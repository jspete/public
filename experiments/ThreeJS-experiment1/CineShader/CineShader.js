! function o(a, s, l) {
    function c(t, e) {
        if (!s[t]) {
            if (!a[t]) {
                var n = "function" == typeof require && require;
                if (!e && n) return n(t, !0);
                if (u) return u(t, !0);
                var r = new Error("Cannot find module '" + t + "'");
                throw r.code = "MODULE_NOT_FOUND", r
            }
            var i = s[t] = {
                exports: {}
            };
            a[t][0].call(i.exports, function(e) {
                return c(a[t][1][e] || e)
            }, i, i.exports, o, a, s, l)
        }
        return s[t].exports
    }
    for (var u = "function" == typeof require && require, e = 0; e < l.length; e++) c(l[e]);
    return c
}({
    1: [function(e, t, n) {
        var r;
        r = function(e) {
            "use strict";
            var E = {},
                C = /[^\s\u00a0]/,
                L = e.Pos;

            function d(e) {
                var t = e.search(C);
                return -1 == t ? 0 : t
            }

            function A(e, t) {
                var n = e.getMode();
                return !1 !== n.useInnerComments && n.innerMode ? e.getModeAt(t) : n
            }
            e.commands.toggleComment = function(e) {
                e.toggleComment()
            }, e.defineExtension("toggleComment", function(e) {
                e = e || E;
                for (var t = this, n = 1 / 0, r = this.listSelections(), i = null, o = r.length - 1; 0 <= o; o--) {
                    var a = r[o].from(),
                        s = r[o].to();
                    a.line >= n || (s.line >= n && (s = L(n, 0)), n = a.line, null == i ? i = t.uncomment(a, s, e) ? "un" : (t.lineComment(a, s, e), "line") : "un" == i ? t.uncomment(a, s, e) : t.lineComment(a, s, e))
                }
            }), e.defineExtension("lineComment", function(o, e, a) {
                a = a || E;
                var s = this,
                    t = A(s, o),
                    n = s.getLine(o.line);
                if (null != n && ! function(e, t, n) {
                        return /\bstring\b/.test(e.getTokenTypeAt(L(t.line, 0))) && !/^[\'\"\`]/.test(n)
                    }(s, o, n)) {
                    var l = a.lineComment || t.lineComment;
                    if (l) {
                        var c = Math.min(0 != e.ch || e.line == o.line ? e.line + 1 : e.line, s.lastLine() + 1),
                            u = null == a.padding ? " " : a.padding,
                            h = a.commentBlankLines || o.line == e.line;
                        s.operation(function() {
                            if (a.indent) {
                                for (var e = null, t = o.line; t < c; ++t) {
                                    var n = (r = s.getLine(t)).slice(0, d(r));
                                    (null == e || e.length > n.length) && (e = n)
                                }
                                for (t = o.line; t < c; ++t) {
                                    var r = s.getLine(t),
                                        i = e.length;
                                    (h || C.test(r)) && (r.slice(0, i) != e && (i = d(r)), s.replaceRange(e + l + u, L(t, 0), L(t, i)))
                                }
                            } else
                                for (t = o.line; t < c; ++t)(h || C.test(s.getLine(t))) && s.replaceRange(l + u, L(t, 0))
                        })
                    } else(a.blockCommentStart || t.blockCommentStart) && (a.fullLines = !0, s.blockComment(o, e, a))
                }
            }), e.defineExtension("blockComment", function(r, i, o) {
                o = o || E;
                var a = this,
                    s = A(a, r),
                    l = o.blockCommentStart || s.blockCommentStart,
                    c = o.blockCommentEnd || s.blockCommentEnd;
                if (l && c) {
                    if (!/\bcomment\b/.test(a.getTokenTypeAt(L(r.line, 0)))) {
                        var u = Math.min(i.line, a.lastLine());
                        u != r.line && 0 == i.ch && C.test(a.getLine(u)) && --u;
                        var h = null == o.padding ? " " : o.padding;
                        r.line > u || a.operation(function() {
                            if (0 != o.fullLines) {
                                var e = C.test(a.getLine(u));
                                a.replaceRange(h + c, L(u)), a.replaceRange(l + h, L(r.line, 0));
                                var t = o.blockCommentLead || s.blockCommentLead;
                                if (null != t)
                                    for (var n = r.line + 1; n <= u; ++n) n == u && !e || a.replaceRange(t + h, L(n, 0))
                            } else a.replaceRange(c, i), a.replaceRange(l, r)
                        })
                    }
                } else(o.lineComment || s.lineComment) && 0 != o.fullLines && a.lineComment(r, i, o)
            }), e.defineExtension("uncomment", function(e, t, n) {
                n = n || E;
                var i, o = this,
                    r = A(o, e),
                    a = Math.min(0 != t.ch || t.line == e.line ? t.line : t.line - 1, o.lastLine()),
                    s = Math.min(e.line, a),
                    l = n.lineComment || r.lineComment,
                    c = [],
                    u = null == n.padding ? " " : n.padding;
                e: if (l) {
                    for (var h = s; h <= a; ++h) {
                        var d = o.getLine(h),
                            p = d.indexOf(l);
                        if (-1 < p && !/comment/.test(o.getTokenTypeAt(L(h, p + 1))) && (p = -1), -1 == p && C.test(d)) break e;
                        if (-1 < p && C.test(d.slice(0, p))) break e;
                        c.push(d)
                    }
                    if (o.operation(function() {
                            for (var e = s; e <= a; ++e) {
                                var t = c[e - s],
                                    n = t.indexOf(l),
                                    r = n + l.length;
                                n < 0 || (t.slice(r, r + u.length) == u && (r += u.length), i = !0, o.replaceRange("", L(e, n), L(e, r)))
                            }
                        }), i) return !0
                }
                var f = n.blockCommentStart || r.blockCommentStart,
                    m = n.blockCommentEnd || r.blockCommentEnd;
                if (!f || !m) return !1;
                var v = n.blockCommentLead || r.blockCommentLead,
                    g = o.getLine(s),
                    y = g.indexOf(f);
                if (-1 == y) return !1;
                var x = a == s ? g : o.getLine(a),
                    b = x.indexOf(m, a == s ? y + f.length : 0),
                    _ = L(s, y + 1),
                    w = L(a, b + 1);
                if (-1 == b || !/comment/.test(o.getTokenTypeAt(_)) || !/comment/.test(o.getTokenTypeAt(w)) || -1 < o.getRange(_, w, "\n").indexOf(m)) return !1;
                var S = g.lastIndexOf(f, e.ch),
                    M = -1 == S ? -1 : g.slice(0, e.ch).indexOf(m, S + f.length);
                if (-1 != S && -1 != M && M + m.length != e.ch) return !1;
                M = x.indexOf(m, t.ch);
                var T = x.slice(t.ch).lastIndexOf(f, M - t.ch);
                return S = -1 == M || -1 == T ? -1 : t.ch + T, (-1 == M || -1 == S || S == t.ch) && (o.operation(function() {
                    o.replaceRange("", L(a, b - (u && x.slice(b - u.length, b) == u ? u.length : 0)), L(a, b + m.length));
                    var e = y + f.length;
                    if (u && g.slice(e, e + u.length) == u && (e += u.length), o.replaceRange("", L(s, y), L(s, e)), v)
                        for (var t = s + 1; t <= a; ++t) {
                            var n = o.getLine(t),
                                r = n.indexOf(v);
                            if (-1 != r && !C.test(n.slice(0, r))) {
                                var i = r + v.length;
                                u && n.slice(i, i + u.length) == u && (i += u.length), o.replaceRange("", L(t, r), L(t, i))
                            }
                        }
                }), !0)
            })
        }, "object" == typeof n && "object" == typeof t ? r(e("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], r) : r(CodeMirror)
    }, {
        "../../lib/codemirror": 5
    }],
    2: [function(e, t, n) {
        var r;
        r = function(h) {
            function d(e, t, n) {
                var r, i = e.getWrapperElement();
                return (r = i.appendChild(document.createElement("div"))).className = n ? "CodeMirror-dialog CodeMirror-dialog-bottom" : "CodeMirror-dialog CodeMirror-dialog-top", "string" == typeof t ? r.innerHTML = t : r.appendChild(t), h.addClass(i, "dialog-opened"), r
            }

            function p(e, t) {
                e.state.currentNotificationClose && e.state.currentNotificationClose(), e.state.currentNotificationClose = t
            }
            h.defineExtension("openDialog", function(e, t, n) {
                n = n || {}, p(this, null);
                var r = d(this, e, n.bottom),
                    i = !1,
                    o = this;

                function a(e) {
                    if ("string" == typeof e) l.value = e;
                    else {
                        if (i) return;
                        i = !0, h.rmClass(r.parentNode, "dialog-opened"), r.parentNode.removeChild(r), o.focus(), n.onClose && n.onClose(r)
                    }
                }
                var s, l = r.getElementsByTagName("input")[0];
                return l ? (l.focus(), n.value && (l.value = n.value, !1 !== n.selectValueOnOpen && l.select()), n.onInput && h.on(l, "input", function(e) {
                    n.onInput(e, l.value, a)
                }), n.onKeyUp && h.on(l, "keyup", function(e) {
                    n.onKeyUp(e, l.value, a)
                }), h.on(l, "keydown", function(e) {
                    n && n.onKeyDown && n.onKeyDown(e, l.value, a) || ((27 == e.keyCode || !1 !== n.closeOnEnter && 13 == e.keyCode) && (l.blur(), h.e_stop(e), a()), 13 == e.keyCode && t(l.value, e))
                }), !1 !== n.closeOnBlur && h.on(l, "blur", a)) : (s = r.getElementsByTagName("button")[0]) && (h.on(s, "click", function() {
                    a(), o.focus()
                }), !1 !== n.closeOnBlur && h.on(s, "blur", a), s.focus()), a
            }), h.defineExtension("openConfirm", function(e, t, n) {
                p(this, null);
                var r = d(this, e, n && n.bottom),
                    i = r.getElementsByTagName("button"),
                    o = !1,
                    a = this,
                    s = 1;

                function l() {
                    o || (o = !0, h.rmClass(r.parentNode, "dialog-opened"), r.parentNode.removeChild(r), a.focus())
                }
                i[0].focus();
                for (var c = 0; c < i.length; ++c) {
                    var u = i[c];
                    ! function(t) {
                        h.on(u, "click", function(e) {
                            h.e_preventDefault(e), l(), t && t(a)
                        })
                    }(t[c]), h.on(u, "blur", function() {
                        --s, setTimeout(function() {
                            s <= 0 && l()
                        }, 200)
                    }), h.on(u, "focus", function() {
                        ++s
                    })
                }
            }), h.defineExtension("openNotification", function(e, t) {
                p(this, a);
                var n, r = d(this, e, t && t.bottom),
                    i = !1,
                    o = t && void 0 !== t.duration ? t.duration : 5e3;

                function a() {
                    i || (i = !0, clearTimeout(n), h.rmClass(r.parentNode, "dialog-opened"), r.parentNode.removeChild(r))
                }
                return h.on(r, "click", function(e) {
                    h.e_preventDefault(e), a()
                }), o && (n = setTimeout(a, o)), a
            })
        }, "object" == typeof n && "object" == typeof t ? r(e("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], r) : r(CodeMirror)
    }, {
        "../../lib/codemirror": 5
    }],
    3: [function(e, t, n) {
        var r;
        r = function(l) {
            "use strict";

            function t() {
                this.posFrom = this.posTo = this.lastQuery = this.query = null, this.overlay = null
            }

            function c(e) {
                return e.state.search || (e.state.search = new t)
            }

            function r(e) {
                return "string" == typeof e && e == e.toLowerCase()
            }

            function u(e, t, n) {
                return e.getSearchCursor(t, n, {
                    caseFold: r(t),
                    multiline: !0
                })
            }

            function h(e, t, n, r, i) {
                e.openDialog ? e.openDialog(t, i, {
                    value: r,
                    selectValueOnOpen: !0
                }) : i(prompt(n, r))
            }

            function d(e) {
                return e.replace(/\\([nrt\\])/g, function(e, t) {
                    return "n" == t ? "\n" : "r" == t ? "\r" : "t" == t ? "\t" : "\\" == t ? "\\" : e
                })
            }

            function i(e) {
                var t = e.match(/^\/(.*)\/([a-z]*)$/);
                if (t) try {
                    e = new RegExp(t[1], -1 == t[2].indexOf("i") ? "" : "i")
                } catch (e) {} else e = d(e);
                return ("string" == typeof e ? "" == e : e.test("")) && (e = /x^/), e
            }

            function p(e, t, n) {
                t.queryText = n, t.query = i(n), e.removeOverlay(t.overlay, r(t.query)), t.overlay = function(n, e) {
                    return "string" == typeof n ? n = new RegExp(n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), e ? "gi" : "g") : n.global || (n = new RegExp(n.source, n.ignoreCase ? "gi" : "g")), {
                        token: function(e) {
                            n.lastIndex = e.pos;
                            var t = n.exec(e.string);
                            if (t && t.index == e.pos) return e.pos += t[0].length || 1, "searching";
                            t ? e.pos = t.index : e.skipToEnd()
                        }
                    }
                }(t.query, r(t.query)), e.addOverlay(t.overlay), e.showMatchesOnScrollbar && (t.annotate && (t.annotate.clear(), t.annotate = null), t.annotate = e.showMatchesOnScrollbar(t.query, r(t.query)))
            }

            function n(o, t, e, n) {
                var r = c(o);
                if (r.query) return f(o, t);
                var i = o.getSelection() || r.lastQuery;
                if (i instanceof RegExp && "x^" == i.source && (i = null), e && o.openDialog) {
                    var a = null,
                        s = function(e, t) {
                            l.e_stop(t), e && (e != r.queryText && (p(o, r, e), r.posFrom = r.posTo = o.getCursor()), a && (a.style.opacity = 1), f(o, t.shiftKey, function(e, t) {
                                var n;
                                t.line < 3 && document.querySelector && (n = o.display.wrapper.querySelector(".CodeMirror-dialog")) && n.getBoundingClientRect().bottom - 4 > o.cursorCoords(t, "window").top && ((a = n).style.opacity = .4)
                            }))
                        };
                    ! function(e, t, n, r, i) {
                        e.openDialog(t, r, {
                            value: n,
                            selectValueOnOpen: !0,
                            closeOnEnter: !1,
                            onClose: function() {
                                m(e)
                            },
                            onKeyDown: i
                        })
                    }(o, v(o), i, s, function(e, t) {
                        var n = l.keyName(e),
                            r = o.getOption("extraKeys"),
                            i = r && r[n] || l.keyMap[o.getOption("keyMap")][n];
                        "findNext" == i || "findPrev" == i || "findPersistentNext" == i || "findPersistentPrev" == i ? (l.e_stop(e), p(o, c(o), t), o.execCommand(i)) : "find" != i && "findPersistent" != i || (l.e_stop(e), s(t, e))
                    }), n && i && (p(o, r, i), f(o, t))
                } else h(o, v(o), "Search for:", i, function(e) {
                    e && !r.query && o.operation(function() {
                        p(o, r, e), r.posFrom = r.posTo = o.getCursor(), f(o, t)
                    })
                })
            }

            function f(n, r, i) {
                n.operation(function() {
                    var e = c(n),
                        t = u(n, e.query, r ? e.posFrom : e.posTo);
                    (t.find(r) || (t = u(n, e.query, r ? l.Pos(n.lastLine()) : l.Pos(n.firstLine(), 0))).find(r)) && (n.setSelection(t.from(), t.to()), n.scrollIntoView({
                        from: t.from(),
                        to: t.to()
                    }, 20), e.posFrom = t.from(), e.posTo = t.to(), i && i(t.from(), t.to()))
                })
            }

            function m(t) {
                t.operation(function() {
                    var e = c(t);
                    e.lastQuery = e.query, e.query && (e.query = e.queryText = null, t.removeOverlay(e.overlay), e.annotate && (e.annotate.clear(), e.annotate = null))
                })
            }

            function v(e) {
                return '<span class="CodeMirror-search-label">' + e.phrase("Search:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + e.phrase("(Use /re/ syntax for regexp search)") + "</span>"
            }

            function g(t, r, i) {
                t.operation(function() {
                    for (var e = u(t, r); e.findNext();)
                        if ("string" != typeof r) {
                            var n = t.getRange(e.from(), e.to()).match(r);
                            e.replace(i.replace(/\$(\d)/g, function(e, t) {
                                return n[t]
                            }))
                        } else e.replace(i)
                })
            }

            function o(s, e) {
                if (!s.getOption("readOnly")) {
                    var t = s.getSelection() || c(s).lastQuery,
                        n = '<span class="CodeMirror-search-label">' + (e ? s.phrase("Replace all:") : s.phrase("Replace:")) + "</span>";
                    h(s, n + function(e) {
                        return ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + e.phrase("(Use /re/ syntax for regexp search)") + "</span>"
                    }(s), n, t, function(a) {
                        a && (a = i(a), h(s, function(e) {
                            return '<span class="CodeMirror-search-label">' + e.phrase("With:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>'
                        }(s), s.phrase("Replace with:"), "", function(r) {
                            if (r = d(r), e) g(s, a, r);
                            else {
                                m(s);
                                var i = u(s, a, s.getCursor("from")),
                                    o = function() {
                                        var e, t = i.from();
                                        !(e = i.findNext()) && (i = u(s, a), !(e = i.findNext()) || t && i.from().line == t.line && i.from().ch == t.ch) || (s.setSelection(i.from(), i.to()), s.scrollIntoView({
                                            from: i.from(),
                                            to: i.to()
                                        }), function(e, t, n, r) {
                                            e.openConfirm ? e.openConfirm(t, r) : confirm(n) && r[0]()
                                        }(s, function(e) {
                                            return '<span class="CodeMirror-search-label">' + e.phrase("Replace?") + "</span> <button>" + e.phrase("Yes") + "</button> <button>" + e.phrase("No") + "</button> <button>" + e.phrase("All") + "</button> <button>" + e.phrase("Stop") + "</button> "
                                        }(s), s.phrase("Replace?"), [function() {
                                            n(e)
                                        }, o, function() {
                                            g(s, a, r)
                                        }]))
                                    },
                                    n = function(n) {
                                        i.replace("string" == typeof a ? r : r.replace(/\$(\d)/g, function(e, t) {
                                            return n[t]
                                        })), o()
                                    };
                                o()
                            }
                        }))
                    })
                }
            }
            l.commands.find = function(e) {
                m(e), n(e)
            }, l.commands.findPersistent = function(e) {
                m(e), n(e, !1, !0)
            }, l.commands.findPersistentNext = function(e) {
                n(e, !1, !0, !0)
            }, l.commands.findPersistentPrev = function(e) {
                n(e, !0, !0, !0)
            }, l.commands.findNext = n, l.commands.findPrev = function(e) {
                n(e, !0)
            }, l.commands.clearSearch = m, l.commands.replace = o, l.commands.replaceAll = function(e) {
                o(e, !0)
            }
        }, "object" == typeof n && "object" == typeof t ? r(e("../../lib/codemirror"), e("./searchcursor"), e("../dialog/dialog")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror", "./searchcursor", "../dialog/dialog"], r) : r(CodeMirror)
    }, {
        "../../lib/codemirror": 5,
        "../dialog/dialog": 2,
        "./searchcursor": 4
    }],
    4: [function(e, t, n) {
        var r;
        r = function(i) {
            "use strict";
            var g, y, x = i.Pos;

            function f(e, t) {
                for (var n = function(e) {
                        var t = e.flags;
                        return null != t ? t : (e.ignoreCase ? "i" : "") + (e.global ? "g" : "") + (e.multiline ? "m" : "")
                    }(e), r = n, i = 0; i < t.length; i++) - 1 == r.indexOf(t.charAt(i)) && (r += t.charAt(i));
                return n == r ? e : new RegExp(e.source, r)
            }

            function m(e, t, n) {
                t = f(t, "g");
                for (var r = n.line, i = n.ch, o = e.lastLine(); r <= o; r++, i = 0) {
                    t.lastIndex = i;
                    var a = e.getLine(r),
                        s = t.exec(a);
                    if (s) return {
                        from: x(r, s.index),
                        to: x(r, s.index + s[0].length),
                        match: s
                    }
                }
            }

            function v(e, t) {
                for (var n, r = 0;;) {
                    t.lastIndex = r;
                    var i = t.exec(e);
                    if (!i) return n;
                    if ((r = (n = i).index + (n[0].length || 1)) == e.length) return n
                }
            }

            function b(e, t, n, r) {
                if (e.length == t.length) return n;
                for (var i = 0, o = n + Math.max(0, e.length - t.length);;) {
                    if (i == o) return i;
                    var a = i + o >> 1,
                        s = r(e.slice(0, a)).length;
                    if (s == n) return a;
                    n < s ? o = a : i = 1 + a
                }
            }

            function r(n, r, e, t) {
                var i;
                this.atOccurrence = !1, this.doc = n, e = e ? n.clipPos(e) : x(0, 0), this.pos = {
                    from: e,
                    to: e
                }, "object" == typeof t ? i = t.caseFold : (i = t, t = null), "string" == typeof r ? (null == i && (i = !1), this.matches = function(e, t) {
                    return (e ? function(e, t, n, r) {
                        if (!t.length) return null;
                        var i = r ? g : y,
                            o = i(t).split(/\r|\n\r?/);
                        e: for (var a = n.line, s = n.ch, l = e.firstLine() - 1 + o.length; l <= a; a--, s = -1) {
                            var c = e.getLine(a); - 1 < s && (c = c.slice(0, s));
                            var u = i(c);
                            if (1 == o.length) {
                                var h = u.lastIndexOf(o[0]);
                                if (-1 == h) continue e;
                                return {
                                    from: x(a, b(c, u, h, i)),
                                    to: x(a, b(c, u, h + o[0].length, i))
                                }
                            }
                            var d = o[o.length - 1];
                            if (u.slice(0, d.length) == d) {
                                var p = 1;
                                for (n = a - o.length + 1; p < o.length - 1; p++)
                                    if (i(e.getLine(n + p)) != o[p]) continue e;
                                var f = e.getLine(a + 1 - o.length),
                                    m = i(f);
                                if (m.slice(m.length - o[0].length) == o[0]) return {
                                    from: x(a + 1 - o.length, b(f, m, f.length - o[0].length, i)),
                                    to: x(a, b(c, u, d.length, i))
                                }
                            }
                        }
                    } : function(e, t, n, r) {
                        if (!t.length) return null;
                        var i = r ? g : y,
                            o = i(t).split(/\r|\n\r?/);
                        e: for (var a = n.line, s = n.ch, l = e.lastLine() + 1 - o.length; a <= l; a++, s = 0) {
                            var c = e.getLine(a).slice(s),
                                u = i(c);
                            if (1 == o.length) {
                                var h = u.indexOf(o[0]);
                                if (-1 == h) continue e;
                                n = b(c, u, h, i) + s;
                                return {
                                    from: x(a, b(c, u, h, i) + s),
                                    to: x(a, b(c, u, h + o[0].length, i) + s)
                                }
                            }
                            var d = u.length - o[0].length;
                            if (u.slice(d) == o[0]) {
                                for (var p = 1; p < o.length - 1; p++)
                                    if (i(e.getLine(a + p)) != o[p]) continue e;
                                var f = e.getLine(a + o.length - 1),
                                    m = i(f),
                                    v = o[o.length - 1];
                                if (m.slice(0, v.length) == v) return {
                                    from: x(a, b(c, u, d, i) + s),
                                    to: x(a + o.length - 1, b(f, m, v.length, i))
                                }
                            }
                        }
                    })(n, r, t, i)
                }) : (r = f(r, "gm"), t && !1 === t.multiline ? this.matches = function(e, t) {
                    return (e ? function(e, t, n) {
                        t = f(t, "g");
                        for (var r = n.line, i = n.ch, o = e.firstLine(); o <= r; r--, i = -1) {
                            var a = e.getLine(r); - 1 < i && (a = a.slice(0, i));
                            var s = v(a, t);
                            if (s) return {
                                from: x(r, s.index),
                                to: x(r, s.index + s[0].length),
                                match: s
                            }
                        }
                    } : m)(n, r, t)
                } : this.matches = function(e, t) {
                    return (e ? function(e, t, n) {
                        t = f(t, "gm");
                        for (var r, i = 1, o = n.line, a = e.firstLine(); a <= o;) {
                            for (var s = 0; s < i; s++) {
                                var l = e.getLine(o--);
                                r = null == r ? l.slice(0, n.ch) : l + "\n" + r
                            }
                            i *= 2;
                            var c = v(r, t);
                            if (c) {
                                var u = r.slice(0, c.index).split("\n"),
                                    h = c[0].split("\n"),
                                    d = o + u.length,
                                    p = u[u.length - 1].length;
                                return {
                                    from: x(d, p),
                                    to: x(d + h.length - 1, 1 == h.length ? p + h[0].length : h[h.length - 1].length),
                                    match: c
                                }
                            }
                        }
                    } : function(e, t, n) {
                        if (! function(e) {
                                return /\\s|\\n|\n|\\W|\\D|\[\^/.test(e.source)
                            }(t)) return m(e, t, n);
                        t = f(t, "gm");
                        for (var r, i = 1, o = n.line, a = e.lastLine(); o <= a;) {
                            for (var s = 0; s < i && !(a < o); s++) {
                                var l = e.getLine(o++);
                                r = null == r ? l : r + "\n" + l
                            }
                            i *= 2, t.lastIndex = n.ch;
                            var c = t.exec(r);
                            if (c) {
                                var u = r.slice(0, c.index).split("\n"),
                                    h = c[0].split("\n"),
                                    d = n.line + u.length - 1,
                                    p = u[u.length - 1].length;
                                return {
                                    from: x(d, p),
                                    to: x(d + h.length - 1, 1 == h.length ? p + h[0].length : h[h.length - 1].length),
                                    match: c
                                }
                            }
                        }
                    })(n, r, t)
                })
            }
            y = String.prototype.normalize ? (g = function(e) {
                return e.normalize("NFD").toLowerCase()
            }, function(e) {
                return e.normalize("NFD")
            }) : (g = function(e) {
                return e.toLowerCase()
            }, function(e) {
                return e
            }), r.prototype = {
                findNext: function() {
                    return this.find(!1)
                },
                findPrevious: function() {
                    return this.find(!0)
                },
                find: function(e) {
                    for (var t = this.matches(e, this.doc.clipPos(e ? this.pos.from : this.pos.to)); t && 0 == i.cmpPos(t.from, t.to);) e ? t.from.ch ? t.from = x(t.from.line, t.from.ch - 1) : t = t.from.line == this.doc.firstLine() ? null : this.matches(e, this.doc.clipPos(x(t.from.line - 1))) : t.to.ch < this.doc.getLine(t.to.line).length ? t.to = x(t.to.line, t.to.ch + 1) : t = t.to.line == this.doc.lastLine() ? null : this.matches(e, x(t.to.line + 1, 0));
                    if (t) return this.pos = t, this.atOccurrence = !0, this.pos.match || !0;
                    var n = x(e ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
                    return this.pos = {
                        from: n,
                        to: n
                    }, this.atOccurrence = !1
                },
                from: function() {
                    if (this.atOccurrence) return this.pos.from
                },
                to: function() {
                    if (this.atOccurrence) return this.pos.to
                },
                replace: function(e, t) {
                    if (this.atOccurrence) {
                        var n = i.splitLines(e);
                        this.doc.replaceRange(n, this.pos.from, this.pos.to, t), this.pos.to = x(this.pos.from.line + n.length - 1, n[n.length - 1].length + (1 == n.length ? this.pos.from.ch : 0))
                    }
                }
            }, i.defineExtension("getSearchCursor", function(e, t, n) {
                return new r(this.doc, e, t, n)
            }), i.defineDocExtension("getSearchCursor", function(e, t, n) {
                return new r(this, e, t, n)
            }), i.defineExtension("selectMatches", function(e, t) {
                for (var n = [], r = this.getSearchCursor(e, this.getCursor("from"), t); r.findNext() && !(0 < i.cmpPos(r.to(), this.getCursor("to")));) n.push({
                    anchor: r.from(),
                    head: r.to()
                });
                n.length && this.setSelections(n, 0)
            })
        }, "object" == typeof n && "object" == typeof t ? r(e("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], r) : r(CodeMirror)
    }, {
        "../../lib/codemirror": 5
    }],
    5: [function(e, t, n) {
        var r, i;
        r = this, i = function() {
            "use strict";
            var e = navigator.userAgent,
                t = navigator.platform,
                m = /gecko\/\d/i.test(e),
                n = /MSIE \d/.test(e),
                r = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(e),
                i = /Edge\/(\d+)/.exec(e),
                _ = n || r || i,
                w = _ && (n ? document.documentMode || 6 : +(i || r)[1]),
                x = !i && /WebKit\//.test(e),
                o = x && /Qt\/\d+\.\d+/.test(e),
                a = !i && /Chrome\//.test(e),
                v = /Opera\//.test(e),
                l = /Apple Computer/.test(navigator.vendor),
                s = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(e),
                c = /PhantomJS/.test(e),
                u = !i && /AppleWebKit/.test(e) && /Mobile\/\w+/.test(e),
                h = /Android/.test(e),
                d = u || h || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(e),
                b = u || /Mac/.test(t),
                p = /\bCrOS\b/.test(e),
                f = /win/i.test(t),
                g = v && e.match(/Version\/(\d*\.\d*)/);
            (g = g && Number(g[1])) && 15 <= g && (x = !(v = !1));
            var y = b && (o || v && (null == g || g < 12.11)),
                S = m || _ && 9 <= w;

            function M(e) {
                return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*")
            }
            var T, E = function(e, t) {
                var n = e.className,
                    r = M(t).exec(n);
                if (r) {
                    var i = n.slice(r.index + r[0].length);
                    e.className = n.slice(0, r.index) + (i ? r[1] + i : "")
                }
            };

            function C(e) {
                for (var t = e.childNodes.length; 0 < t; --t) e.removeChild(e.firstChild);
                return e
            }

            function L(e, t) {
                return C(e).appendChild(t)
            }

            function R(e, t, n, r) {
                var i = document.createElement(e);
                if (n && (i.className = n), r && (i.style.cssText = r), "string" == typeof t) i.appendChild(document.createTextNode(t));
                else if (t)
                    for (var o = 0; o < t.length; ++o) i.appendChild(t[o]);
                return i
            }

            function A(e, t, n, r) {
                var i = R(e, t, n, r);
                return i.setAttribute("role", "presentation"), i
            }

            function P(e, t) {
                if (3 == t.nodeType && (t = t.parentNode), e.contains) return e.contains(t);
                do {
                    if (11 == t.nodeType && (t = t.host), t == e) return !0
                } while (t = t.parentNode)
            }

            function O() {
                var t;
                try {
                    t = document.activeElement
                } catch (e) {
                    t = document.body || null
                }
                for (; t && t.shadowRoot && t.shadowRoot.activeElement;) t = t.shadowRoot.activeElement;
                return t
            }

            function I(e, t) {
                var n = e.className;
                M(t).test(n) || (e.className += (n ? " " : "") + t)
            }

            function D(e, t) {
                for (var n = e.split(" "), r = 0; r < n.length; r++) n[r] && !M(n[r]).test(t) && (t += " " + n[r]);
                return t
            }
            T = document.createRange ? function(e, t, n, r) {
                var i = document.createRange();
                return i.setEnd(r || e, n), i.setStart(e, t), i
            } : function(e, t, n) {
                var r = document.body.createTextRange();
                try {
                    r.moveToElementText(e.parentNode)
                } catch (e) {
                    return r
                }
                return r.collapse(!0), r.moveEnd("character", n), r.moveStart("character", t), r
            };
            var N = function(e) {
                e.select()
            };

            function k(e) {
                var t = Array.prototype.slice.call(arguments, 1);
                return function() {
                    return e.apply(null, t)
                }
            }

            function z(e, t, n) {
                for (var r in t = t || {}, e) !e.hasOwnProperty(r) || !1 === n && t.hasOwnProperty(r) || (t[r] = e[r]);
                return t
            }

            function F(e, t, n, r, i) {
                null == t && -1 == (t = e.search(/[^\s\u00a0]/)) && (t = e.length);
                for (var o = r || 0, a = i || 0;;) {
                    var s = e.indexOf("\t", o);
                    if (s < 0 || t <= s) return a + (t - o);
                    a += s - o, a += n - a % n, o = s + 1
                }
            }
            u ? N = function(e) {
                e.selectionStart = 0, e.selectionEnd = e.value.length
            } : _ && (N = function(e) {
                try {
                    e.select()
                } catch (e) {}
            });
            var B = function() {
                this.id = null, this.f = null, this.time = 0, this.handler = k(this.onTimeout, this)
            };

            function U(e, t) {
                for (var n = 0; n < e.length; ++n)
                    if (e[n] == t) return n;
                return -1
            }
            B.prototype.onTimeout = function(e) {
                e.id = 0, e.time <= +new Date ? e.f() : setTimeout(e.handler, e.time - +new Date)
            }, B.prototype.set = function(e, t) {
                this.f = t;
                var n = +new Date + e;
                (!this.id || n < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = n)
            };
            var H = 30,
                G = {
                    toString: function() {
                        return "CodeMirror.Pass"
                    }
                },
                V = {
                    scroll: !1
                },
                W = {
                    origin: "*mouse"
                },
                j = {
                    origin: "+move"
                };

            function q(e, t, n) {
                for (var r = 0, i = 0;;) {
                    var o = e.indexOf("\t", r); - 1 == o && (o = e.length);
                    var a = o - r;
                    if (o == e.length || t <= i + a) return r + Math.min(a, t - i);
                    if (i += o - r, r = o + 1, t <= (i += n - i % n)) return r
                }
            }
            var X = [""];

            function Y(e) {
                for (; X.length <= e;) X.push(Z(X) + " ");
                return X[e]
            }

            function Z(e) {
                return e[e.length - 1]
            }

            function K(e, t) {
                for (var n = [], r = 0; r < e.length; r++) n[r] = t(e[r], r);
                return n
            }

            function J() {}

            function Q(e, t) {
                var n;
                return n = Object.create ? Object.create(e) : (J.prototype = e, new J), t && z(t, n), n
            }
            var $ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

            function ee(e) {
                return /\w/.test(e) || "Â€" < e && (e.toUpperCase() != e.toLowerCase() || $.test(e))
            }

            function te(e, t) {
                return t ? !!(-1 < t.source.indexOf("\\w") && ee(e)) || t.test(e) : ee(e)
            }

            function ne(e) {
                for (var t in e)
                    if (e.hasOwnProperty(t) && e[t]) return !1;
                return !0
            }
            var re = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

            function ie(e) {
                return 768 <= e.charCodeAt(0) && re.test(e)
            }

            function oe(e, t, n) {
                for (;
                    (n < 0 ? 0 < t : t < e.length) && ie(e.charAt(t));) t += n;
                return t
            }

            function ae(e, t, n) {
                for (var r = n < t ? -1 : 1;;) {
                    if (t == n) return t;
                    var i = (t + n) / 2,
                        o = r < 0 ? Math.ceil(i) : Math.floor(i);
                    if (o == t) return e(o) ? t : n;
                    e(o) ? n = o : t = o + r
                }
            }
            var se = null;

            function le(e, t, n) {
                var r;
                se = null;
                for (var i = 0; i < e.length; ++i) {
                    var o = e[i];
                    if (o.from < t && o.to > t) return i;
                    o.to == t && (o.from != o.to && "before" == n ? r = i : se = i), o.from == t && (o.from != o.to && "before" != n ? r = i : se = i)
                }
                return null != r ? r : se
            }
            var ce, ue, he, de, pe, fe, me, ve = (ce = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", ue = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111", he = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, de = /[stwN]/, pe = /[LRr]/, fe = /[Lb1n]/, me = /[1n]/, function(e, t) {
                var n = "ltr" == t ? "L" : "R";
                if (0 == e.length || "ltr" == t && !he.test(e)) return !1;
                for (var r, i = e.length, o = [], a = 0; a < i; ++a) o.push((r = e.charCodeAt(a)) <= 247 ? ce.charAt(r) : 1424 <= r && r <= 1524 ? "R" : 1536 <= r && r <= 1785 ? ue.charAt(r - 1536) : 1774 <= r && r <= 2220 ? "r" : 8192 <= r && r <= 8203 ? "w" : 8204 == r ? "b" : "L");
                for (var s = 0, l = n; s < i; ++s) {
                    var c = o[s];
                    "m" == c ? o[s] = l : l = c
                }
                for (var u = 0, h = n; u < i; ++u) {
                    var d = o[u];
                    "1" == d && "r" == h ? o[u] = "n" : pe.test(d) && "r" == (h = d) && (o[u] = "R")
                }
                for (var p = 1, f = o[0]; p < i - 1; ++p) {
                    var m = o[p];
                    "+" == m && "1" == f && "1" == o[p + 1] ? o[p] = "1" : "," != m || f != o[p + 1] || "1" != f && "n" != f || (o[p] = f), f = m
                }
                for (var v = 0; v < i; ++v) {
                    var g = o[v];
                    if ("," == g) o[v] = "N";
                    else if ("%" == g) {
                        var y = void 0;
                        for (y = v + 1; y < i && "%" == o[y]; ++y);
                        for (var x = v && "!" == o[v - 1] || y < i && "1" == o[y] ? "1" : "N", b = v; b < y; ++b) o[b] = x;
                        v = y - 1
                    }
                }
                for (var _ = 0, w = n; _ < i; ++_) {
                    var S = o[_];
                    "L" == w && "1" == S ? o[_] = "L" : pe.test(S) && (w = S)
                }
                for (var M = 0; M < i; ++M)
                    if (de.test(o[M])) {
                        var T = void 0;
                        for (T = M + 1; T < i && de.test(o[T]); ++T);
                        for (var E = "L" == (M ? o[M - 1] : n), C = E == ("L" == (T < i ? o[T] : n)) ? E ? "L" : "R" : n, L = M; L < T; ++L) o[L] = C;
                        M = T - 1
                    }
                for (var A, R = [], P = 0; P < i;)
                    if (fe.test(o[P])) {
                        var O = P;
                        for (++P; P < i && fe.test(o[P]); ++P);
                        R.push(new ge(0, O, P))
                    } else {
                        var I = P,
                            D = R.length;
                        for (++P; P < i && "L" != o[P]; ++P);
                        for (var N = I; N < P;)
                            if (me.test(o[N])) {
                                I < N && R.splice(D, 0, new ge(1, I, N));
                                var k = N;
                                for (++N; N < P && me.test(o[N]); ++N);
                                R.splice(D, 0, new ge(2, k, N)), I = N
                            } else ++N;
                        I < P && R.splice(D, 0, new ge(1, I, P))
                    }
                return "ltr" == t && (1 == R[0].level && (A = e.match(/^\s+/)) && (R[0].from = A[0].length, R.unshift(new ge(0, 0, A[0].length))), 1 == Z(R).level && (A = e.match(/\s+$/)) && (Z(R).to -= A[0].length, R.push(new ge(0, i - A[0].length, i)))), "rtl" == t ? R.reverse() : R
            });

            function ge(e, t, n) {
                this.level = e, this.from = t, this.to = n
            }

            function ye(e, t) {
                var n = e.order;
                return null == n && (n = e.order = ve(e.text, t)), n
            }
            var xe = [],
                be = function(e, t, n) {
                    if (e.addEventListener) e.addEventListener(t, n, !1);
                    else if (e.attachEvent) e.attachEvent("on" + t, n);
                    else {
                        var r = e._handlers || (e._handlers = {});
                        r[t] = (r[t] || xe).concat(n)
                    }
                };

            function _e(e, t) {
                return e._handlers && e._handlers[t] || xe
            }

            function we(e, t, n) {
                if (e.removeEventListener) e.removeEventListener(t, n, !1);
                else if (e.detachEvent) e.detachEvent("on" + t, n);
                else {
                    var r = e._handlers,
                        i = r && r[t];
                    if (i) {
                        var o = U(i, n); - 1 < o && (r[t] = i.slice(0, o).concat(i.slice(o + 1)))
                    }
                }
            }

            function Se(e, t) {
                var n = _e(e, t);
                if (n.length)
                    for (var r = Array.prototype.slice.call(arguments, 2), i = 0; i < n.length; ++i) n[i].apply(null, r)
            }

            function Me(e, t, n) {
                return "string" == typeof t && (t = {
                    type: t,
                    preventDefault: function() {
                        this.defaultPrevented = !0
                    }
                }), Se(e, n || t.type, e, t), Re(t) || t.codemirrorIgnore
            }

            function Te(e) {
                var t = e._handlers && e._handlers.cursorActivity;
                if (t)
                    for (var n = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), r = 0; r < t.length; ++r) - 1 == U(n, t[r]) && n.push(t[r])
            }

            function Ee(e, t) {
                return 0 < _e(e, t).length
            }

            function Ce(e) {
                e.prototype.on = function(e, t) {
                    be(this, e, t)
                }, e.prototype.off = function(e, t) {
                    we(this, e, t)
                }
            }

            function Le(e) {
                e.preventDefault ? e.preventDefault() : e.returnValue = !1
            }

            function Ae(e) {
                e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
            }

            function Re(e) {
                return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
            }

            function Pe(e) {
                Le(e), Ae(e)
            }

            function Oe(e) {
                return e.target || e.srcElement
            }

            function Ie(e) {
                var t = e.which;
                return null == t && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), b && e.ctrlKey && 1 == t && (t = 3), t
            }
            var De, Ne, ke = function() {
                if (_ && w < 9) return !1;
                var e = R("div");
                return "draggable" in e || "dragDrop" in e
            }();

            function ze(e) {
                if (null == De) {
                    var t = R("span", "â€‹");
                    L(e, R("span", [t, document.createTextNode("x")])), 0 != e.firstChild.offsetHeight && (De = t.offsetWidth <= 1 && 2 < t.offsetHeight && !(_ && w < 8))
                }
                var n = De ? R("span", "â€‹") : R("span", "Â ", null, "display: inline-block; width: 1px; margin-right: -1px");
                return n.setAttribute("cm-text", ""), n
            }

            function Fe(e) {
                if (null != Ne) return Ne;
                var t = L(e, document.createTextNode("AØ®A")),
                    n = T(t, 0, 1).getBoundingClientRect(),
                    r = T(t, 1, 2).getBoundingClientRect();
                return C(e), !(!n || n.left == n.right) && (Ne = r.right - n.right < 3)
            }
            var Be, Ue = 3 != "\n\nb".split(/\n/).length ? function(e) {
                    for (var t = 0, n = [], r = e.length; t <= r;) {
                        var i = e.indexOf("\n", t); - 1 == i && (i = e.length);
                        var o = e.slice(t, "\r" == e.charAt(i - 1) ? i - 1 : i),
                            a = o.indexOf("\r"); - 1 != a ? (n.push(o.slice(0, a)), t += a + 1) : (n.push(o), t = i + 1)
                    }
                    return n
                } : function(e) {
                    return e.split(/\r\n?|\n/)
                },
                He = window.getSelection ? function(e) {
                    try {
                        return e.selectionStart != e.selectionEnd
                    } catch (e) {
                        return !1
                    }
                } : function(e) {
                    var t;
                    try {
                        t = e.ownerDocument.selection.createRange()
                    } catch (e) {}
                    return !(!t || t.parentElement() != e) && 0 != t.compareEndPoints("StartToEnd", t)
                },
                Ge = "oncopy" in (Be = R("div")) || (Be.setAttribute("oncopy", "return;"), "function" == typeof Be.oncopy),
                Ve = null;
            var We = {},
                je = {};

            function qe(e) {
                if ("string" == typeof e && je.hasOwnProperty(e)) e = je[e];
                else if (e && "string" == typeof e.name && je.hasOwnProperty(e.name)) {
                    var t = je[e.name];
                    "string" == typeof t && (t = {
                        name: t
                    }), (e = Q(t, e)).name = t.name
                } else {
                    if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+xml$/.test(e)) return qe("application/xml");
                    if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+json$/.test(e)) return qe("application/json")
                }
                return "string" == typeof e ? {
                    name: e
                } : e || {
                    name: "null"
                }
            }

            function Xe(e, t) {
                t = qe(t);
                var n = We[t.name];
                if (!n) return Xe(e, "text/plain");
                var r = n(e, t);
                if (Ye.hasOwnProperty(t.name)) {
                    var i = Ye[t.name];
                    for (var o in i) i.hasOwnProperty(o) && (r.hasOwnProperty(o) && (r["_" + o] = r[o]), r[o] = i[o])
                }
                if (r.name = t.name, t.helperType && (r.helperType = t.helperType), t.modeProps)
                    for (var a in t.modeProps) r[a] = t.modeProps[a];
                return r
            }
            var Ye = {};

            function Ze(e, t) {
                z(t, Ye.hasOwnProperty(e) ? Ye[e] : Ye[e] = {})
            }

            function Ke(e, t) {
                if (!0 === t) return t;
                if (e.copyState) return e.copyState(t);
                var n = {};
                for (var r in t) {
                    var i = t[r];
                    i instanceof Array && (i = i.concat([])), n[r] = i
                }
                return n
            }

            function Je(e, t) {
                for (var n; e.innerMode && (n = e.innerMode(t)) && n.mode != e;) t = n.state, e = n.mode;
                return n || {
                    mode: e,
                    state: t
                }
            }

            function Qe(e, t, n) {
                return !e.startState || e.startState(t, n)
            }
            var $e = function(e, t, n) {
                this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = n
            };

            function et(e, t) {
                if ((t -= e.first) < 0 || t >= e.size) throw new Error("There is no line " + (t + e.first) + " in the document.");
                for (var n = e; !n.lines;)
                    for (var r = 0;; ++r) {
                        var i = n.children[r],
                            o = i.chunkSize();
                        if (t < o) {
                            n = i;
                            break
                        }
                        t -= o
                    }
                return n.lines[t]
            }

            function tt(e, n, r) {
                var i = [],
                    o = n.line;
                return e.iter(n.line, r.line + 1, function(e) {
                    var t = e.text;
                    o == r.line && (t = t.slice(0, r.ch)), o == n.line && (t = t.slice(n.ch)), i.push(t), ++o
                }), i
            }

            function nt(e, t, n) {
                var r = [];
                return e.iter(t, n, function(e) {
                    r.push(e.text)
                }), r
            }

            function rt(e, t) {
                var n = t - e.height;
                if (n)
                    for (var r = e; r; r = r.parent) r.height += n
            }

            function it(e) {
                if (null == e.parent) return null;
                for (var t = e.parent, n = U(t.lines, e), r = t.parent; r; r = (t = r).parent)
                    for (var i = 0; r.children[i] != t; ++i) n += r.children[i].chunkSize();
                return n + t.first
            }

            function ot(e, t) {
                var n = e.first;
                e: do {
                    for (var r = 0; r < e.children.length; ++r) {
                        var i = e.children[r],
                            o = i.height;
                        if (t < o) {
                            e = i;
                            continue e
                        }
                        t -= o, n += i.chunkSize()
                    }
                    return n
                } while (!e.lines);
                for (var a = 0; a < e.lines.length; ++a) {
                    var s = e.lines[a].height;
                    if (t < s) break;
                    t -= s
                }
                return n + a
            }

            function at(e, t) {
                return t >= e.first && t < e.first + e.size
            }

            function st(e, t) {
                return String(e.lineNumberFormatter(t + e.firstLineNumber))
            }

            function lt(e, t, n) {
                if (void 0 === n && (n = null), !(this instanceof lt)) return new lt(e, t, n);
                this.line = e, this.ch = t, this.sticky = n
            }

            function ct(e, t) {
                return e.line - t.line || e.ch - t.ch
            }

            function ut(e, t) {
                return e.sticky == t.sticky && 0 == ct(e, t)
            }

            function ht(e) {
                return lt(e.line, e.ch)
            }

            function dt(e, t) {
                return ct(e, t) < 0 ? t : e
            }

            function pt(e, t) {
                return ct(e, t) < 0 ? e : t
            }

            function ft(e, t) {
                return Math.max(e.first, Math.min(t, e.first + e.size - 1))
            }

            function mt(e, t) {
                if (t.line < e.first) return lt(e.first, 0);
                var n = e.first + e.size - 1;
                return t.line > n ? lt(n, et(e, n).text.length) : function(e, t) {
                    var n = e.ch;
                    return null == n || t < n ? lt(e.line, t) : n < 0 ? lt(e.line, 0) : e
                }(t, et(e, t.line).text.length)
            }

            function vt(e, t) {
                for (var n = [], r = 0; r < t.length; r++) n[r] = mt(e, t[r]);
                return n
            }
            $e.prototype.eol = function() {
                return this.pos >= this.string.length
            }, $e.prototype.sol = function() {
                return this.pos == this.lineStart
            }, $e.prototype.peek = function() {
                return this.string.charAt(this.pos) || void 0
            }, $e.prototype.next = function() {
                if (this.pos < this.string.length) return this.string.charAt(this.pos++)
            }, $e.prototype.eat = function(e) {
                var t = this.string.charAt(this.pos);
                if ("string" == typeof e ? t == e : t && (e.test ? e.test(t) : e(t))) return ++this.pos, t
            }, $e.prototype.eatWhile = function(e) {
                for (var t = this.pos; this.eat(e););
                return this.pos > t
            }, $e.prototype.eatSpace = function() {
                for (var e = this.pos;
                    /[\s\u00a0]/.test(this.string.charAt(this.pos));) ++this.pos;
                return this.pos > e
            }, $e.prototype.skipToEnd = function() {
                this.pos = this.string.length
            }, $e.prototype.skipTo = function(e) {
                var t = this.string.indexOf(e, this.pos);
                if (-1 < t) return this.pos = t, !0
            }, $e.prototype.backUp = function(e) {
                this.pos -= e
            }, $e.prototype.column = function() {
                return this.lastColumnPos < this.start && (this.lastColumnValue = F(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? F(this.string, this.lineStart, this.tabSize) : 0)
            }, $e.prototype.indentation = function() {
                return F(this.string, null, this.tabSize) - (this.lineStart ? F(this.string, this.lineStart, this.tabSize) : 0)
            }, $e.prototype.match = function(e, t, n) {
                if ("string" != typeof e) {
                    var r = this.string.slice(this.pos).match(e);
                    return r && 0 < r.index ? null : (r && !1 !== t && (this.pos += r[0].length), r)
                }

                function i(e) {
                    return n ? e.toLowerCase() : e
                }
                if (i(this.string.substr(this.pos, e.length)) == i(e)) return !1 !== t && (this.pos += e.length), !0
            }, $e.prototype.current = function() {
                return this.string.slice(this.start, this.pos)
            }, $e.prototype.hideFirstChars = function(e, t) {
                this.lineStart += e;
                try {
                    return t()
                } finally {
                    this.lineStart -= e
                }
            }, $e.prototype.lookAhead = function(e) {
                var t = this.lineOracle;
                return t && t.lookAhead(e)
            }, $e.prototype.baseToken = function() {
                var e = this.lineOracle;
                return e && e.baseToken(this.pos)
            };
            var gt = function(e, t) {
                    this.state = e, this.lookAhead = t
                },
                yt = function(e, t, n, r) {
                    this.state = t, this.doc = e, this.line = n, this.maxLookAhead = r || 0, this.baseTokens = null, this.baseTokenPos = 1
                };

            function xt(t, n, r, e) {
                var l = [t.state.modeGen],
                    i = {};
                Lt(t, n.text, t.doc.mode, r, function(e, t) {
                    return l.push(e, t)
                }, i, e);
                for (var c = r.state, o = function(e) {
                        r.baseTokens = l;
                        var o = t.state.overlays[e],
                            a = 1,
                            s = 0;
                        r.state = !0, Lt(t, n.text, o.mode, r, function(e, t) {
                            for (var n = a; s < e;) {
                                var r = l[a];
                                e < r && l.splice(a, 1, e, l[a + 1], r), a += 2, s = Math.min(e, r)
                            }
                            if (t)
                                if (o.opaque) l.splice(n, a - n, e, "overlay " + t), a = n + 2;
                                else
                                    for (; n < a; n += 2) {
                                        var i = l[n + 1];
                                        l[n + 1] = (i ? i + " " : "") + "overlay " + t
                                    }
                        }, i), r.state = c, r.baseTokens = null, r.baseTokenPos = 1
                    }, a = 0; a < t.state.overlays.length; ++a) o(a);
                return {
                    styles: l,
                    classes: i.bgClass || i.textClass ? i : null
                }
            }

            function bt(e, t, n) {
                if (!t.styles || t.styles[0] != e.state.modeGen) {
                    var r = _t(e, it(t)),
                        i = t.text.length > e.options.maxHighlightLength && Ke(e.doc.mode, r.state),
                        o = xt(e, t, r);
                    i && (r.state = i), t.stateAfter = r.save(!i), t.styles = o.styles, o.classes ? t.styleClasses = o.classes : t.styleClasses && (t.styleClasses = null), n === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier))
                }
                return t.styles
            }

            function _t(n, r, e) {
                var t = n.doc,
                    i = n.display;
                if (!t.mode.startState) return new yt(t, !0, r);
                var o = function(e, t, n) {
                        for (var r, i, o = e.doc, a = n ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), s = t; a < s; --s) {
                            if (s <= o.first) return o.first;
                            var l = et(o, s - 1),
                                c = l.stateAfter;
                            if (c && (!n || s + (c instanceof gt ? c.lookAhead : 0) <= o.modeFrontier)) return s;
                            var u = F(l.text, null, e.options.tabSize);
                            (null == i || u < r) && (i = s - 1, r = u)
                        }
                        return i
                    }(n, r, e),
                    a = o > t.first && et(t, o - 1).stateAfter,
                    s = a ? yt.fromSaved(t, a, o) : new yt(t, Qe(t.mode), o);
                return t.iter(o, r, function(e) {
                    wt(n, e.text, s);
                    var t = s.line;
                    e.stateAfter = t == r - 1 || t % 5 == 0 || t >= i.viewFrom && t < i.viewTo ? s.save() : null, s.nextLine()
                }), e && (t.modeFrontier = s.line), s
            }

            function wt(e, t, n, r) {
                var i = e.doc.mode,
                    o = new $e(t, e.options.tabSize, n);
                for (o.start = o.pos = r || 0, "" == t && St(i, n.state); !o.eol();) Mt(i, o, n.state), o.start = o.pos
            }

            function St(e, t) {
                if (e.blankLine) return e.blankLine(t);
                if (e.innerMode) {
                    var n = Je(e, t);
                    return n.mode.blankLine ? n.mode.blankLine(n.state) : void 0
                }
            }

            function Mt(e, t, n, r) {
                for (var i = 0; i < 10; i++) {
                    r && (r[0] = Je(e, n).mode);
                    var o = e.token(t, n);
                    if (t.pos > t.start) return o
                }
                throw new Error("Mode " + e.name + " failed to advance stream.")
            }
            yt.prototype.lookAhead = function(e) {
                var t = this.doc.getLine(this.line + e);
                return null != t && e > this.maxLookAhead && (this.maxLookAhead = e), t
            }, yt.prototype.baseToken = function(e) {
                if (!this.baseTokens) return null;
                for (; this.baseTokens[this.baseTokenPos] <= e;) this.baseTokenPos += 2;
                var t = this.baseTokens[this.baseTokenPos + 1];
                return {
                    type: t && t.replace(/( |^)overlay .*/, ""),
                    size: this.baseTokens[this.baseTokenPos] - e
                }
            }, yt.prototype.nextLine = function() {
                this.line++, 0 < this.maxLookAhead && this.maxLookAhead--
            }, yt.fromSaved = function(e, t, n) {
                return t instanceof gt ? new yt(e, Ke(e.mode, t.state), n, t.lookAhead) : new yt(e, Ke(e.mode, t), n)
            }, yt.prototype.save = function(e) {
                var t = !1 !== e ? Ke(this.doc.mode, this.state) : this.state;
                return 0 < this.maxLookAhead ? new gt(t, this.maxLookAhead) : t
            };
            var Tt = function(e, t, n) {
                this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = n
            };

            function Et(e, t, n, r) {
                var i, o, a = e.doc,
                    s = a.mode,
                    l = et(a, (t = mt(a, t)).line),
                    c = _t(e, t.line, n),
                    u = new $e(l.text, e.options.tabSize, c);
                for (r && (o = []);
                    (r || u.pos < t.ch) && !u.eol();) u.start = u.pos, i = Mt(s, u, c.state), r && o.push(new Tt(u, i, Ke(a.mode, c.state)));
                return r ? o : new Tt(u, i, c.state)
            }

            function Ct(e, t) {
                if (e)
                    for (;;) {
                        var n = e.match(/(?:^|\s+)line-(background-)?(\S+)/);
                        if (!n) break;
                        e = e.slice(0, n.index) + e.slice(n.index + n[0].length);
                        var r = n[1] ? "bgClass" : "textClass";
                        null == t[r] ? t[r] = n[2] : new RegExp("(?:^|s)" + n[2] + "(?:$|s)").test(t[r]) || (t[r] += " " + n[2])
                    }
                return e
            }

            function Lt(e, t, n, r, i, o, a) {
                var s = n.flattenSpans;
                null == s && (s = e.options.flattenSpans);
                var l, c = 0,
                    u = null,
                    h = new $e(t, e.options.tabSize, r),
                    d = e.options.addModeClass && [null];
                for ("" == t && Ct(St(n, r.state), o); !h.eol();) {
                    if (l = h.pos > e.options.maxHighlightLength ? (s = !1, a && wt(e, t, r, h.pos), h.pos = t.length, null) : Ct(Mt(n, h, r.state, d), o), d) {
                        var p = d[0].name;
                        p && (l = "m-" + (l ? p + " " + l : p))
                    }
                    if (!s || u != l) {
                        for (; c < h.start;) i(c = Math.min(h.start, c + 5e3), u);
                        u = l
                    }
                    h.start = h.pos
                }
                for (; c < h.pos;) {
                    var f = Math.min(h.pos, c + 5e3);
                    i(f, u), c = f
                }
            }
            var At = !1,
                Rt = !1;

            function Pt(e, t, n) {
                this.marker = e, this.from = t, this.to = n
            }

            function Ot(e, t) {
                if (e)
                    for (var n = 0; n < e.length; ++n) {
                        var r = e[n];
                        if (r.marker == t) return r
                    }
            }

            function It(e, t) {
                for (var n, r = 0; r < e.length; ++r) e[r] != t && (n = n || []).push(e[r]);
                return n
            }

            function Dt(e, t) {
                if (t.full) return null;
                var n = at(e, t.from.line) && et(e, t.from.line).markedSpans,
                    r = at(e, t.to.line) && et(e, t.to.line).markedSpans;
                if (!n && !r) return null;
                var i = t.from.ch,
                    o = t.to.ch,
                    a = 0 == ct(t.from, t.to),
                    s = function(e, t, n) {
                        var r;
                        if (e)
                            for (var i = 0; i < e.length; ++i) {
                                var o = e[i],
                                    a = o.marker;
                                if (null == o.from || (a.inclusiveLeft ? o.from <= t : o.from < t) || o.from == t && "bookmark" == a.type && (!n || !o.marker.insertLeft)) {
                                    var s = null == o.to || (a.inclusiveRight ? o.to >= t : o.to > t);
                                    (r = r || []).push(new Pt(a, o.from, s ? null : o.to))
                                }
                            }
                        return r
                    }(n, i, a),
                    l = function(e, t, n) {
                        var r;
                        if (e)
                            for (var i = 0; i < e.length; ++i) {
                                var o = e[i],
                                    a = o.marker;
                                if (null == o.to || (a.inclusiveRight ? o.to >= t : o.to > t) || o.from == t && "bookmark" == a.type && (!n || o.marker.insertLeft)) {
                                    var s = null == o.from || (a.inclusiveLeft ? o.from <= t : o.from < t);
                                    (r = r || []).push(new Pt(a, s ? null : o.from - t, null == o.to ? null : o.to - t))
                                }
                            }
                        return r
                    }(r, o, a),
                    c = 1 == t.text.length,
                    u = Z(t.text).length + (c ? i : 0);
                if (s)
                    for (var h = 0; h < s.length; ++h) {
                        var d = s[h];
                        if (null == d.to) {
                            var p = Ot(l, d.marker);
                            p ? c && (d.to = null == p.to ? null : p.to + u) : d.to = i
                        }
                    }
                if (l)
                    for (var f = 0; f < l.length; ++f) {
                        var m = l[f];
                        if (null != m.to && (m.to += u), null == m.from) Ot(s, m.marker) || (m.from = u, c && (s = s || []).push(m));
                        else m.from += u, c && (s = s || []).push(m)
                    }
                s = s && Nt(s), l && l != s && (l = Nt(l));
                var v = [s];
                if (!c) {
                    var g, y = t.text.length - 2;
                    if (0 < y && s)
                        for (var x = 0; x < s.length; ++x) null == s[x].to && (g = g || []).push(new Pt(s[x].marker, null, null));
                    for (var b = 0; b < y; ++b) v.push(g);
                    v.push(l)
                }
                return v
            }

            function Nt(e) {
                for (var t = 0; t < e.length; ++t) {
                    var n = e[t];
                    null != n.from && n.from == n.to && !1 !== n.marker.clearWhenEmpty && e.splice(t--, 1)
                }
                return e.length ? e : null
            }

            function kt(e) {
                var t = e.markedSpans;
                if (t) {
                    for (var n = 0; n < t.length; ++n) t[n].marker.detachLine(e);
                    e.markedSpans = null
                }
            }

            function zt(e, t) {
                if (t) {
                    for (var n = 0; n < t.length; ++n) t[n].marker.attachLine(e);
                    e.markedSpans = t
                }
            }

            function Ft(e) {
                return e.inclusiveLeft ? -1 : 0
            }

            function Bt(e) {
                return e.inclusiveRight ? 1 : 0
            }

            function Ut(e, t) {
                var n = e.lines.length - t.lines.length;
                if (0 != n) return n;
                var r = e.find(),
                    i = t.find(),
                    o = ct(r.from, i.from) || Ft(e) - Ft(t);
                if (o) return -o;
                var a = ct(r.to, i.to) || Bt(e) - Bt(t);
                return a || t.id - e.id
            }

            function Ht(e, t) {
                var n, r = Rt && e.markedSpans;
                if (r)
                    for (var i = void 0, o = 0; o < r.length; ++o)(i = r[o]).marker.collapsed && null == (t ? i.from : i.to) && (!n || Ut(n, i.marker) < 0) && (n = i.marker);
                return n
            }

            function Gt(e) {
                return Ht(e, !0)
            }

            function Vt(e) {
                return Ht(e, !1)
            }

            function Wt(e, t) {
                var n, r = Rt && e.markedSpans;
                if (r)
                    for (var i = 0; i < r.length; ++i) {
                        var o = r[i];
                        o.marker.collapsed && (null == o.from || o.from < t) && (null == o.to || o.to > t) && (!n || Ut(n, o.marker) < 0) && (n = o.marker)
                    }
                return n
            }

            function jt(e, t, n, r, i) {
                var o = et(e, t),
                    a = Rt && o.markedSpans;
                if (a)
                    for (var s = 0; s < a.length; ++s) {
                        var l = a[s];
                        if (l.marker.collapsed) {
                            var c = l.marker.find(0),
                                u = ct(c.from, n) || Ft(l.marker) - Ft(i),
                                h = ct(c.to, r) || Bt(l.marker) - Bt(i);
                            if (!(0 <= u && h <= 0 || u <= 0 && 0 <= h) && (u <= 0 && (l.marker.inclusiveRight && i.inclusiveLeft ? 0 <= ct(c.to, n) : 0 < ct(c.to, n)) || 0 <= u && (l.marker.inclusiveRight && i.inclusiveLeft ? ct(c.from, r) <= 0 : ct(c.from, r) < 0))) return !0
                        }
                    }
            }

            function qt(e) {
                for (var t; t = Gt(e);) e = t.find(-1, !0).line;
                return e
            }

            function Xt(e, t) {
                var n = et(e, t),
                    r = qt(n);
                return n == r ? t : it(r)
            }

            function Yt(e, t) {
                if (t > e.lastLine()) return t;
                var n, r = et(e, t);
                if (!Zt(e, r)) return t;
                for (; n = Vt(r);) r = n.find(1, !0).line;
                return it(r) + 1
            }

            function Zt(e, t) {
                var n = Rt && t.markedSpans;
                if (n)
                    for (var r = void 0, i = 0; i < n.length; ++i)
                        if ((r = n[i]).marker.collapsed) {
                            if (null == r.from) return !0;
                            if (!r.marker.widgetNode && 0 == r.from && r.marker.inclusiveLeft && Kt(e, t, r)) return !0
                        }
            }

            function Kt(e, t, n) {
                if (null == n.to) {
                    var r = n.marker.find(1, !0);
                    return Kt(e, r.line, Ot(r.line.markedSpans, n.marker))
                }
                if (n.marker.inclusiveRight && n.to == t.text.length) return !0;
                for (var i = void 0, o = 0; o < t.markedSpans.length; ++o)
                    if ((i = t.markedSpans[o]).marker.collapsed && !i.marker.widgetNode && i.from == n.to && (null == i.to || i.to != n.from) && (i.marker.inclusiveLeft || n.marker.inclusiveRight) && Kt(e, t, i)) return !0
            }

            function Jt(e) {
                for (var t = 0, n = (e = qt(e)).parent, r = 0; r < n.lines.length; ++r) {
                    var i = n.lines[r];
                    if (i == e) break;
                    t += i.height
                }
                for (var o = n.parent; o; o = (n = o).parent)
                    for (var a = 0; a < o.children.length; ++a) {
                        var s = o.children[a];
                        if (s == n) break;
                        t += s.height
                    }
                return t
            }

            function Qt(e) {
                if (0 == e.height) return 0;
                for (var t, n = e.text.length, r = e; t = Gt(r);) {
                    var i = t.find(0, !0);
                    r = i.from.line, n += i.from.ch - i.to.ch
                }
                for (r = e; t = Vt(r);) {
                    var o = t.find(0, !0);
                    n -= r.text.length - o.from.ch, n += (r = o.to.line).text.length - o.to.ch
                }
                return n
            }

            function $t(e) {
                var n = e.display,
                    t = e.doc;
                n.maxLine = et(t, t.first), n.maxLineLength = Qt(n.maxLine), n.maxLineChanged = !0, t.iter(function(e) {
                    var t = Qt(e);
                    t > n.maxLineLength && (n.maxLineLength = t, n.maxLine = e)
                })
            }
            var en = function(e, t, n) {
                this.text = e, zt(this, t), this.height = n ? n(this) : 1
            };
            en.prototype.lineNo = function() {
                return it(this)
            }, Ce(en);
            var tn = {},
                nn = {};

            function rn(e, t) {
                if (!e || /^\s*$/.test(e)) return null;
                var n = t.addModeClass ? nn : tn;
                return n[e] || (n[e] = e.replace(/\S+/g, "cm-$&"))
            }

            function on(e, t) {
                var n = A("span", null, null, x ? "padding-right: .1px" : null),
                    r = {
                        pre: A("pre", [n], "CodeMirror-line"),
                        content: n,
                        col: 0,
                        pos: 0,
                        cm: e,
                        trailingSpace: !1,
                        splitSpaces: e.getOption("lineWrapping")
                    };
                t.measure = {};
                for (var i = 0; i <= (t.rest ? t.rest.length : 0); i++) {
                    var o = i ? t.rest[i - 1] : t.line,
                        a = void 0;
                    r.pos = 0, r.addToken = sn, Fe(e.display.measure) && (a = ye(o, e.doc.direction)) && (r.addToken = ln(r.addToken, a)), r.map = [], un(o, r, bt(e, o, t != e.display.externalMeasured && it(o))), o.styleClasses && (o.styleClasses.bgClass && (r.bgClass = D(o.styleClasses.bgClass, r.bgClass || "")), o.styleClasses.textClass && (r.textClass = D(o.styleClasses.textClass, r.textClass || ""))), 0 == r.map.length && r.map.push(0, 0, r.content.appendChild(ze(e.display.measure))), 0 == i ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({}))
                }
                if (x) {
                    var s = r.content.lastChild;
                    (/\bcm-tab\b/.test(s.className) || s.querySelector && s.querySelector(".cm-tab")) && (r.content.className = "cm-tab-wrap-hack")
                }
                return Se(e, "renderLine", e, t.line, r.pre), r.pre.className && (r.textClass = D(r.pre.className, r.textClass || "")), r
            }

            function an(e) {
                var t = R("span", "â€¢", "cm-invalidchar");
                return t.title = "\\u" + e.charCodeAt(0).toString(16), t.setAttribute("aria-label", t.title), t
            }

            function sn(e, t, n, r, i, o, a) {
                if (t) {
                    var s, l = e.splitSpaces ? function(e, t) {
                            if (1 < e.length && !/  /.test(e)) return e;
                            for (var n = t, r = "", i = 0; i < e.length; i++) {
                                var o = e.charAt(i);
                                " " != o || !n || i != e.length - 1 && 32 != e.charCodeAt(i + 1) || (o = "Â "), r += o, n = " " == o
                            }
                            return r
                        }(t, e.trailingSpace) : t,
                        c = e.cm.state.specialChars,
                        u = !1;
                    if (c.test(t)) {
                        s = document.createDocumentFragment();
                        for (var h = 0;;) {
                            c.lastIndex = h;
                            var d = c.exec(t),
                                p = d ? d.index - h : t.length - h;
                            if (p) {
                                var f = document.createTextNode(l.slice(h, h + p));
                                _ && w < 9 ? s.appendChild(R("span", [f])) : s.appendChild(f), e.map.push(e.pos, e.pos + p, f), e.col += p, e.pos += p
                            }
                            if (!d) break;
                            h += 1 + p;
                            var m = void 0;
                            if ("\t" == d[0]) {
                                var v = e.cm.options.tabSize,
                                    g = v - e.col % v;
                                (m = s.appendChild(R("span", Y(g), "cm-tab"))).setAttribute("role", "presentation"), m.setAttribute("cm-text", "\t"), e.col += g
                            } else "\r" == d[0] || "\n" == d[0] ? (m = s.appendChild(R("span", "\r" == d[0] ? "â" : "â¤", "cm-invalidchar"))).setAttribute("cm-text", d[0]) : ((m = e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text", d[0]), _ && w < 9 ? s.appendChild(R("span", [m])) : s.appendChild(m)), e.col += 1;
                            e.map.push(e.pos, e.pos + 1, m), e.pos++
                        }
                    } else e.col += t.length, s = document.createTextNode(l), e.map.push(e.pos, e.pos + t.length, s), _ && w < 9 && (u = !0), e.pos += t.length;
                    if (e.trailingSpace = 32 == l.charCodeAt(t.length - 1), n || r || i || u || o) {
                        var y = n || "";
                        r && (y += r), i && (y += i);
                        var x = R("span", [s], y, o);
                        if (a)
                            for (var b in a) a.hasOwnProperty(b) && "style" != b && "class" != b && x.setAttribute(b, a[b]);
                        return e.content.appendChild(x)
                    }
                    e.content.appendChild(s)
                }
            }

            function ln(h, d) {
                return function(e, t, n, r, i, o, a) {
                    n = n ? n + " cm-force-border" : "cm-force-border";
                    for (var s = e.pos, l = s + t.length;;) {
                        for (var c = void 0, u = 0; u < d.length && !((c = d[u]).to > s && c.from <= s); u++);
                        if (c.to >= l) return h(e, t, n, r, i, o, a);
                        h(e, t.slice(0, c.to - s), n, r, null, o, a), r = null, t = t.slice(c.to - s), s = c.to
                    }
                }
            }

            function cn(e, t, n, r) {
                var i = !r && n.widgetNode;
                i && e.map.push(e.pos, e.pos + t, i), !r && e.cm.display.input.needsContentAttribute && (i = i || e.content.appendChild(document.createElement("span"))).setAttribute("cm-marker", n.id), i && (e.cm.display.input.setUneditable(i), e.content.appendChild(i)), e.pos += t, e.trailingSpace = !1
            }

            function un(e, t, n) {
                var r = e.markedSpans,
                    i = e.text,
                    o = 0;
                if (r)
                    for (var a, s, l, c, u, h, d, p = i.length, f = 0, m = 1, v = "", g = 0;;) {
                        if (g == f) {
                            l = c = u = s = "", h = d = null, g = 1 / 0;
                            for (var y = [], x = void 0, b = 0; b < r.length; ++b) {
                                var _ = r[b],
                                    w = _.marker;
                                if ("bookmark" == w.type && _.from == f && w.widgetNode) y.push(w);
                                else if (_.from <= f && (null == _.to || _.to > f || w.collapsed && _.to == f && _.from == f)) {
                                    if (null != _.to && _.to != f && g > _.to && (g = _.to, c = ""), w.className && (l += " " + w.className), w.css && (s = (s ? s + ";" : "") + w.css), w.startStyle && _.from == f && (u += " " + w.startStyle), w.endStyle && _.to == g && (x = x || []).push(w.endStyle, _.to), w.title && ((d = d || {}).title = w.title), w.attributes)
                                        for (var S in w.attributes)(d = d || {})[S] = w.attributes[S];
                                    w.collapsed && (!h || Ut(h.marker, w) < 0) && (h = _)
                                } else _.from > f && g > _.from && (g = _.from)
                            }
                            if (x)
                                for (var M = 0; M < x.length; M += 2) x[M + 1] == g && (c += " " + x[M]);
                            if (!h || h.from == f)
                                for (var T = 0; T < y.length; ++T) cn(t, 0, y[T]);
                            if (h && (h.from || 0) == f) {
                                if (cn(t, (null == h.to ? p + 1 : h.to) - f, h.marker, null == h.from), null == h.to) return;
                                h.to == f && (h = !1)
                            }
                        }
                        if (p <= f) break;
                        for (var E = Math.min(p, g);;) {
                            if (v) {
                                var C = f + v.length;
                                if (!h) {
                                    var L = E < C ? v.slice(0, E - f) : v;
                                    t.addToken(t, L, a ? a + l : l, u, f + L.length == g ? c : "", s, d)
                                }
                                if (E <= C) {
                                    v = v.slice(E - f), f = E;
                                    break
                                }
                                f = C, u = ""
                            }
                            v = i.slice(o, o = n[m++]), a = rn(n[m++], t.cm.options)
                        }
                    } else
                        for (var A = 1; A < n.length; A += 2) t.addToken(t, i.slice(o, o = n[A]), rn(n[A + 1], t.cm.options))
            }

            function hn(e, t, n) {
                this.line = t, this.rest = function(e) {
                    for (var t, n; t = Vt(e);) e = t.find(1, !0).line, (n = n || []).push(e);
                    return n
                }(t), this.size = this.rest ? it(Z(this.rest)) - n + 1 : 1, this.node = this.text = null, this.hidden = Zt(e, t)
            }

            function dn(e, t, n) {
                for (var r, i = [], o = t; o < n; o = r) {
                    var a = new hn(e.doc, et(e.doc, o), o);
                    r = o + a.size, i.push(a)
                }
                return i
            }
            var pn = null;
            var fn = null;

            function mn(e, t) {
                var n = _e(e, t);
                if (n.length) {
                    var r, i = Array.prototype.slice.call(arguments, 2);
                    pn ? r = pn.delayedCallbacks : fn ? r = fn : (r = fn = [], setTimeout(vn, 0));
                    for (var o = function(e) {
                            r.push(function() {
                                return n[e].apply(null, i)
                            })
                        }, a = 0; a < n.length; ++a) o(a)
                }
            }

            function vn() {
                var e = fn;
                fn = null;
                for (var t = 0; t < e.length; ++t) e[t]()
            }

            function gn(e, t, n, r) {
                for (var i = 0; i < t.changes.length; i++) {
                    var o = t.changes[i];
                    "text" == o ? bn(e, t) : "gutter" == o ? wn(e, t, n, r) : "class" == o ? _n(e, t) : "widget" == o && Sn(e, t, r)
                }
                t.changes = null
            }

            function yn(e) {
                return e.node == e.text && (e.node = R("div", null, null, "position: relative"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), _ && w < 8 && (e.node.style.zIndex = 2)), e.node
            }

            function xn(e, t) {
                var n = e.display.externalMeasured;
                return n && n.line == t.line ? (e.display.externalMeasured = null, t.measure = n.measure, n.built) : on(e, t)
            }

            function bn(e, t) {
                var n = t.text.className,
                    r = xn(e, t);
                t.text == t.node && (t.node = r.pre), t.text.parentNode.replaceChild(r.pre, t.text), t.text = r.pre, r.bgClass != t.bgClass || r.textClass != t.textClass ? (t.bgClass = r.bgClass, t.textClass = r.textClass, _n(e, t)) : n && (t.text.className = n)
            }

            function _n(e, t) {
                ! function(e, t) {
                    var n = t.bgClass ? t.bgClass + " " + (t.line.bgClass || "") : t.line.bgClass;
                    if (n && (n += " CodeMirror-linebackground"), t.background) n ? t.background.className = n : (t.background.parentNode.removeChild(t.background), t.background = null);
                    else if (n) {
                        var r = yn(t);
                        t.background = r.insertBefore(R("div", null, n), r.firstChild), e.display.input.setUneditable(t.background)
                    }
                }(e, t), t.line.wrapClass ? yn(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = "");
                var n = t.textClass ? t.textClass + " " + (t.line.textClass || "") : t.line.textClass;
                t.text.className = n || ""
            }

            function wn(e, t, n, r) {
                if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) {
                    var i = yn(t);
                    t.gutterBackground = R("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px; width: " + r.gutterTotalWidth + "px"), e.display.input.setUneditable(t.gutterBackground), i.insertBefore(t.gutterBackground, t.text)
                }
                var o = t.line.gutterMarkers;
                if (e.options.lineNumbers || o) {
                    var a = yn(t),
                        s = t.gutter = R("div", null, "CodeMirror-gutter-wrapper", "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px");
                    if (e.display.input.setUneditable(s), a.insertBefore(s, t.text), t.line.gutterClass && (s.className += " " + t.line.gutterClass), !e.options.lineNumbers || o && o["CodeMirror-linenumbers"] || (t.lineNumber = s.appendChild(R("div", st(e.options, n), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + r.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + e.display.lineNumInnerWidth + "px"))), o)
                        for (var l = 0; l < e.display.gutterSpecs.length; ++l) {
                            var c = e.display.gutterSpecs[l].className,
                                u = o.hasOwnProperty(c) && o[c];
                            u && s.appendChild(R("div", [u], "CodeMirror-gutter-elt", "left: " + r.gutterLeft[c] + "px; width: " + r.gutterWidth[c] + "px"))
                        }
                }
            }

            function Sn(e, t, n) {
                t.alignable && (t.alignable = null);
                for (var r = t.node.firstChild, i = void 0; r; r = i) i = r.nextSibling, "CodeMirror-linewidget" == r.className && t.node.removeChild(r);
                Mn(e, t, n)
            }

            function Mn(e, t, n) {
                if (Tn(e, t.line, t, n, !0), t.rest)
                    for (var r = 0; r < t.rest.length; r++) Tn(e, t.rest[r], t, n, !1)
            }

            function Tn(e, t, n, r, i) {
                if (t.widgets)
                    for (var o = yn(n), a = 0, s = t.widgets; a < s.length; ++a) {
                        var l = s[a],
                            c = R("div", [l.node], "CodeMirror-linewidget");
                        l.handleMouseEvents || c.setAttribute("cm-ignore-events", "true"), En(l, c, n, r), e.display.input.setUneditable(c), i && l.above ? o.insertBefore(c, n.gutter || n.text) : o.appendChild(c), mn(l, "redraw")
                    }
            }

            function En(e, t, n, r) {
                if (e.noHScroll) {
                    (n.alignable || (n.alignable = [])).push(t);
                    var i = r.wrapperWidth;
                    t.style.left = r.fixedPos + "px", e.coverGutter || (i -= r.gutterTotalWidth, t.style.paddingLeft = r.gutterTotalWidth + "px"), t.style.width = i + "px"
                }
                e.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", e.noHScroll || (t.style.marginLeft = -r.gutterTotalWidth + "px"))
            }

            function Cn(e) {
                if (null != e.height) return e.height;
                var t = e.doc.cm;
                if (!t) return 0;
                if (!P(document.body, e.node)) {
                    var n = "position: relative;";
                    e.coverGutter && (n += "margin-left: -" + t.display.gutters.offsetWidth + "px;"), e.noHScroll && (n += "width: " + t.display.wrapper.clientWidth + "px;"), L(t.display.measure, R("div", [e.node], null, n))
                }
                return e.height = e.node.parentNode.offsetHeight
            }

            function Ln(e, t) {
                for (var n = Oe(t); n != e.wrapper; n = n.parentNode)
                    if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == e.sizer && n != e.mover) return !0
            }

            function An(e) {
                return e.lineSpace.offsetTop
            }

            function Rn(e) {
                return e.mover.offsetHeight - e.lineSpace.offsetHeight
            }

            function Pn(e) {
                if (e.cachedPaddingH) return e.cachedPaddingH;
                var t = L(e.measure, R("pre", "x", "CodeMirror-line-like")),
                    n = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle,
                    r = {
                        left: parseInt(n.paddingLeft),
                        right: parseInt(n.paddingRight)
                    };
                return isNaN(r.left) || isNaN(r.right) || (e.cachedPaddingH = r), r
            }

            function On(e) {
                return H - e.display.nativeBarWidth
            }

            function In(e) {
                return e.display.scroller.clientWidth - On(e) - e.display.barWidth
            }

            function Dn(e) {
                return e.display.scroller.clientHeight - On(e) - e.display.barHeight
            }

            function Nn(e, t, n) {
                if (e.line == t) return {
                    map: e.measure.map,
                    cache: e.measure.cache
                };
                for (var r = 0; r < e.rest.length; r++)
                    if (e.rest[r] == t) return {
                        map: e.measure.maps[r],
                        cache: e.measure.caches[r]
                    };
                for (var i = 0; i < e.rest.length; i++)
                    if (it(e.rest[i]) > n) return {
                        map: e.measure.maps[i],
                        cache: e.measure.caches[i],
                        before: !0
                    }
            }

            function kn(e, t, n, r) {
                return Bn(e, Fn(e, t), n, r)
            }

            function zn(e, t) {
                if (t >= e.display.viewFrom && t < e.display.viewTo) return e.display.view[fr(e, t)];
                var n = e.display.externalMeasured;
                return n && t >= n.lineN && t < n.lineN + n.size ? n : void 0
            }

            function Fn(e, t) {
                var n = it(t),
                    r = zn(e, n);
                r && !r.text ? r = null : r && r.changes && (gn(e, r, n, cr(e)), e.curOp.forceUpdate = !0);
                var i = Nn(r = r || function(e, t) {
                    var n = it(t = qt(t)),
                        r = e.display.externalMeasured = new hn(e.doc, t, n);
                    r.lineN = n;
                    var i = r.built = on(e, r);
                    return r.text = i.pre, L(e.display.lineMeasure, i.pre), r
                }(e, t), t, n);
                return {
                    line: t,
                    view: r,
                    rect: null,
                    map: i.map,
                    cache: i.cache,
                    before: i.before,
                    hasHeights: !1
                }
            }

            function Bn(e, t, n, r, i) {
                t.before && (n = -1);
                var o, a = n + (r || "");
                return t.cache.hasOwnProperty(a) ? o = t.cache[a] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (function(e, t, n) {
                    var r = e.options.lineWrapping,
                        i = r && In(e);
                    if (!t.measure.heights || r && t.measure.width != i) {
                        var o = t.measure.heights = [];
                        if (r) {
                            t.measure.width = i;
                            for (var a = t.text.firstChild.getClientRects(), s = 0; s < a.length - 1; s++) {
                                var l = a[s],
                                    c = a[s + 1];
                                2 < Math.abs(l.bottom - c.bottom) && o.push((l.bottom + c.top) / 2 - n.top)
                            }
                        }
                        o.push(n.bottom - n.top)
                    }
                }(e, t.view, t.rect), t.hasHeights = !0), (o = function(e, t, n, r) {
                    var i, o = Gn(t.map, n, r),
                        a = o.node,
                        s = o.start,
                        l = o.end,
                        c = o.collapse;
                    if (3 == a.nodeType) {
                        for (var u = 0; u < 4; u++) {
                            for (; s && ie(t.line.text.charAt(o.coverStart + s));) --s;
                            for (; o.coverStart + l < o.coverEnd && ie(t.line.text.charAt(o.coverStart + l));) ++l;
                            if ((i = _ && w < 9 && 0 == s && l == o.coverEnd - o.coverStart ? a.parentNode.getBoundingClientRect() : Vn(T(a, s, l).getClientRects(), r)).left || i.right || 0 == s) break;
                            l = s, s -= 1, c = "right"
                        }
                        _ && w < 11 && (i = function(e, t) {
                            if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || ! function(e) {
                                    if (null != Ve) return Ve;
                                    var t = L(e, R("span", "x")),
                                        n = t.getBoundingClientRect(),
                                        r = T(t, 0, 1).getBoundingClientRect();
                                    return Ve = 1 < Math.abs(n.left - r.left)
                                }(e)) return t;
                            var n = screen.logicalXDPI / screen.deviceXDPI,
                                r = screen.logicalYDPI / screen.deviceYDPI;
                            return {
                                left: t.left * n,
                                right: t.right * n,
                                top: t.top * r,
                                bottom: t.bottom * r
                            }
                        }(e.display.measure, i))
                    } else {
                        var h;
                        0 < s && (c = r = "right"), i = e.options.lineWrapping && 1 < (h = a.getClientRects()).length ? h["right" == r ? h.length - 1 : 0] : a.getBoundingClientRect()
                    }
                    if (_ && w < 9 && !s && (!i || !i.left && !i.right)) {
                        var d = a.parentNode.getClientRects()[0];
                        i = d ? {
                            left: d.left,
                            right: d.left + lr(e.display),
                            top: d.top,
                            bottom: d.bottom
                        } : Hn
                    }
                    for (var p = i.top - t.rect.top, f = i.bottom - t.rect.top, m = (p + f) / 2, v = t.view.measure.heights, g = 0; g < v.length - 1 && !(m < v[g]); g++);
                    var y = g ? v[g - 1] : 0,
                        x = v[g],
                        b = {
                            left: ("right" == c ? i.right : i.left) - t.rect.left,
                            right: ("left" == c ? i.left : i.right) - t.rect.left,
                            top: y,
                            bottom: x
                        };
                    i.left || i.right || (b.bogus = !0);
                    e.options.singleCursorHeightPerLine || (b.rtop = p, b.rbottom = f);
                    return b
                }(e, t, n, r)).bogus || (t.cache[a] = o)), {
                    left: o.left,
                    right: o.right,
                    top: i ? o.rtop : o.top,
                    bottom: i ? o.rbottom : o.bottom
                }
            }
            var Un, Hn = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };

            function Gn(e, t, n) {
                for (var r, i, o, a, s, l, c = 0; c < e.length; c += 3)
                    if (s = e[c], l = e[c + 1], t < s ? (i = 0, o = 1, a = "left") : t < l ? o = (i = t - s) + 1 : (c == e.length - 3 || t == l && e[c + 3] > t) && (i = (o = l - s) - 1, l <= t && (a = "right")), null != i) {
                        if (r = e[c + 2], s == l && n == (r.insertLeft ? "left" : "right") && (a = n), "left" == n && 0 == i)
                            for (; c && e[c - 2] == e[c - 3] && e[c - 1].insertLeft;) r = e[2 + (c -= 3)], a = "left";
                        if ("right" == n && i == l - s)
                            for (; c < e.length - 3 && e[c + 3] == e[c + 4] && !e[c + 5].insertLeft;) r = e[(c += 3) + 2], a = "right";
                        break
                    }
                return {
                    node: r,
                    start: i,
                    end: o,
                    collapse: a,
                    coverStart: s,
                    coverEnd: l
                }
            }

            function Vn(e, t) {
                var n = Hn;
                if ("left" == t)
                    for (var r = 0; r < e.length && (n = e[r]).left == n.right; r++);
                else
                    for (var i = e.length - 1; 0 <= i && (n = e[i]).left == n.right; i--);
                return n
            }

            function Wn(e) {
                if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest))
                    for (var t = 0; t < e.rest.length; t++) e.measure.caches[t] = {}
            }

            function jn(e) {
                e.display.externalMeasure = null, C(e.display.lineMeasure);
                for (var t = 0; t < e.display.view.length; t++) Wn(e.display.view[t])
            }

            function qn(e) {
                jn(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null
            }

            function Xn() {
                return a && h ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft
            }

            function Yn() {
                return a && h ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop
            }

            function Zn(e) {
                var t = 0;
                if (e.widgets)
                    for (var n = 0; n < e.widgets.length; ++n) e.widgets[n].above && (t += Cn(e.widgets[n]));
                return t
            }

            function Kn(e, t, n, r, i) {
                if (!i) {
                    var o = Zn(t);
                    n.top += o, n.bottom += o
                }
                if ("line" == r) return n;
                r = r || "local";
                var a = Jt(t);
                if ("local" == r ? a += An(e.display) : a -= e.display.viewOffset, "page" == r || "window" == r) {
                    var s = e.display.lineSpace.getBoundingClientRect();
                    a += s.top + ("window" == r ? 0 : Yn());
                    var l = s.left + ("window" == r ? 0 : Xn());
                    n.left += l, n.right += l
                }
                return n.top += a, n.bottom += a, n
            }

            function Jn(e, t, n) {
                if ("div" == n) return t;
                var r = t.left,
                    i = t.top;
                if ("page" == n) r -= Xn(), i -= Yn();
                else if ("local" == n || !n) {
                    var o = e.display.sizer.getBoundingClientRect();
                    r += o.left, i += o.top
                }
                var a = e.display.lineSpace.getBoundingClientRect();
                return {
                    left: r - a.left,
                    top: i - a.top
                }
            }

            function Qn(e, t, n, r, i) {
                return Kn(e, r = r || et(e.doc, t.line), kn(e, r, t.ch, i), n)
            }

            function $n(r, e, i, o, a, s) {
                function l(e, t) {
                    var n = Bn(r, a, e, t ? "right" : "left", s);
                    return t ? n.left = n.right : n.right = n.left, Kn(r, o, n, i)
                }
                o = o || et(r.doc, e.line), a = a || Fn(r, o);
                var c = ye(o, r.doc.direction),
                    t = e.ch,
                    n = e.sticky;
                if (t >= o.text.length ? (t = o.text.length, n = "before") : t <= 0 && (t = 0, n = "after"), !c) return l("before" == n ? t - 1 : t, "before" == n);

                function u(e, t, n) {
                    return l(n ? e - 1 : e, 1 == c[t].level != n)
                }
                var h = le(c, t, n),
                    d = se,
                    p = u(t, h, "before" == n);
                return null != d && (p.other = u(t, d, "before" != n)), p
            }

            function er(e, t) {
                var n = 0;
                t = mt(e.doc, t), e.options.lineWrapping || (n = lr(e.display) * t.ch);
                var r = et(e.doc, t.line),
                    i = Jt(r) + An(e.display);
                return {
                    left: n,
                    right: n,
                    top: i,
                    bottom: i + r.height
                }
            }

            function tr(e, t, n, r, i) {
                var o = lt(e, t, n);
                return o.xRel = i, r && (o.outside = r), o
            }

            function nr(e, t, n) {
                var r = e.doc;
                if ((n += e.display.viewOffset) < 0) return tr(r.first, 0, null, -1, -1);
                var i = ot(r, n),
                    o = r.first + r.size - 1;
                if (o < i) return tr(r.first + r.size - 1, et(r, o).text.length, null, 1, 1);
                t < 0 && (t = 0);
                for (var a = et(r, i);;) {
                    var s = ar(e, a, i, t, n),
                        l = Wt(a, s.ch + (0 < s.xRel || 0 < s.outside ? 1 : 0));
                    if (!l) return s;
                    var c = l.find(1);
                    if (c.line == i) return c;
                    a = et(r, i = c.line)
                }
            }

            function rr(t, e, n, r) {
                r -= Zn(e);
                var i = e.text.length,
                    o = ae(function(e) {
                        return Bn(t, n, e - 1).bottom <= r
                    }, i, 0);
                return {
                    begin: o,
                    end: i = ae(function(e) {
                        return Bn(t, n, e).top > r
                    }, o, i)
                }
            }

            function ir(e, t, n, r) {
                return rr(e, t, n = n || Fn(e, t), Kn(e, t, Bn(e, n, r), "line").top)
            }

            function or(e, t, n, r) {
                return !(e.bottom <= n) && (e.top > n || (r ? e.left : e.right) > t)
            }

            function ar(n, e, t, r, i) {
                i -= Jt(e);
                var o = Fn(n, e),
                    a = Zn(e),
                    s = 0,
                    l = e.text.length,
                    c = !0,
                    u = ye(e, n.doc.direction);
                if (u) {
                    var h = (n.options.lineWrapping ? function(e, t, n, r, i, o, a) {
                        var s = rr(e, t, r, a),
                            l = s.begin,
                            c = s.end;
                        /\s/.test(t.text.charAt(c - 1)) && c--;
                        for (var u = null, h = null, d = 0; d < i.length; d++) {
                            var p = i[d];
                            if (!(p.from >= c || p.to <= l)) {
                                var f = 1 != p.level,
                                    m = Bn(e, r, f ? Math.min(c, p.to) - 1 : Math.max(l, p.from)).right,
                                    v = m < o ? o - m + 1e9 : m - o;
                                (!u || v < h) && (u = p, h = v)
                            }
                        }
                        u = u || i[i.length - 1];
                        u.from < l && (u = {
                            from: l,
                            to: u.to,
                            level: u.level
                        });
                        u.to > c && (u = {
                            from: u.from,
                            to: c,
                            level: u.level
                        });
                        return u
                    } : function(r, i, o, a, s, l, c) {
                        var e = ae(function(e) {
                                var t = s[e],
                                    n = 1 != t.level;
                                return or($n(r, lt(o, n ? t.to : t.from, n ? "before" : "after"), "line", i, a), l, c, !0)
                            }, 0, s.length - 1),
                            t = s[e];
                        if (0 < e) {
                            var n = 1 != t.level,
                                u = $n(r, lt(o, n ? t.from : t.to, n ? "after" : "before"), "line", i, a);
                            or(u, l, c, !0) && u.top > c && (t = s[e - 1])
                        }
                        return t
                    })(n, e, t, o, u, r, i);
                    s = (c = 1 != h.level) ? h.from : h.to - 1, l = c ? h.to : h.from - 1
                }
                var d, p, f = null,
                    m = null,
                    v = ae(function(e) {
                        var t = Bn(n, o, e);
                        return t.top += a, t.bottom += a, !!or(t, r, i, !1) && (t.top <= i && t.left <= r && (f = e, m = t), !0)
                    }, s, l),
                    g = !1;
                if (m) {
                    var y = r - m.left < m.right - r,
                        x = y == c;
                    v = f + (x ? 0 : 1), p = x ? "after" : "before", d = y ? m.left : m.right
                } else {
                    c || v != l && v != s || v++, p = 0 == v ? "after" : v == e.text.length ? "before" : Bn(n, o, v - (c ? 1 : 0)).bottom + a <= i == c ? "after" : "before";
                    var b = $n(n, lt(t, v, p), "line", e, o);
                    d = b.left, g = i < b.top ? -1 : i >= b.bottom ? 1 : 0
                }
                return tr(t, v = oe(e.text, v, 1), p, g, r - d)
            }

            function sr(e) {
                if (null != e.cachedTextHeight) return e.cachedTextHeight;
                if (null == Un) {
                    Un = R("pre", null, "CodeMirror-line-like");
                    for (var t = 0; t < 49; ++t) Un.appendChild(document.createTextNode("x")), Un.appendChild(R("br"));
                    Un.appendChild(document.createTextNode("x"))
                }
                L(e.measure, Un);
                var n = Un.offsetHeight / 50;
                return 3 < n && (e.cachedTextHeight = n), C(e.measure), n || 1
            }

            function lr(e) {
                if (null != e.cachedCharWidth) return e.cachedCharWidth;
                var t = R("span", "xxxxxxxxxx"),
                    n = R("pre", [t], "CodeMirror-line-like");
                L(e.measure, n);
                var r = t.getBoundingClientRect(),
                    i = (r.right - r.left) / 10;
                return 2 < i && (e.cachedCharWidth = i), i || 10
            }

            function cr(e) {
                for (var t = e.display, n = {}, r = {}, i = t.gutters.clientLeft, o = t.gutters.firstChild, a = 0; o; o = o.nextSibling, ++a) {
                    var s = e.display.gutterSpecs[a].className;
                    n[s] = o.offsetLeft + o.clientLeft + i, r[s] = o.clientWidth
                }
                return {
                    fixedPos: ur(t),
                    gutterTotalWidth: t.gutters.offsetWidth,
                    gutterLeft: n,
                    gutterWidth: r,
                    wrapperWidth: t.wrapper.clientWidth
                }
            }

            function ur(e) {
                return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left
            }

            function hr(r) {
                var i = sr(r.display),
                    o = r.options.lineWrapping,
                    a = o && Math.max(5, r.display.scroller.clientWidth / lr(r.display) - 3);
                return function(e) {
                    if (Zt(r.doc, e)) return 0;
                    var t = 0;
                    if (e.widgets)
                        for (var n = 0; n < e.widgets.length; n++) e.widgets[n].height && (t += e.widgets[n].height);
                    return o ? t + (Math.ceil(e.text.length / a) || 1) * i : t + i
                }
            }

            function dr(e) {
                var t = e.doc,
                    n = hr(e);
                t.iter(function(e) {
                    var t = n(e);
                    t != e.height && rt(e, t)
                })
            }

            function pr(e, t, n, r) {
                var i = e.display;
                if (!n && "true" == Oe(t).getAttribute("cm-not-content")) return null;
                var o, a, s = i.lineSpace.getBoundingClientRect();
                try {
                    o = t.clientX - s.left, a = t.clientY - s.top
                } catch (t) {
                    return null
                }
                var l, c = nr(e, o, a);
                if (r && 1 == c.xRel && (l = et(e.doc, c.line).text).length == c.ch) {
                    var u = F(l, l.length, e.options.tabSize) - l.length;
                    c = lt(c.line, Math.max(0, Math.round((o - Pn(e.display).left) / lr(e.display)) - u))
                }
                return c
            }

            function fr(e, t) {
                if (t >= e.display.viewTo) return null;
                if ((t -= e.display.viewFrom) < 0) return null;
                for (var n = e.display.view, r = 0; r < n.length; r++)
                    if ((t -= n[r].size) < 0) return r
            }

            function mr(e, t, n, r) {
                null == t && (t = e.doc.first), null == n && (n = e.doc.first + e.doc.size), r = r || 0;
                var i = e.display;
                if (r && n < i.viewTo && (null == i.updateLineNumbers || i.updateLineNumbers > t) && (i.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= i.viewTo) Rt && Xt(e.doc, t) < i.viewTo && gr(e);
                else if (n <= i.viewFrom) Rt && Yt(e.doc, n + r) > i.viewFrom ? gr(e) : (i.viewFrom += r, i.viewTo += r);
                else if (t <= i.viewFrom && n >= i.viewTo) gr(e);
                else if (t <= i.viewFrom) {
                    var o = yr(e, n, n + r, 1);
                    o ? (i.view = i.view.slice(o.index), i.viewFrom = o.lineN, i.viewTo += r) : gr(e)
                } else if (n >= i.viewTo) {
                    var a = yr(e, t, t, -1);
                    a ? (i.view = i.view.slice(0, a.index), i.viewTo = a.lineN) : gr(e)
                } else {
                    var s = yr(e, t, t, -1),
                        l = yr(e, n, n + r, 1);
                    s && l ? (i.view = i.view.slice(0, s.index).concat(dn(e, s.lineN, l.lineN)).concat(i.view.slice(l.index)), i.viewTo += r) : gr(e)
                }
                var c = i.externalMeasured;
                c && (n < c.lineN ? c.lineN += r : t < c.lineN + c.size && (i.externalMeasured = null))
            }

            function vr(e, t, n) {
                e.curOp.viewChanged = !0;
                var r = e.display,
                    i = e.display.externalMeasured;
                if (i && t >= i.lineN && t < i.lineN + i.size && (r.externalMeasured = null), !(t < r.viewFrom || t >= r.viewTo)) {
                    var o = r.view[fr(e, t)];
                    if (null != o.node) {
                        var a = o.changes || (o.changes = []); - 1 == U(a, n) && a.push(n)
                    }
                }
            }

            function gr(e) {
                e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0
            }

            function yr(e, t, n, r) {
                var i, o = fr(e, t),
                    a = e.display.view;
                if (!Rt || n == e.doc.first + e.doc.size) return {
                    index: o,
                    lineN: n
                };
                for (var s = e.display.viewFrom, l = 0; l < o; l++) s += a[l].size;
                if (s != t) {
                    if (0 < r) {
                        if (o == a.length - 1) return null;
                        i = s + a[o].size - t, o++
                    } else i = s - t;
                    t += i, n += i
                }
                for (; Xt(e.doc, n) != n;) {
                    if (o == (r < 0 ? 0 : a.length - 1)) return null;
                    n += r * a[o - (r < 0 ? 1 : 0)].size, o += r
                }
                return {
                    index: o,
                    lineN: n
                }
            }

            function xr(e) {
                for (var t = e.display.view, n = 0, r = 0; r < t.length; r++) {
                    var i = t[r];
                    i.hidden || i.node && !i.changes || ++n
                }
                return n
            }

            function br(e) {
                e.display.input.showSelection(e.display.input.prepareSelection())
            }

            function _r(e, t) {
                void 0 === t && (t = !0);
                for (var n = e.doc, r = {}, i = r.cursors = document.createDocumentFragment(), o = r.selection = document.createDocumentFragment(), a = 0; a < n.sel.ranges.length; a++)
                    if (t || a != n.sel.primIndex) {
                        var s = n.sel.ranges[a];
                        if (!(s.from().line >= e.display.viewTo || s.to().line < e.display.viewFrom)) {
                            var l = s.empty();
                            (l || e.options.showCursorWhenSelecting) && wr(e, s.head, i), l || Mr(e, s, o)
                        }
                    }
                return r
            }

            function wr(e, t, n) {
                var r = $n(e, t, "div", null, null, !e.options.singleCursorHeightPerLine),
                    i = n.appendChild(R("div", "Â ", "CodeMirror-cursor"));
                if (i.style.left = r.left + "px", i.style.top = r.top + "px", i.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + "px", r.other) {
                    var o = n.appendChild(R("div", "Â ", "CodeMirror-cursor CodeMirror-secondarycursor"));
                    o.style.display = "", o.style.left = r.other.left + "px", o.style.top = r.other.top + "px", o.style.height = .85 * (r.other.bottom - r.other.top) + "px"
                }
            }

            function Sr(e, t) {
                return e.top - t.top || e.left - t.left
            }

            function Mr(a, e, t) {
                var n = a.display,
                    r = a.doc,
                    i = document.createDocumentFragment(),
                    o = Pn(a.display),
                    E = o.left,
                    C = Math.max(n.sizerWidth, In(a) - n.sizer.offsetLeft) - o.right,
                    L = "ltr" == r.direction;

                function A(e, t, n, r) {
                    t < 0 && (t = 0), t = Math.round(t), r = Math.round(r), i.appendChild(R("div", null, "CodeMirror-selected", "position: absolute; left: " + e + "px;\n                             top: " + t + "px; width: " + (null == n ? C - e : n) + "px;\n                             height: " + (r - t) + "px"))
                }

                function s(n, y, x) {
                    var b, _, o = et(r, n),
                        w = o.text.length;

                    function S(e, t) {
                        return Qn(a, lt(n, e), "div", o, t)
                    }

                    function M(e, t, n) {
                        var r = ir(a, o, null, e),
                            i = "ltr" == t == ("after" == n) ? "left" : "right";
                        return S("after" == n ? r.begin : r.end - (/\s/.test(o.text.charAt(r.end - 1)) ? 2 : 1), i)[i]
                    }
                    var T = ye(o, r.direction);
                    return function(e, t, n, r) {
                        if (!e) return r(t, n, "ltr", 0);
                        for (var i = !1, o = 0; o < e.length; ++o) {
                            var a = e[o];
                            (a.from < n && a.to > t || t == n && a.to == t) && (r(Math.max(a.from, t), Math.min(a.to, n), 1 == a.level ? "rtl" : "ltr", o), i = !0)
                        }
                        i || r(t, n, "ltr")
                    }(T, y || 0, null == x ? w : x, function(e, t, n, r) {
                        var i = "ltr" == n,
                            o = S(e, i ? "left" : "right"),
                            a = S(t - 1, i ? "right" : "left"),
                            s = null == y && 0 == e,
                            l = null == x && t == w,
                            c = 0 == r,
                            u = !T || r == T.length - 1;
                        if (a.top - o.top <= 3) {
                            var h = (L ? l : s) && u,
                                d = (L ? s : l) && c ? E : (i ? o : a).left,
                                p = h ? C : (i ? a : o).right;
                            A(d, o.top, p - d, o.bottom)
                        } else {
                            var f, m, v, g;
                            g = i ? (f = L && s && c ? E : o.left, m = L ? C : M(e, n, "before"), v = L ? E : M(t, n, "after"), L && l && u ? C : a.right) : (f = L ? M(e, n, "before") : E, m = !L && s && c ? C : o.right, v = !L && l && u ? E : a.left, L ? M(t, n, "after") : C), A(f, o.top, m - f, o.bottom), o.bottom < a.top && A(E, o.bottom, null, a.top), A(v, a.top, g - v, a.bottom)
                        }(!b || Sr(o, b) < 0) && (b = o), Sr(a, b) < 0 && (b = a), (!_ || Sr(o, _) < 0) && (_ = o), Sr(a, _) < 0 && (_ = a)
                    }), {
                        start: b,
                        end: _
                    }
                }
                var l = e.from(),
                    c = e.to();
                if (l.line == c.line) s(l.line, l.ch, c.ch);
                else {
                    var u = et(r, l.line),
                        h = et(r, c.line),
                        d = qt(u) == qt(h),
                        p = s(l.line, l.ch, d ? u.text.length + 1 : null).end,
                        f = s(c.line, d ? 0 : null, c.ch).start;
                    d && (p.top < f.top - 2 ? (A(p.right, p.top, null, p.bottom), A(E, f.top, f.left, f.bottom)) : A(p.right, p.top, f.left - p.right, p.bottom)), p.bottom < f.top && A(E, p.bottom, null, f.top)
                }
                t.appendChild(i)
            }

            function Tr(e) {
                if (e.state.focused) {
                    var t = e.display;
                    clearInterval(t.blinker);
                    var n = !0;
                    t.cursorDiv.style.visibility = "", 0 < e.options.cursorBlinkRate ? t.blinker = setInterval(function() {
                        return t.cursorDiv.style.visibility = (n = !n) ? "" : "hidden"
                    }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden")
                }
            }

            function Er(e) {
                e.state.focused || (e.display.input.focus(), Lr(e))
            }

            function Cr(e) {
                e.state.delayingBlurEvent = !0, setTimeout(function() {
                    e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, Ar(e))
                }, 100)
            }

            function Lr(e, t) {
                e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1), "nocursor" != e.options.readOnly && (e.state.focused || (Se(e, "focus", e, t), e.state.focused = !0, I(e.display.wrapper, "CodeMirror-focused"), e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(), x && setTimeout(function() {
                    return e.display.input.reset(!0)
                }, 20)), e.display.input.receivedFocus()), Tr(e))
            }

            function Ar(e, t) {
                e.state.delayingBlurEvent || (e.state.focused && (Se(e, "blur", e, t), e.state.focused = !1, E(e.display.wrapper, "CodeMirror-focused")), clearInterval(e.display.blinker), setTimeout(function() {
                    e.state.focused || (e.display.shift = !1)
                }, 150))
            }

            function Rr(e) {
                for (var t = e.display, n = t.lineDiv.offsetTop, r = 0; r < t.view.length; r++) {
                    var i = t.view[r],
                        o = e.options.lineWrapping,
                        a = void 0,
                        s = 0;
                    if (!i.hidden) {
                        if (_ && w < 8) {
                            var l = i.node.offsetTop + i.node.offsetHeight;
                            a = l - n, n = l
                        } else {
                            var c = i.node.getBoundingClientRect();
                            a = c.bottom - c.top, !o && i.text.firstChild && (s = i.text.firstChild.getBoundingClientRect().right - c.left - 1)
                        }
                        var u = i.line.height - a;
                        if ((.005 < u || u < -.005) && (rt(i.line, a), Pr(i.line), i.rest))
                            for (var h = 0; h < i.rest.length; h++) Pr(i.rest[h]);
                        if (s > e.display.sizerWidth) {
                            var d = Math.ceil(s / lr(e.display));
                            d > e.display.maxLineLength && (e.display.maxLineLength = d, e.display.maxLine = i.line, e.display.maxLineChanged = !0)
                        }
                    }
                }
            }

            function Pr(e) {
                if (e.widgets)
                    for (var t = 0; t < e.widgets.length; ++t) {
                        var n = e.widgets[t],
                            r = n.node.parentNode;
                        r && (n.height = r.offsetHeight)
                    }
            }

            function Or(e, t, n) {
                var r = n && null != n.top ? Math.max(0, n.top) : e.scroller.scrollTop;
                r = Math.floor(r - An(e));
                var i = n && null != n.bottom ? n.bottom : r + e.wrapper.clientHeight,
                    o = ot(t, r),
                    a = ot(t, i);
                if (n && n.ensure) {
                    var s = n.ensure.from.line,
                        l = n.ensure.to.line;
                    s < o ? a = ot(t, Jt(et(t, o = s)) + e.wrapper.clientHeight) : Math.min(l, t.lastLine()) >= a && (o = ot(t, Jt(et(t, l)) - e.wrapper.clientHeight), a = l)
                }
                return {
                    from: o,
                    to: Math.max(a, o + 1)
                }
            }

            function Ir(e, t) {
                var n = e.display,
                    r = sr(e.display);
                t.top < 0 && (t.top = 0);
                var i = e.curOp && null != e.curOp.scrollTop ? e.curOp.scrollTop : n.scroller.scrollTop,
                    o = Dn(e),
                    a = {};
                t.bottom - t.top > o && (t.bottom = t.top + o);
                var s = e.doc.height + Rn(n),
                    l = t.top < r,
                    c = t.bottom > s - r;
                if (t.top < i) a.scrollTop = l ? 0 : t.top;
                else if (t.bottom > i + o) {
                    var u = Math.min(t.top, (c ? s : t.bottom) - o);
                    u != i && (a.scrollTop = u)
                }
                var h = e.curOp && null != e.curOp.scrollLeft ? e.curOp.scrollLeft : n.scroller.scrollLeft,
                    d = In(e) - (e.options.fixedGutter ? n.gutters.offsetWidth : 0),
                    p = t.right - t.left > d;
                return p && (t.right = t.left + d), t.left < 10 ? a.scrollLeft = 0 : t.left < h ? a.scrollLeft = Math.max(0, t.left - (p ? 0 : 10)) : t.right > d + h - 3 && (a.scrollLeft = t.right + (p ? 0 : 10) - d), a
            }

            function Dr(e, t) {
                null != t && (zr(e), e.curOp.scrollTop = (null == e.curOp.scrollTop ? e.doc.scrollTop : e.curOp.scrollTop) + t)
            }

            function Nr(e) {
                zr(e);
                var t = e.getCursor();
                e.curOp.scrollToPos = {
                    from: t,
                    to: t,
                    margin: e.options.cursorScrollMargin
                }
            }

            function kr(e, t, n) {
                null == t && null == n || zr(e), null != t && (e.curOp.scrollLeft = t), null != n && (e.curOp.scrollTop = n)
            }

            function zr(e) {
                var t = e.curOp.scrollToPos;
                t && (e.curOp.scrollToPos = null, Fr(e, er(e, t.from), er(e, t.to), t.margin))
            }

            function Fr(e, t, n, r) {
                var i = Ir(e, {
                    left: Math.min(t.left, n.left),
                    top: Math.min(t.top, n.top) - r,
                    right: Math.max(t.right, n.right),
                    bottom: Math.max(t.bottom, n.bottom) + r
                });
                kr(e, i.scrollLeft, i.scrollTop)
            }

            function Br(e, t) {
                Math.abs(e.doc.scrollTop - t) < 2 || (m || hi(e, {
                    top: t
                }), Ur(e, t, !0), m && hi(e), ai(e, 100))
            }

            function Ur(e, t, n) {
                t = Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t), e.display.scroller.scrollTop == t && !n || (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t))
            }

            function Hr(e, t, n, r) {
                t = Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth), (n ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !r || (e.doc.scrollLeft = t, fi(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t))
            }

            function Gr(e) {
                var t = e.display,
                    n = t.gutters.offsetWidth,
                    r = Math.round(e.doc.height + Rn(e.display));
                return {
                    clientHeight: t.scroller.clientHeight,
                    viewHeight: t.wrapper.clientHeight,
                    scrollWidth: t.scroller.scrollWidth,
                    clientWidth: t.scroller.clientWidth,
                    viewWidth: t.wrapper.clientWidth,
                    barLeft: e.options.fixedGutter ? n : 0,
                    docHeight: r,
                    scrollHeight: r + On(e) + t.barHeight,
                    nativeBarWidth: t.nativeBarWidth,
                    gutterWidth: n
                }
            }

            function Vr(e, t, n) {
                this.cm = n;
                var r = this.vert = R("div", [R("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"),
                    i = this.horiz = R("div", [R("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
                r.tabIndex = i.tabIndex = -1, e(r), e(i), be(r, "scroll", function() {
                    r.clientHeight && t(r.scrollTop, "vertical")
                }), be(i, "scroll", function() {
                    i.clientWidth && t(i.scrollLeft, "horizontal")
                }), this.checkedZeroWidth = !1, _ && w < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
            }
            Vr.prototype.update = function(e) {
                var t = e.scrollWidth > e.clientWidth + 1,
                    n = e.scrollHeight > e.clientHeight + 1,
                    r = e.nativeBarWidth;
                if (n) {
                    this.vert.style.display = "block", this.vert.style.bottom = t ? r + "px" : "0";
                    var i = e.viewHeight - (t ? r : 0);
                    this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + i) + "px"
                } else this.vert.style.display = "", this.vert.firstChild.style.height = "0";
                if (t) {
                    this.horiz.style.display = "block", this.horiz.style.right = n ? r + "px" : "0", this.horiz.style.left = e.barLeft + "px";
                    var o = e.viewWidth - e.barLeft - (n ? r : 0);
                    this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + o) + "px"
                } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
                return !this.checkedZeroWidth && 0 < e.clientHeight && (0 == r && this.zeroWidthHack(), this.checkedZeroWidth = !0), {
                    right: n ? r : 0,
                    bottom: t ? r : 0
                }
            }, Vr.prototype.setScrollLeft = function(e) {
                this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz")
            }, Vr.prototype.setScrollTop = function(e) {
                this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert")
            }, Vr.prototype.zeroWidthHack = function() {
                var e = b && !s ? "12px" : "18px";
                this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", this.disableHoriz = new B, this.disableVert = new B
            }, Vr.prototype.enableZeroWidthBar = function(n, r, i) {
                n.style.pointerEvents = "auto", r.set(1e3, function e() {
                    var t = n.getBoundingClientRect();
                    ("vert" == i ? document.elementFromPoint(t.right - 1, (t.top + t.bottom) / 2) : document.elementFromPoint((t.right + t.left) / 2, t.bottom - 1)) != n ? n.style.pointerEvents = "none" : r.set(1e3, e)
                })
            }, Vr.prototype.clear = function() {
                var e = this.horiz.parentNode;
                e.removeChild(this.horiz), e.removeChild(this.vert)
            };

            function Wr() {}

            function jr(e, t) {
                t = t || Gr(e);
                var n = e.display.barWidth,
                    r = e.display.barHeight;
                qr(e, t);
                for (var i = 0; i < 4 && n != e.display.barWidth || r != e.display.barHeight; i++) n != e.display.barWidth && e.options.lineWrapping && Rr(e), qr(e, Gr(e)), n = e.display.barWidth, r = e.display.barHeight
            }

            function qr(e, t) {
                var n = e.display,
                    r = n.scrollbars.update(t);
                n.sizer.style.paddingRight = (n.barWidth = r.right) + "px", n.sizer.style.paddingBottom = (n.barHeight = r.bottom) + "px", n.heightForcer.style.borderBottom = r.bottom + "px solid transparent", r.right && r.bottom ? (n.scrollbarFiller.style.display = "block", n.scrollbarFiller.style.height = r.bottom + "px", n.scrollbarFiller.style.width = r.right + "px") : n.scrollbarFiller.style.display = "", r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (n.gutterFiller.style.display = "block", n.gutterFiller.style.height = r.bottom + "px", n.gutterFiller.style.width = t.gutterWidth + "px") : n.gutterFiller.style.display = ""
            }
            Wr.prototype.update = function() {
                return {
                    bottom: 0,
                    right: 0
                }
            }, Wr.prototype.setScrollLeft = function() {}, Wr.prototype.setScrollTop = function() {}, Wr.prototype.clear = function() {};
            var Xr = {
                native: Vr,
                null: Wr
            };

            function Yr(n) {
                n.display.scrollbars && (n.display.scrollbars.clear(), n.display.scrollbars.addClass && E(n.display.wrapper, n.display.scrollbars.addClass)), n.display.scrollbars = new Xr[n.options.scrollbarStyle](function(e) {
                    n.display.wrapper.insertBefore(e, n.display.scrollbarFiller), be(e, "mousedown", function() {
                        n.state.focused && setTimeout(function() {
                            return n.display.input.focus()
                        }, 0)
                    }), e.setAttribute("cm-not-content", "true")
                }, function(e, t) {
                    "horizontal" == t ? Hr(n, e) : Br(n, e)
                }, n), n.display.scrollbars.addClass && I(n.display.wrapper, n.display.scrollbars.addClass)
            }
            var Zr = 0;

            function Kr(e) {
                e.curOp = {
                        cm: e,
                        viewChanged: !1,
                        startHeight: e.doc.height,
                        forceUpdate: !1,
                        updateInput: 0,
                        typing: !1,
                        changeObjs: null,
                        cursorActivityHandlers: null,
                        cursorActivityCalled: 0,
                        selectionChanged: !1,
                        updateMaxLine: !1,
                        scrollLeft: null,
                        scrollTop: null,
                        scrollToPos: null,
                        focus: !1,
                        id: ++Zr
                    },
                    function(e) {
                        pn ? pn.ops.push(e) : e.ownsGroup = pn = {
                            ops: [e],
                            delayedCallbacks: []
                        }
                    }(e.curOp)
            }

            function Jr(e) {
                var t = e.curOp;
                t && function(e, t) {
                    var n = e.ownsGroup;
                    if (n) try {
                        ! function(e) {
                            var t = e.delayedCallbacks,
                                n = 0;
                            do {
                                for (; n < t.length; n++) t[n].call(null);
                                for (var r = 0; r < e.ops.length; r++) {
                                    var i = e.ops[r];
                                    if (i.cursorActivityHandlers)
                                        for (; i.cursorActivityCalled < i.cursorActivityHandlers.length;) i.cursorActivityHandlers[i.cursorActivityCalled++].call(null, i.cm)
                                }
                            } while (n < t.length)
                        }(n)
                    } finally {
                        pn = null, t(n)
                    }
                }(t, function(e) {
                    for (var t = 0; t < e.ops.length; t++) e.ops[t].cm.curOp = null;
                    ! function(e) {
                        for (var t = e.ops, n = 0; n < t.length; n++) Qr(t[n]);
                        for (var r = 0; r < t.length; r++)(i = t[r]).updatedDisplay = i.mustUpdate && ci(i.cm, i.update);
                        var i;
                        for (var o = 0; o < t.length; o++) $r(t[o]);
                        for (var a = 0; a < t.length; a++) ei(t[a]);
                        for (var s = 0; s < t.length; s++) ti(t[s])
                    }(e)
                })
            }

            function Qr(e) {
                var t = e.cm,
                    n = t.display;
                ! function(e) {
                    var t = e.display;
                    !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = On(e) + "px", t.sizer.style.marginBottom = -t.nativeBarWidth + "px", t.sizer.style.borderRightWidth = On(e) + "px", t.scrollbarsClipped = !0)
                }(t), e.updateMaxLine && $t(t), e.mustUpdate = e.viewChanged || e.forceUpdate || null != e.scrollTop || e.scrollToPos && (e.scrollToPos.from.line < n.viewFrom || e.scrollToPos.to.line >= n.viewTo) || n.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new li(t, e.mustUpdate && {
                    top: e.scrollTop,
                    ensure: e.scrollToPos
                }, e.forceUpdate)
            }

            function $r(e) {
                var t = e.cm,
                    n = t.display;
                e.updatedDisplay && Rr(t), e.barMeasure = Gr(t), n.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = kn(t, n.maxLine, n.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(n.scroller.clientWidth, n.sizer.offsetLeft + e.adjustWidthTo + On(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, n.sizer.offsetLeft + e.adjustWidthTo - In(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = n.input.prepareSelection())
            }

            function ei(e) {
                var t = e.cm;
                null != e.adjustWidthTo && (t.display.sizer.style.minWidth = e.adjustWidthTo + "px", e.maxScrollLeft < t.doc.scrollLeft && Hr(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1);
                var n = e.focus && e.focus == O();
                e.preparedSelection && t.display.input.showSelection(e.preparedSelection, n), !e.updatedDisplay && e.startHeight == t.doc.height || jr(t, e.barMeasure), e.updatedDisplay && pi(t, e.barMeasure), e.selectionChanged && Tr(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), n && Er(e.cm)
            }

            function ti(e) {
                var t = e.cm,
                    n = t.display,
                    r = t.doc;
                e.updatedDisplay && ui(t, e.update), null == n.wheelStartX || null == e.scrollTop && null == e.scrollLeft && !e.scrollToPos || (n.wheelStartX = n.wheelStartY = null), null != e.scrollTop && Ur(t, e.scrollTop, e.forceScroll), null != e.scrollLeft && Hr(t, e.scrollLeft, !0, !0), e.scrollToPos && function(e, t) {
                    if (!Me(e, "scrollCursorIntoView")) {
                        var n = e.display,
                            r = n.sizer.getBoundingClientRect(),
                            i = null;
                        if (t.top + r.top < 0 ? i = !0 : t.bottom + r.top > (window.innerHeight || document.documentElement.clientHeight) && (i = !1), null != i && !c) {
                            var o = R("div", "â€‹", null, "position: absolute;\n                         top: " + (t.top - n.viewOffset - An(e.display)) + "px;\n                         height: " + (t.bottom - t.top + On(e) + n.barHeight) + "px;\n                         left: " + t.left + "px; width: " + Math.max(2, t.right - t.left) + "px;");
                            e.display.lineSpace.appendChild(o), o.scrollIntoView(i), e.display.lineSpace.removeChild(o)
                        }
                    }
                }(t, function(e, t, n, r) {
                    var i;
                    null == r && (r = 0), e.options.lineWrapping || t != n || (n = "before" == (t = t.ch ? lt(t.line, "before" == t.sticky ? t.ch - 1 : t.ch, "after") : t).sticky ? lt(t.line, t.ch + 1, "before") : t);
                    for (var o = 0; o < 5; o++) {
                        var a = !1,
                            s = $n(e, t),
                            l = n && n != t ? $n(e, n) : s,
                            c = Ir(e, i = {
                                left: Math.min(s.left, l.left),
                                top: Math.min(s.top, l.top) - r,
                                right: Math.max(s.left, l.left),
                                bottom: Math.max(s.bottom, l.bottom) + r
                            }),
                            u = e.doc.scrollTop,
                            h = e.doc.scrollLeft;
                        if (null != c.scrollTop && (Br(e, c.scrollTop), 1 < Math.abs(e.doc.scrollTop - u) && (a = !0)), null != c.scrollLeft && (Hr(e, c.scrollLeft), 1 < Math.abs(e.doc.scrollLeft - h) && (a = !0)), !a) break
                    }
                    return i
                }(t, mt(r, e.scrollToPos.from), mt(r, e.scrollToPos.to), e.scrollToPos.margin));
                var i = e.maybeHiddenMarkers,
                    o = e.maybeUnhiddenMarkers;
                if (i)
                    for (var a = 0; a < i.length; ++a) i[a].lines.length || Se(i[a], "hide");
                if (o)
                    for (var s = 0; s < o.length; ++s) o[s].lines.length && Se(o[s], "unhide");
                n.wrapper.offsetHeight && (r.scrollTop = t.display.scroller.scrollTop), e.changeObjs && Se(t, "changes", t, e.changeObjs), e.update && e.update.finish()
            }

            function ni(e, t) {
                if (e.curOp) return t();
                Kr(e);
                try {
                    return t()
                } finally {
                    Jr(e)
                }
            }

            function ri(e, t) {
                return function() {
                    if (e.curOp) return t.apply(e, arguments);
                    Kr(e);
                    try {
                        return t.apply(e, arguments)
                    } finally {
                        Jr(e)
                    }
                }
            }

            function ii(e) {
                return function() {
                    if (this.curOp) return e.apply(this, arguments);
                    Kr(this);
                    try {
                        return e.apply(this, arguments)
                    } finally {
                        Jr(this)
                    }
                }
            }

            function oi(t) {
                return function() {
                    var e = this.cm;
                    if (!e || e.curOp) return t.apply(this, arguments);
                    Kr(e);
                    try {
                        return t.apply(this, arguments)
                    } finally {
                        Jr(e)
                    }
                }
            }

            function ai(e, t) {
                e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, k(si, e))
            }

            function si(l) {
                var c = l.doc;
                if (!(c.highlightFrontier >= l.display.viewTo)) {
                    var u = +new Date + l.options.workTime,
                        h = _t(l, c.highlightFrontier),
                        d = [];
                    c.iter(h.line, Math.min(c.first + c.size, l.display.viewTo + 500), function(e) {
                        if (h.line >= l.display.viewFrom) {
                            var t = e.styles,
                                n = e.text.length > l.options.maxHighlightLength ? Ke(c.mode, h.state) : null,
                                r = xt(l, e, h, !0);
                            n && (h.state = n), e.styles = r.styles;
                            var i = e.styleClasses,
                                o = r.classes;
                            o ? e.styleClasses = o : i && (e.styleClasses = null);
                            for (var a = !t || t.length != e.styles.length || i != o && (!i || !o || i.bgClass != o.bgClass || i.textClass != o.textClass), s = 0; !a && s < t.length; ++s) a = t[s] != e.styles[s];
                            a && d.push(h.line), e.stateAfter = h.save(), h.nextLine()
                        } else e.text.length <= l.options.maxHighlightLength && wt(l, e.text, h), e.stateAfter = h.line % 5 == 0 ? h.save() : null, h.nextLine();
                        if (+new Date > u) return ai(l, l.options.workDelay), !0
                    }), c.highlightFrontier = h.line, c.modeFrontier = Math.max(c.modeFrontier, h.line), d.length && ni(l, function() {
                        for (var e = 0; e < d.length; e++) vr(l, d[e], "text")
                    })
                }
            }
            var li = function(e, t, n) {
                var r = e.display;
                this.viewport = t, this.visible = Or(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = In(e), this.force = n, this.dims = cr(e), this.events = []
            };

            function ci(e, t) {
                var n = e.display,
                    r = e.doc;
                if (t.editorIsHidden) return gr(e), !1;
                if (!t.force && t.visible.from >= n.viewFrom && t.visible.to <= n.viewTo && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo) && n.renderedView == n.view && 0 == xr(e)) return !1;
                mi(e) && (gr(e), t.dims = cr(e));
                var i = r.first + r.size,
                    o = Math.max(t.visible.from - e.options.viewportMargin, r.first),
                    a = Math.min(i, t.visible.to + e.options.viewportMargin);
                n.viewFrom < o && o - n.viewFrom < 20 && (o = Math.max(r.first, n.viewFrom)), n.viewTo > a && n.viewTo - a < 20 && (a = Math.min(i, n.viewTo)), Rt && (o = Xt(e.doc, o), a = Yt(e.doc, a));
                var s = o != n.viewFrom || a != n.viewTo || n.lastWrapHeight != t.wrapperHeight || n.lastWrapWidth != t.wrapperWidth;
                ! function(e, t, n) {
                    var r = e.display;
                    0 == r.view.length || t >= r.viewTo || n <= r.viewFrom ? (r.view = dn(e, t, n), r.viewFrom = t) : (r.viewFrom > t ? r.view = dn(e, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(fr(e, t))), r.viewFrom = t, r.viewTo < n ? r.view = r.view.concat(dn(e, r.viewTo, n)) : r.viewTo > n && (r.view = r.view.slice(0, fr(e, n)))), r.viewTo = n
                }(e, o, a), n.viewOffset = Jt(et(e.doc, n.viewFrom)), e.display.mover.style.top = n.viewOffset + "px";
                var l = xr(e);
                if (!s && 0 == l && !t.force && n.renderedView == n.view && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo)) return !1;
                var c = function(e) {
                    if (e.hasFocus()) return null;
                    var t = O();
                    if (!t || !P(e.display.lineDiv, t)) return null;
                    var n = {
                        activeElt: t
                    };
                    if (window.getSelection) {
                        var r = window.getSelection();
                        r.anchorNode && r.extend && P(e.display.lineDiv, r.anchorNode) && (n.anchorNode = r.anchorNode, n.anchorOffset = r.anchorOffset, n.focusNode = r.focusNode, n.focusOffset = r.focusOffset)
                    }
                    return n
                }(e);
                return 4 < l && (n.lineDiv.style.display = "none"),
                    function(n, e, t) {
                        var r = n.display,
                            i = n.options.lineNumbers,
                            o = r.lineDiv,
                            a = o.firstChild;

                        function s(e) {
                            var t = e.nextSibling;
                            return x && b && n.display.currentWheelTarget == e ? e.style.display = "none" : e.parentNode.removeChild(e), t
                        }
                        for (var l = r.view, c = r.viewFrom, u = 0; u < l.length; u++) {
                            var h = l[u];
                            if (h.hidden);
                            else if (h.node && h.node.parentNode == o) {
                                for (; a != h.node;) a = s(a);
                                var d = i && null != e && e <= c && h.lineNumber;
                                h.changes && (-1 < U(h.changes, "gutter") && (d = !1), gn(n, h, c, t)), d && (C(h.lineNumber), h.lineNumber.appendChild(document.createTextNode(st(n.options, c)))), a = h.node.nextSibling
                            } else {
                                var p = (v = c, g = t, void 0, y = xn(f = n, m = h), m.text = m.node = y.pre, y.bgClass && (m.bgClass = y.bgClass), y.textClass && (m.textClass = y.textClass), _n(f, m), wn(f, m, v, g), Mn(f, m, g), m.node);
                                o.insertBefore(p, a)
                            }
                            c += h.size
                        }
                        var f, m, v, g, y;
                        for (; a;) a = s(a)
                    }(e, n.updateLineNumbers, t.dims), 4 < l && (n.lineDiv.style.display = ""), n.renderedView = n.view,
                    function(e) {
                        if (e && e.activeElt && e.activeElt != O() && (e.activeElt.focus(), e.anchorNode && P(document.body, e.anchorNode) && P(document.body, e.focusNode))) {
                            var t = window.getSelection(),
                                n = document.createRange();
                            n.setEnd(e.anchorNode, e.anchorOffset), n.collapse(!1), t.removeAllRanges(), t.addRange(n), t.extend(e.focusNode, e.focusOffset)
                        }
                    }(c), C(n.cursorDiv), C(n.selectionDiv), n.gutters.style.height = n.sizer.style.minHeight = 0, s && (n.lastWrapHeight = t.wrapperHeight, n.lastWrapWidth = t.wrapperWidth, ai(e, 400)), !(n.updateLineNumbers = null)
            }

            function ui(e, t) {
                for (var n = t.viewport, r = !0;
                    (r && e.options.lineWrapping && t.oldDisplayWidth != In(e) || (n && null != n.top && (n = {
                        top: Math.min(e.doc.height + Rn(e.display) - Dn(e), n.top)
                    }), t.visible = Or(e.display, e.doc, n), !(t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo))) && ci(e, t); r = !1) {
                    Rr(e);
                    var i = Gr(e);
                    br(e), jr(e, i), pi(e, i), t.force = !1
                }
                t.signal(e, "update", e), e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo)
            }

            function hi(e, t) {
                var n = new li(e, t);
                if (ci(e, n)) {
                    Rr(e), ui(e, n);
                    var r = Gr(e);
                    br(e), jr(e, r), pi(e, r), n.finish()
                }
            }

            function di(e) {
                var t = e.gutters.offsetWidth;
                e.sizer.style.marginLeft = t + "px"
            }

            function pi(e, t) {
                e.display.sizer.style.minHeight = t.docHeight + "px", e.display.heightForcer.style.top = t.docHeight + "px", e.display.gutters.style.height = t.docHeight + e.display.barHeight + On(e) + "px"
            }

            function fi(e) {
                var t = e.display,
                    n = t.view;
                if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) {
                    for (var r = ur(t) - t.scroller.scrollLeft + e.doc.scrollLeft, i = t.gutters.offsetWidth, o = r + "px", a = 0; a < n.length; a++)
                        if (!n[a].hidden) {
                            e.options.fixedGutter && (n[a].gutter && (n[a].gutter.style.left = o), n[a].gutterBackground && (n[a].gutterBackground.style.left = o));
                            var s = n[a].alignable;
                            if (s)
                                for (var l = 0; l < s.length; l++) s[l].style.left = o
                        }
                    e.options.fixedGutter && (t.gutters.style.left = r + i + "px")
                }
            }

            function mi(e) {
                if (!e.options.lineNumbers) return !1;
                var t = e.doc,
                    n = st(e.options, t.first + t.size - 1),
                    r = e.display;
                if (n.length == r.lineNumChars) return !1;
                var i = r.measure.appendChild(R("div", [R("div", n)], "CodeMirror-linenumber CodeMirror-gutter-elt")),
                    o = i.firstChild.offsetWidth,
                    a = i.offsetWidth - o;
                return r.lineGutter.style.width = "", r.lineNumInnerWidth = Math.max(o, r.lineGutter.offsetWidth - a) + 1, r.lineNumWidth = r.lineNumInnerWidth + a, r.lineNumChars = r.lineNumInnerWidth ? n.length : -1, r.lineGutter.style.width = r.lineNumWidth + "px", di(e.display), !0
            }

            function vi(e, t) {
                for (var n = [], r = !1, i = 0; i < e.length; i++) {
                    var o = e[i],
                        a = null;
                    if ("string" != typeof o && (a = o.style, o = o.className), "CodeMirror-linenumbers" == o) {
                        if (!t) continue;
                        r = !0
                    }
                    n.push({
                        className: o,
                        style: a
                    })
                }
                return t && !r && n.push({
                    className: "CodeMirror-linenumbers",
                    style: null
                }), n
            }

            function gi(e) {
                var t = e.gutters,
                    n = e.gutterSpecs;
                C(t), e.lineGutter = null;
                for (var r = 0; r < n.length; ++r) {
                    var i = n[r],
                        o = i.className,
                        a = i.style,
                        s = t.appendChild(R("div", null, "CodeMirror-gutter " + o));
                    a && (s.style.cssText = a), "CodeMirror-linenumbers" == o && ((e.lineGutter = s).style.width = (e.lineNumWidth || 1) + "px")
                }
                t.style.display = n.length ? "" : "none", di(e)
            }

            function yi(e) {
                gi(e.display), mr(e), fi(e)
            }

            function xi(e, t, n, r) {
                var i = this;
                this.input = n, i.scrollbarFiller = R("div", null, "CodeMirror-scrollbar-filler"), i.scrollbarFiller.setAttribute("cm-not-content", "true"), i.gutterFiller = R("div", null, "CodeMirror-gutter-filler"), i.gutterFiller.setAttribute("cm-not-content", "true"), i.lineDiv = A("div", null, "CodeMirror-code"), i.selectionDiv = R("div", null, null, "position: relative; z-index: 1"), i.cursorDiv = R("div", null, "CodeMirror-cursors"), i.measure = R("div", null, "CodeMirror-measure"), i.lineMeasure = R("div", null, "CodeMirror-measure"), i.lineSpace = A("div", [i.measure, i.lineMeasure, i.selectionDiv, i.cursorDiv, i.lineDiv], null, "position: relative; outline: none");
                var o = A("div", [i.lineSpace], "CodeMirror-lines");
                i.mover = R("div", [o], null, "position: relative"), i.sizer = R("div", [i.mover], "CodeMirror-sizer"), i.sizerWidth = null, i.heightForcer = R("div", null, null, "position: absolute; height: " + H + "px; width: 1px;"), i.gutters = R("div", null, "CodeMirror-gutters"), i.lineGutter = null, i.scroller = R("div", [i.sizer, i.heightForcer, i.gutters], "CodeMirror-scroll"), i.scroller.setAttribute("tabIndex", "-1"), i.wrapper = R("div", [i.scrollbarFiller, i.gutterFiller, i.scroller], "CodeMirror"), _ && w < 8 && (i.gutters.style.zIndex = -1, i.scroller.style.paddingRight = 0), x || m && d || (i.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(i.wrapper) : e(i.wrapper)), i.viewFrom = i.viewTo = t.first, i.reportedViewFrom = i.reportedViewTo = t.first, i.view = [], i.renderedView = null, i.externalMeasured = null, i.viewOffset = 0, i.lastWrapHeight = i.lastWrapWidth = 0, i.updateLineNumbers = null, i.nativeBarWidth = i.barHeight = i.barWidth = 0, i.scrollbarsClipped = !1, i.lineNumWidth = i.lineNumInnerWidth = i.lineNumChars = null, i.alignWidgets = !1, i.cachedCharWidth = i.cachedTextHeight = i.cachedPaddingH = null, i.maxLine = null, i.maxLineLength = 0, i.maxLineChanged = !1, i.wheelDX = i.wheelDY = i.wheelStartX = i.wheelStartY = null, i.shift = !1, i.selForContextMenu = null, i.activeTouch = null, i.gutterSpecs = vi(r.gutters, r.lineNumbers), gi(i), n.init(i)
            }
            li.prototype.signal = function(e, t) {
                Ee(e, t) && this.events.push(arguments)
            }, li.prototype.finish = function() {
                for (var e = 0; e < this.events.length; e++) Se.apply(null, this.events[e])
            };
            var bi = 0,
                _i = null;

            function wi(e) {
                var t = e.wheelDeltaX,
                    n = e.wheelDeltaY;
                return null == t && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), null == n && e.detail && e.axis == e.VERTICAL_AXIS ? n = e.detail : null == n && (n = e.wheelDelta), {
                    x: t,
                    y: n
                }
            }

            function Si(e) {
                var t = wi(e);
                return t.x *= _i, t.y *= _i, t
            }

            function Mi(e, t) {
                var n = wi(t),
                    r = n.x,
                    i = n.y,
                    o = e.display,
                    a = o.scroller,
                    s = a.scrollWidth > a.clientWidth,
                    l = a.scrollHeight > a.clientHeight;
                if (r && s || i && l) {
                    if (i && b && x) e: for (var c = t.target, u = o.view; c != a; c = c.parentNode)
                        for (var h = 0; h < u.length; h++)
                            if (u[h].node == c) {
                                e.display.currentWheelTarget = c;
                                break e
                            }
                    if (r && !m && !v && null != _i) return i && l && Br(e, Math.max(0, a.scrollTop + i * _i)), Hr(e, Math.max(0, a.scrollLeft + r * _i)), (!i || i && l) && Le(t), void(o.wheelStartX = null);
                    if (i && null != _i) {
                        var d = i * _i,
                            p = e.doc.scrollTop,
                            f = p + o.wrapper.clientHeight;
                        d < 0 ? p = Math.max(0, p + d - 50) : f = Math.min(e.doc.height, f + d + 50), hi(e, {
                            top: p,
                            bottom: f
                        })
                    }
                    bi < 20 && (null == o.wheelStartX ? (o.wheelStartX = a.scrollLeft, o.wheelStartY = a.scrollTop, o.wheelDX = r, o.wheelDY = i, setTimeout(function() {
                        if (null != o.wheelStartX) {
                            var e = a.scrollLeft - o.wheelStartX,
                                t = a.scrollTop - o.wheelStartY,
                                n = t && o.wheelDY && t / o.wheelDY || e && o.wheelDX && e / o.wheelDX;
                            o.wheelStartX = o.wheelStartY = null, n && (_i = (_i * bi + n) / (bi + 1), ++bi)
                        }
                    }, 200)) : (o.wheelDX += r, o.wheelDY += i))
                }
            }
            _ ? _i = -.53 : m ? _i = 15 : a ? _i = -.7 : l && (_i = -1 / 3);
            var Ti = function(e, t) {
                this.ranges = e, this.primIndex = t
            };
            Ti.prototype.primary = function() {
                return this.ranges[this.primIndex]
            }, Ti.prototype.equals = function(e) {
                if (e == this) return !0;
                if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length) return !1;
                for (var t = 0; t < this.ranges.length; t++) {
                    var n = this.ranges[t],
                        r = e.ranges[t];
                    if (!ut(n.anchor, r.anchor) || !ut(n.head, r.head)) return !1
                }
                return !0
            }, Ti.prototype.deepCopy = function() {
                for (var e = [], t = 0; t < this.ranges.length; t++) e[t] = new Ei(ht(this.ranges[t].anchor), ht(this.ranges[t].head));
                return new Ti(e, this.primIndex)
            }, Ti.prototype.somethingSelected = function() {
                for (var e = 0; e < this.ranges.length; e++)
                    if (!this.ranges[e].empty()) return !0;
                return !1
            }, Ti.prototype.contains = function(e, t) {
                t = t || e;
                for (var n = 0; n < this.ranges.length; n++) {
                    var r = this.ranges[n];
                    if (0 <= ct(t, r.from()) && ct(e, r.to()) <= 0) return n
                }
                return -1
            };
            var Ei = function(e, t) {
                this.anchor = e, this.head = t
            };

            function Ci(e, t, n) {
                var r = e && e.options.selectionsMayTouch,
                    i = t[n];
                t.sort(function(e, t) {
                    return ct(e.from(), t.from())
                }), n = U(t, i);
                for (var o = 1; o < t.length; o++) {
                    var a = t[o],
                        s = t[o - 1],
                        l = ct(s.to(), a.from());
                    if (r && !a.empty() ? 0 < l : 0 <= l) {
                        var c = pt(s.from(), a.from()),
                            u = dt(s.to(), a.to()),
                            h = s.empty() ? a.from() == a.head : s.from() == s.head;
                        o <= n && --n, t.splice(--o, 2, new Ei(h ? u : c, h ? c : u))
                    }
                }
                return new Ti(t, n)
            }

            function Li(e, t) {
                return new Ti([new Ei(e, t || e)], 0)
            }

            function Ai(e) {
                return e.text ? lt(e.from.line + e.text.length - 1, Z(e.text).length + (1 == e.text.length ? e.from.ch : 0)) : e.to
            }

            function Ri(e, t) {
                if (ct(e, t.from) < 0) return e;
                if (ct(e, t.to) <= 0) return Ai(t);
                var n = e.line + t.text.length - (t.to.line - t.from.line) - 1,
                    r = e.ch;
                return e.line == t.to.line && (r += Ai(t).ch - t.to.ch), lt(n, r)
            }

            function Pi(e, t) {
                for (var n = [], r = 0; r < e.sel.ranges.length; r++) {
                    var i = e.sel.ranges[r];
                    n.push(new Ei(Ri(i.anchor, t), Ri(i.head, t)))
                }
                return Ci(e.cm, n, e.sel.primIndex)
            }

            function Oi(e, t, n) {
                return e.line == t.line ? lt(n.line, e.ch - t.ch + n.ch) : lt(n.line + (e.line - t.line), e.ch)
            }

            function Ii(e) {
                e.doc.mode = Xe(e.options, e.doc.modeOption), Di(e)
            }

            function Di(e) {
                e.doc.iter(function(e) {
                    e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null)
                }), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, ai(e, 100), e.state.modeGen++, e.curOp && mr(e)
            }

            function Ni(e, t) {
                return 0 == t.from.ch && 0 == t.to.ch && "" == Z(t.text) && (!e.cm || e.cm.options.wholeLineUpdateBefore)
            }

            function ki(e, r, t, i) {
                function o(e) {
                    return t ? t[e] : null
                }

                function n(e, t, n) {
                    ! function(e, t, n, r) {
                        e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), null != e.order && (e.order = null), kt(e), zt(e, n);
                        var i = r ? r(e) : 1;
                        i != e.height && rt(e, i)
                    }(e, t, n, i), mn(e, "change", e, r)
                }

                function a(e, t) {
                    for (var n = [], r = e; r < t; ++r) n.push(new en(c[r], o(r), i));
                    return n
                }
                var s = r.from,
                    l = r.to,
                    c = r.text,
                    u = et(e, s.line),
                    h = et(e, l.line),
                    d = Z(c),
                    p = o(c.length - 1),
                    f = l.line - s.line;
                if (r.full) e.insert(0, a(0, c.length)), e.remove(c.length, e.size - c.length);
                else if (Ni(e, r)) {
                    var m = a(0, c.length - 1);
                    n(h, h.text, p), f && e.remove(s.line, f), m.length && e.insert(s.line, m)
                } else if (u == h)
                    if (1 == c.length) n(u, u.text.slice(0, s.ch) + d + u.text.slice(l.ch), p);
                    else {
                        var v = a(1, c.length - 1);
                        v.push(new en(d + u.text.slice(l.ch), p, i)), n(u, u.text.slice(0, s.ch) + c[0], o(0)), e.insert(s.line + 1, v)
                    } else if (1 == c.length) n(u, u.text.slice(0, s.ch) + c[0] + h.text.slice(l.ch), o(0)), e.remove(s.line + 1, f);
                else {
                    n(u, u.text.slice(0, s.ch) + c[0], o(0)), n(h, d + h.text.slice(l.ch), p);
                    var g = a(1, c.length - 1);
                    1 < f && e.remove(s.line + 1, f - 1), e.insert(s.line + 1, g)
                }
                mn(e, "change", e, r)
            }

            function zi(e, s, l) {
                ! function e(t, n, r) {
                    if (t.linked)
                        for (var i = 0; i < t.linked.length; ++i) {
                            var o = t.linked[i];
                            if (o.doc != n) {
                                var a = r && o.sharedHist;
                                l && !a || (s(o.doc, a), e(o.doc, t, a))
                            }
                        }
                }(e, null, !0)
            }

            function Fi(e, t) {
                if (t.cm) throw new Error("This document is already in use.");
                dr((e.doc = t).cm = e), Ii(e), Bi(e), e.options.lineWrapping || $t(e), e.options.mode = t.modeOption, mr(e)
            }

            function Bi(e) {
                ("rtl" == e.doc.direction ? I : E)(e.display.lineDiv, "CodeMirror-rtl")
            }

            function Ui(e) {
                this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e || 1
            }

            function Hi(e, t) {
                var n = {
                    from: ht(t.from),
                    to: Ai(t),
                    text: tt(e, t.from, t.to)
                };
                return qi(e, n, t.from.line, t.to.line + 1), zi(e, function(e) {
                    return qi(e, n, t.from.line, t.to.line + 1)
                }, !0), n
            }

            function Gi(e) {
                for (; e.length;) {
                    if (!Z(e).ranges) break;
                    e.pop()
                }
            }

            function Vi(e, t, n, r) {
                var i = e.history;
                i.undone.length = 0;
                var o, a, s = +new Date;
                if ((i.lastOp == r || i.lastOrigin == t.origin && t.origin && ("+" == t.origin.charAt(0) && i.lastModTime > s - (e.cm ? e.cm.options.historyEventDelay : 500) || "*" == t.origin.charAt(0))) && (o = function(e, t) {
                        return t ? (Gi(e.done), Z(e.done)) : e.done.length && !Z(e.done).ranges ? Z(e.done) : 1 < e.done.length && !e.done[e.done.length - 2].ranges ? (e.done.pop(), Z(e.done)) : void 0
                    }(i, i.lastOp == r))) a = Z(o.changes), 0 == ct(t.from, t.to) && 0 == ct(t.from, a.to) ? a.to = Ai(t) : o.changes.push(Hi(e, t));
                else {
                    var l = Z(i.done);
                    for (l && l.ranges || ji(e.sel, i.done), o = {
                            changes: [Hi(e, t)],
                            generation: i.generation
                        }, i.done.push(o); i.done.length > i.undoDepth;) i.done.shift(), i.done[0].ranges || i.done.shift()
                }
                i.done.push(n), i.generation = ++i.maxGeneration, i.lastModTime = i.lastSelTime = s, i.lastOp = i.lastSelOp = r, i.lastOrigin = i.lastSelOrigin = t.origin, a || Se(e, "historyAdded")
            }

            function Wi(e, t, n, r) {
                var i = e.history,
                    o = r && r.origin;
                n == i.lastSelOp || o && i.lastSelOrigin == o && (i.lastModTime == i.lastSelTime && i.lastOrigin == o || function(e, t, n, r) {
                    var i = t.charAt(0);
                    return "*" == i || "+" == i && n.ranges.length == r.ranges.length && n.somethingSelected() == r.somethingSelected() && new Date - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500)
                }(e, o, Z(i.done), t)) ? i.done[i.done.length - 1] = t : ji(t, i.done), i.lastSelTime = +new Date, i.lastSelOrigin = o, i.lastSelOp = n, r && !1 !== r.clearRedo && Gi(i.undone)
            }

            function ji(e, t) {
                var n = Z(t);
                n && n.ranges && n.equals(e) || t.push(e)
            }

            function qi(t, n, e, r) {
                var i = n["spans_" + t.id],
                    o = 0;
                t.iter(Math.max(t.first, e), Math.min(t.first + t.size, r), function(e) {
                    e.markedSpans && ((i = i || (n["spans_" + t.id] = {}))[o] = e.markedSpans), ++o
                })
            }

            function Xi(e) {
                if (!e) return null;
                for (var t, n = 0; n < e.length; ++n) e[n].marker.explicitlyCleared ? t = t || e.slice(0, n) : t && t.push(e[n]);
                return t ? t.length ? t : null : e
            }

            function Yi(e, t) {
                var n = function(e, t) {
                        var n = t["spans_" + e.id];
                        if (!n) return null;
                        for (var r = [], i = 0; i < t.text.length; ++i) r.push(Xi(n[i]));
                        return r
                    }(e, t),
                    r = Dt(e, t);
                if (!n) return r;
                if (!r) return n;
                for (var i = 0; i < n.length; ++i) {
                    var o = n[i],
                        a = r[i];
                    if (o && a) e: for (var s = 0; s < a.length; ++s) {
                        for (var l = a[s], c = 0; c < o.length; ++c)
                            if (o[c].marker == l.marker) continue e;
                        o.push(l)
                    } else a && (n[i] = a)
                }
                return n
            }

            function Zi(e, t, n) {
                for (var r = [], i = 0; i < e.length; ++i) {
                    var o = e[i];
                    if (o.ranges) r.push(n ? Ti.prototype.deepCopy.call(o) : o);
                    else {
                        var a = o.changes,
                            s = [];
                        r.push({
                            changes: s
                        });
                        for (var l = 0; l < a.length; ++l) {
                            var c = a[l],
                                u = void 0;
                            if (s.push({
                                    from: c.from,
                                    to: c.to,
                                    text: c.text
                                }), t)
                                for (var h in c)(u = h.match(/^spans_(\d+)$/)) && -1 < U(t, Number(u[1])) && (Z(s)[h] = c[h], delete c[h])
                        }
                    }
                }
                return r
            }

            function Ki(e, t, n, r) {
                if (r) {
                    var i = e.anchor;
                    if (n) {
                        var o = ct(t, i) < 0;
                        o != ct(n, i) < 0 ? (i = t, t = n) : o != ct(t, n) < 0 && (t = n)
                    }
                    return new Ei(i, t)
                }
                return new Ei(n || t, t)
            }

            function Ji(e, t, n, r, i) {
                null == i && (i = e.cm && (e.cm.display.shift || e.extend)), no(e, new Ti([Ki(e.sel.primary(), t, n, i)], 0), r)
            }

            function Qi(e, t, n) {
                for (var r = [], i = e.cm && (e.cm.display.shift || e.extend), o = 0; o < e.sel.ranges.length; o++) r[o] = Ki(e.sel.ranges[o], t[o], null, i);
                no(e, Ci(e.cm, r, e.sel.primIndex), n)
            }

            function $i(e, t, n, r) {
                var i = e.sel.ranges.slice(0);
                i[t] = n, no(e, Ci(e.cm, i, e.sel.primIndex), r)
            }

            function eo(e, t, n, r) {
                no(e, Li(t, n), r)
            }

            function to(e, t, n) {
                var r = e.history.done,
                    i = Z(r);
                i && i.ranges ? ro(e, r[r.length - 1] = t, n) : no(e, t, n)
            }

            function no(e, t, n) {
                ro(e, t, n), Wi(e, e.sel, e.cm ? e.cm.curOp.id : NaN, n)
            }

            function ro(e, t, n) {
                (Ee(e, "beforeSelectionChange") || e.cm && Ee(e.cm, "beforeSelectionChange")) && (t = function(n, e, t) {
                    var r = {
                        ranges: e.ranges,
                        update: function(e) {
                            this.ranges = [];
                            for (var t = 0; t < e.length; t++) this.ranges[t] = new Ei(mt(n, e[t].anchor), mt(n, e[t].head))
                        },
                        origin: t && t.origin
                    };
                    return Se(n, "beforeSelectionChange", n, r), n.cm && Se(n.cm, "beforeSelectionChange", n.cm, r), r.ranges != e.ranges ? Ci(n.cm, r.ranges, r.ranges.length - 1) : e
                }(e, t, n));
                var r = n && n.bias || (ct(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1);
                io(e, ao(e, t, r, !0)), n && !1 === n.scroll || !e.cm || Nr(e.cm)
            }

            function io(e, t) {
                t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, Te(e.cm)), mn(e, "cursorActivity", e))
            }

            function oo(e) {
                io(e, ao(e, e.sel, null, !1))
            }

            function ao(e, t, n, r) {
                for (var i, o = 0; o < t.ranges.length; o++) {
                    var a = t.ranges[o],
                        s = t.ranges.length == e.sel.ranges.length && e.sel.ranges[o],
                        l = lo(e, a.anchor, s && s.anchor, n, r),
                        c = lo(e, a.head, s && s.head, n, r);
                    !i && l == a.anchor && c == a.head || ((i = i || t.ranges.slice(0, o))[o] = new Ei(l, c))
                }
                return i ? Ci(e.cm, i, t.primIndex) : t
            }

            function so(e, t, n, r, i) {
                var o = et(e, t.line);
                if (o.markedSpans)
                    for (var a = 0; a < o.markedSpans.length; ++a) {
                        var s = o.markedSpans[a],
                            l = s.marker,
                            c = "selectLeft" in l ? !l.selectLeft : l.inclusiveLeft,
                            u = "selectRight" in l ? !l.selectRight : l.inclusiveRight;
                        if ((null == s.from || (c ? s.from <= t.ch : s.from < t.ch)) && (null == s.to || (u ? s.to >= t.ch : s.to > t.ch))) {
                            if (i && (Se(l, "beforeCursorEnter"), l.explicitlyCleared)) {
                                if (o.markedSpans) {
                                    --a;
                                    continue
                                }
                                break
                            }
                            if (!l.atomic) continue;
                            if (n) {
                                var h = l.find(r < 0 ? 1 : -1),
                                    d = void 0;
                                if ((r < 0 ? u : c) && (h = co(e, h, -r, h && h.line == t.line ? o : null)), h && h.line == t.line && (d = ct(h, n)) && (r < 0 ? d < 0 : 0 < d)) return so(e, h, t, r, i)
                            }
                            var p = l.find(r < 0 ? -1 : 1);
                            return (r < 0 ? c : u) && (p = co(e, p, r, p.line == t.line ? o : null)), p ? so(e, p, t, r, i) : null
                        }
                    }
                return t
            }

            function lo(e, t, n, r, i) {
                var o = r || 1,
                    a = so(e, t, n, o, i) || !i && so(e, t, n, o, !0) || so(e, t, n, -o, i) || !i && so(e, t, n, -o, !0);
                return a || (e.cantEdit = !0, lt(e.first, 0))
            }

            function co(e, t, n, r) {
                return n < 0 && 0 == t.ch ? t.line > e.first ? mt(e, lt(t.line - 1)) : null : 0 < n && t.ch == (r || et(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? lt(t.line + 1, 0) : null : new lt(t.line, t.ch + n)
            }

            function uo(e) {
                e.setSelection(lt(e.firstLine(), 0), lt(e.lastLine()), V)
            }

            function ho(i, e, t) {
                var o = {
                    canceled: !1,
                    from: e.from,
                    to: e.to,
                    text: e.text,
                    origin: e.origin,
                    cancel: function() {
                        return o.canceled = !0
                    }
                };
                return t && (o.update = function(e, t, n, r) {
                    e && (o.from = mt(i, e)), t && (o.to = mt(i, t)), n && (o.text = n), void 0 !== r && (o.origin = r)
                }), Se(i, "beforeChange", i, o), i.cm && Se(i.cm, "beforeChange", i.cm, o), o.canceled ? (i.cm && (i.cm.curOp.updateInput = 2), null) : {
                    from: o.from,
                    to: o.to,
                    text: o.text,
                    origin: o.origin
                }
            }

            function po(e, t, n) {
                if (e.cm) {
                    if (!e.cm.curOp) return ri(e.cm, po)(e, t, n);
                    if (e.cm.state.suppressEdits) return
                }
                if (!(Ee(e, "beforeChange") || e.cm && Ee(e.cm, "beforeChange")) || (t = ho(e, t, !0))) {
                    var r = At && !n && function(e, t, n) {
                        var r = null;
                        if (e.iter(t.line, n.line + 1, function(e) {
                                if (e.markedSpans)
                                    for (var t = 0; t < e.markedSpans.length; ++t) {
                                        var n = e.markedSpans[t].marker;
                                        !n.readOnly || r && -1 != U(r, n) || (r = r || []).push(n)
                                    }
                            }), !r) return null;
                        for (var i = [{
                                from: t,
                                to: n
                            }], o = 0; o < r.length; ++o)
                            for (var a = r[o], s = a.find(0), l = 0; l < i.length; ++l) {
                                var c = i[l];
                                if (!(ct(c.to, s.from) < 0 || 0 < ct(c.from, s.to))) {
                                    var u = [l, 1],
                                        h = ct(c.from, s.from),
                                        d = ct(c.to, s.to);
                                    (h < 0 || !a.inclusiveLeft && !h) && u.push({
                                        from: c.from,
                                        to: s.from
                                    }), (0 < d || !a.inclusiveRight && !d) && u.push({
                                        from: s.to,
                                        to: c.to
                                    }), i.splice.apply(i, u), l += u.length - 3
                                }
                            }
                        return i
                    }(e, t.from, t.to);
                    if (r)
                        for (var i = r.length - 1; 0 <= i; --i) fo(e, {
                            from: r[i].from,
                            to: r[i].to,
                            text: i ? [""] : t.text,
                            origin: t.origin
                        });
                    else fo(e, t)
                }
            }

            function fo(e, n) {
                if (1 != n.text.length || "" != n.text[0] || 0 != ct(n.from, n.to)) {
                    var t = Pi(e, n);
                    Vi(e, n, t, e.cm ? e.cm.curOp.id : NaN), go(e, n, t, Dt(e, n));
                    var r = [];
                    zi(e, function(e, t) {
                        t || -1 != U(r, e.history) || (_o(e.history, n), r.push(e.history)), go(e, n, null, Dt(e, n))
                    })
                }
            }

            function mo(i, o, e) {
                var t = i.cm && i.cm.state.suppressEdits;
                if (!t || e) {
                    for (var a, n = i.history, r = i.sel, s = "undo" == o ? n.done : n.undone, l = "undo" == o ? n.undone : n.done, c = 0; c < s.length && (a = s[c], e ? !a.ranges || a.equals(i.sel) : a.ranges); c++);
                    if (c != s.length) {
                        for (n.lastOrigin = n.lastSelOrigin = null;;) {
                            if (!(a = s.pop()).ranges) {
                                if (t) return void s.push(a);
                                break
                            }
                            if (ji(a, l), e && !a.equals(i.sel)) return void no(i, a, {
                                clearRedo: !1
                            });
                            r = a
                        }
                        var u = [];
                        ji(r, l), l.push({
                            changes: u,
                            generation: n.generation
                        }), n.generation = a.generation || ++n.maxGeneration;
                        for (var h = Ee(i, "beforeChange") || i.cm && Ee(i.cm, "beforeChange"), d = function(e) {
                                var n = a.changes[e];
                                if (n.origin = o, h && !ho(i, n, !1)) return s.length = 0, {};
                                u.push(Hi(i, n));
                                var t = e ? Pi(i, n) : Z(s);
                                go(i, n, t, Yi(i, n)), !e && i.cm && i.cm.scrollIntoView({
                                    from: n.from,
                                    to: Ai(n)
                                });
                                var r = [];
                                zi(i, function(e, t) {
                                    t || -1 != U(r, e.history) || (_o(e.history, n), r.push(e.history)), go(e, n, null, Yi(e, n))
                                })
                            }, p = a.changes.length - 1; 0 <= p; --p) {
                            var f = d(p);
                            if (f) return f.v
                        }
                    }
                }
            }

            function vo(e, t) {
                if (0 != t && (e.first += t, e.sel = new Ti(K(e.sel.ranges, function(e) {
                        return new Ei(lt(e.anchor.line + t, e.anchor.ch), lt(e.head.line + t, e.head.ch))
                    }), e.sel.primIndex), e.cm)) {
                    mr(e.cm, e.first, e.first - t, t);
                    for (var n = e.cm.display, r = n.viewFrom; r < n.viewTo; r++) vr(e.cm, r, "gutter")
                }
            }

            function go(e, t, n, r) {
                if (e.cm && !e.cm.curOp) return ri(e.cm, go)(e, t, n, r);
                if (t.to.line < e.first) vo(e, t.text.length - 1 - (t.to.line - t.from.line));
                else if (!(t.from.line > e.lastLine())) {
                    if (t.from.line < e.first) {
                        var i = t.text.length - 1 - (e.first - t.from.line);
                        vo(e, i), t = {
                            from: lt(e.first, 0),
                            to: lt(t.to.line + i, t.to.ch),
                            text: [Z(t.text)],
                            origin: t.origin
                        }
                    }
                    var o = e.lastLine();
                    t.to.line > o && (t = {
                        from: t.from,
                        to: lt(o, et(e, o).text.length),
                        text: [t.text[0]],
                        origin: t.origin
                    }), t.removed = tt(e, t.from, t.to), n = n || Pi(e, t), e.cm ? function(e, t, n) {
                        var r = e.doc,
                            i = e.display,
                            o = t.from,
                            a = t.to,
                            s = !1,
                            l = o.line;
                        e.options.lineWrapping || (l = it(qt(et(r, o.line))), r.iter(l, a.line + 1, function(e) {
                            if (e == i.maxLine) return s = !0
                        })); - 1 < r.sel.contains(t.from, t.to) && Te(e);
                        ki(r, t, n, hr(e)), e.options.lineWrapping || (r.iter(l, o.line + t.text.length, function(e) {
                            var t = Qt(e);
                            t > i.maxLineLength && (i.maxLine = e, i.maxLineLength = t, i.maxLineChanged = !0, s = !1)
                        }), s && (e.curOp.updateMaxLine = !0));
                        (function(e, t) {
                            if (e.modeFrontier = Math.min(e.modeFrontier, t), !(e.highlightFrontier < t - 10)) {
                                for (var n = e.first, r = t - 1; n < r; r--) {
                                    var i = et(e, r).stateAfter;
                                    if (i && (!(i instanceof gt) || r + i.lookAhead < t)) {
                                        n = r + 1;
                                        break
                                    }
                                }
                                e.highlightFrontier = Math.min(e.highlightFrontier, n)
                            }
                        })(r, o.line), ai(e, 400);
                        var c = t.text.length - (a.line - o.line) - 1;
                        t.full ? mr(e) : o.line != a.line || 1 != t.text.length || Ni(e.doc, t) ? mr(e, o.line, a.line + 1, c) : vr(e, o.line, "text");
                        var u = Ee(e, "changes"),
                            h = Ee(e, "change");
                        if (h || u) {
                            var d = {
                                from: o,
                                to: a,
                                text: t.text,
                                removed: t.removed,
                                origin: t.origin
                            };
                            h && mn(e, "change", e, d), u && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(d)
                        }
                        e.display.selForContextMenu = null
                    }(e.cm, t, r) : ki(e, t, r), ro(e, n, V), e.cantEdit && lo(e, lt(e.firstLine(), 0)) && (e.cantEdit = !1)
                }
            }

            function yo(e, t, n, r, i) {
                var o;
                ct(r = r || n, n) < 0 && (n = (o = [r, n])[0], r = o[1]), "string" == typeof t && (t = e.splitLines(t)), po(e, {
                    from: n,
                    to: r,
                    text: t,
                    origin: i
                })
            }

            function xo(e, t, n, r) {
                n < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0)
            }

            function bo(e, t, n, r) {
                for (var i = 0; i < e.length; ++i) {
                    var o = e[i],
                        a = !0;
                    if (o.ranges) {
                        o.copied || ((o = e[i] = o.deepCopy()).copied = !0);
                        for (var s = 0; s < o.ranges.length; s++) xo(o.ranges[s].anchor, t, n, r), xo(o.ranges[s].head, t, n, r)
                    } else {
                        for (var l = 0; l < o.changes.length; ++l) {
                            var c = o.changes[l];
                            if (n < c.from.line) c.from = lt(c.from.line + r, c.from.ch), c.to = lt(c.to.line + r, c.to.ch);
                            else if (t <= c.to.line) {
                                a = !1;
                                break
                            }
                        }
                        a || (e.splice(0, i + 1), i = 0)
                    }
                }
            }

            function _o(e, t) {
                var n = t.from.line,
                    r = t.to.line,
                    i = t.text.length - (r - n) - 1;
                bo(e.done, n, r, i), bo(e.undone, n, r, i)
            }

            function wo(e, t, n, r) {
                var i = t,
                    o = t;
                return "number" == typeof t ? o = et(e, ft(e, t)) : i = it(t), null == i ? null : (r(o, i) && e.cm && vr(e.cm, i, n), o)
            }

            function So(e) {
                this.lines = e, this.parent = null;
                for (var t = 0, n = 0; n < e.length; ++n) e[n].parent = this, t += e[n].height;
                this.height = t
            }

            function Mo(e) {
                this.children = e;
                for (var t = 0, n = 0, r = 0; r < e.length; ++r) {
                    var i = e[r];
                    t += i.chunkSize(), n += i.height, i.parent = this
                }
                this.size = t, this.height = n, this.parent = null
            }
            Ei.prototype.from = function() {
                return pt(this.anchor, this.head)
            }, Ei.prototype.to = function() {
                return dt(this.anchor, this.head)
            }, Ei.prototype.empty = function() {
                return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
            }, So.prototype = {
                chunkSize: function() {
                    return this.lines.length
                },
                removeInner: function(e, t) {
                    for (var n, r = e, i = e + t; r < i; ++r) {
                        var o = this.lines[r];
                        this.height -= o.height, (n = o).parent = null, kt(n), mn(o, "delete")
                    }
                    this.lines.splice(e, t)
                },
                collapse: function(e) {
                    e.push.apply(e, this.lines)
                },
                insertInner: function(e, t, n) {
                    this.height += n, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));
                    for (var r = 0; r < t.length; ++r) t[r].parent = this
                },
                iterN: function(e, t, n) {
                    for (var r = e + t; e < r; ++e)
                        if (n(this.lines[e])) return !0
                }
            }, Mo.prototype = {
                chunkSize: function() {
                    return this.size
                },
                removeInner: function(e, t) {
                    this.size -= t;
                    for (var n = 0; n < this.children.length; ++n) {
                        var r = this.children[n],
                            i = r.chunkSize();
                        if (e < i) {
                            var o = Math.min(t, i - e),
                                a = r.height;
                            if (r.removeInner(e, o), this.height -= a - r.height, i == o && (this.children.splice(n--, 1), r.parent = null), 0 == (t -= o)) break;
                            e = 0
                        } else e -= i
                    }
                    if (this.size - t < 25 && (1 < this.children.length || !(this.children[0] instanceof So))) {
                        var s = [];
                        this.collapse(s), this.children = [new So(s)], this.children[0].parent = this
                    }
                },
                collapse: function(e) {
                    for (var t = 0; t < this.children.length; ++t) this.children[t].collapse(e)
                },
                insertInner: function(e, t, n) {
                    this.size += t.length, this.height += n;
                    for (var r = 0; r < this.children.length; ++r) {
                        var i = this.children[r],
                            o = i.chunkSize();
                        if (e <= o) {
                            if (i.insertInner(e, t, n), i.lines && 50 < i.lines.length) {
                                for (var a = i.lines.length % 25 + 25, s = a; s < i.lines.length;) {
                                    var l = new So(i.lines.slice(s, s += 25));
                                    i.height -= l.height, this.children.splice(++r, 0, l), l.parent = this
                                }
                                i.lines = i.lines.slice(0, a), this.maybeSpill()
                            }
                            break
                        }
                        e -= o
                    }
                },
                maybeSpill: function() {
                    if (!(this.children.length <= 10)) {
                        var e = this;
                        do {
                            var t = new Mo(e.children.splice(e.children.length - 5, 5));
                            if (e.parent) {
                                e.size -= t.size, e.height -= t.height;
                                var n = U(e.parent.children, e);
                                e.parent.children.splice(n + 1, 0, t)
                            } else {
                                var r = new Mo(e.children);
                                (r.parent = e).children = [r, t], e = r
                            }
                            t.parent = e.parent
                        } while (10 < e.children.length);
                        e.parent.maybeSpill()
                    }
                },
                iterN: function(e, t, n) {
                    for (var r = 0; r < this.children.length; ++r) {
                        var i = this.children[r],
                            o = i.chunkSize();
                        if (e < o) {
                            var a = Math.min(t, o - e);
                            if (i.iterN(e, a, n)) return !0;
                            if (0 == (t -= a)) break;
                            e = 0
                        } else e -= o
                    }
                }
            };

            function To(e, t, n) {
                if (n)
                    for (var r in n) n.hasOwnProperty(r) && (this[r] = n[r]);
                this.doc = e, this.node = t
            }

            function Eo(e, t, n) {
                Jt(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && Dr(e, n)
            }
            To.prototype.clear = function() {
                var e = this.doc.cm,
                    t = this.line.widgets,
                    n = this.line,
                    r = it(n);
                if (null != r && t) {
                    for (var i = 0; i < t.length; ++i) t[i] == this && t.splice(i--, 1);
                    t.length || (n.widgets = null);
                    var o = Cn(this);
                    rt(n, Math.max(0, n.height - o)), e && (ni(e, function() {
                        Eo(e, n, -o), vr(e, r, "widget")
                    }), mn(e, "lineWidgetCleared", e, this, r))
                }
            }, To.prototype.changed = function() {
                var e = this,
                    t = this.height,
                    n = this.doc.cm,
                    r = this.line;
                this.height = null;
                var i = Cn(this) - t;
                i && (Zt(this.doc, r) || rt(r, r.height + i), n && ni(n, function() {
                    n.curOp.forceUpdate = !0, Eo(n, r, i), mn(n, "lineWidgetChanged", n, e, it(r))
                }))
            }, Ce(To);
            var Co = 0,
                Lo = function(e, t) {
                    this.lines = [], this.type = t, this.doc = e, this.id = ++Co
                };

            function Ao(t, n, r, e, i) {
                if (e && e.shared) return function(e, n, r, i, o) {
                    (i = z(i)).shared = !1;
                    var a = [Ao(e, n, r, i, o)],
                        s = a[0],
                        l = i.widgetNode;
                    return zi(e, function(e) {
                        l && (i.widgetNode = l.cloneNode(!0)), a.push(Ao(e, mt(e, n), mt(e, r), i, o));
                        for (var t = 0; t < e.linked.length; ++t)
                            if (e.linked[t].isParent) return;
                        s = Z(a)
                    }), new Ro(a, s)
                }(t, n, r, e, i);
                if (t.cm && !t.cm.curOp) return ri(t.cm, Ao)(t, n, r, e, i);
                var o = new Lo(t, i),
                    a = ct(n, r);
                if (e && z(e, o, !1), 0 < a || 0 == a && !1 !== o.clearWhenEmpty) return o;
                if (o.replacedWith && (o.collapsed = !0, o.widgetNode = A("span", [o.replacedWith], "CodeMirror-widget"), e.handleMouseEvents || o.widgetNode.setAttribute("cm-ignore-events", "true"), e.insertLeft && (o.widgetNode.insertLeft = !0)), o.collapsed) {
                    if (jt(t, n.line, n, r, o) || n.line != r.line && jt(t, r.line, n, r, o)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
                    Rt = !0
                }
                o.addToHistory && Vi(t, {
                    from: n,
                    to: r,
                    origin: "markText"
                }, t.sel, NaN);
                var s, l = n.line,
                    c = t.cm;
                if (t.iter(l, r.line + 1, function(e) {
                        c && o.collapsed && !c.options.lineWrapping && qt(e) == c.display.maxLine && (s = !0), o.collapsed && l != n.line && rt(e, 0),
                            function(e, t) {
                                e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], t.marker.attachLine(e)
                            }(e, new Pt(o, l == n.line ? n.ch : null, l == r.line ? r.ch : null)), ++l
                    }), o.collapsed && t.iter(n.line, r.line + 1, function(e) {
                        Zt(t, e) && rt(e, 0)
                    }), o.clearOnEnter && be(o, "beforeCursorEnter", function() {
                        return o.clear()
                    }), o.readOnly && (At = !0, (t.history.done.length || t.history.undone.length) && t.clearHistory()), o.collapsed && (o.id = ++Co, o.atomic = !0), c) {
                    if (s && (c.curOp.updateMaxLine = !0), o.collapsed) mr(c, n.line, r.line + 1);
                    else if (o.className || o.startStyle || o.endStyle || o.css || o.attributes || o.title)
                        for (var u = n.line; u <= r.line; u++) vr(c, u, "text");
                    o.atomic && oo(c.doc), mn(c, "markerAdded", c, o)
                }
                return o
            }
            Lo.prototype.clear = function() {
                var e = this;
                if (!this.explicitlyCleared) {
                    var t = this.doc.cm,
                        n = t && !t.curOp;
                    if (n && Kr(t), Ee(this, "clear")) {
                        var r = this.find();
                        r && mn(this, "clear", r.from, r.to)
                    }
                    for (var i = null, o = null, a = 0; a < this.lines.length; ++a) {
                        var s = e.lines[a],
                            l = Ot(s.markedSpans, e);
                        t && !e.collapsed ? vr(t, it(s), "text") : t && (null != l.to && (o = it(s)), null != l.from && (i = it(s))), s.markedSpans = It(s.markedSpans, l), null == l.from && e.collapsed && !Zt(e.doc, s) && t && rt(s, sr(t.display))
                    }
                    if (t && this.collapsed && !t.options.lineWrapping)
                        for (var c = 0; c < this.lines.length; ++c) {
                            var u = qt(e.lines[c]),
                                h = Qt(u);
                            h > t.display.maxLineLength && (t.display.maxLine = u, t.display.maxLineLength = h, t.display.maxLineChanged = !0)
                        }
                    null != i && t && this.collapsed && mr(t, i, o + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, t && oo(t.doc)), t && mn(t, "markerCleared", t, this, i, o), n && Jr(t), this.parent && this.parent.clear()
                }
            }, Lo.prototype.find = function(e, t) {
                var n, r;
                null == e && "bookmark" == this.type && (e = 1);
                for (var i = 0; i < this.lines.length; ++i) {
                    var o = this.lines[i],
                        a = Ot(o.markedSpans, this);
                    if (null != a.from && (n = lt(t ? o : it(o), a.from), -1 == e)) return n;
                    if (null != a.to && (r = lt(t ? o : it(o), a.to), 1 == e)) return r
                }
                return n && {
                    from: n,
                    to: r
                }
            }, Lo.prototype.changed = function() {
                var o = this,
                    a = this.find(-1, !0),
                    s = this,
                    l = this.doc.cm;
                a && l && ni(l, function() {
                    var e = a.line,
                        t = it(a.line),
                        n = zn(l, t);
                    if (n && (Wn(n), l.curOp.selectionChanged = l.curOp.forceUpdate = !0), l.curOp.updateMaxLine = !0, !Zt(s.doc, e) && null != s.height) {
                        var r = s.height;
                        s.height = null;
                        var i = Cn(s) - r;
                        i && rt(e, e.height + i)
                    }
                    mn(l, "markerChanged", l, o)
                })
            }, Lo.prototype.attachLine = function(e) {
                if (!this.lines.length && this.doc.cm) {
                    var t = this.doc.cm.curOp;
                    t.maybeHiddenMarkers && -1 != U(t.maybeHiddenMarkers, this) || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this)
                }
                this.lines.push(e)
            }, Lo.prototype.detachLine = function(e) {
                if (this.lines.splice(U(this.lines, e), 1), !this.lines.length && this.doc.cm) {
                    var t = this.doc.cm.curOp;
                    (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this)
                }
            }, Ce(Lo);
            var Ro = function(e, t) {
                this.markers = e, this.primary = t;
                for (var n = 0; n < e.length; ++n) e[n].parent = this
            };

            function Po(e) {
                return e.findMarks(lt(e.first, 0), e.clipPos(lt(e.lastLine())), function(e) {
                    return e.parent
                })
            }

            function Oo(o) {
                for (var e = function(e) {
                        var t = o[e],
                            n = [t.primary.doc];
                        zi(t.primary.doc, function(e) {
                            return n.push(e)
                        });
                        for (var r = 0; r < t.markers.length; r++) {
                            var i = t.markers[r]; - 1 == U(n, i.doc) && (i.parent = null, t.markers.splice(r--, 1))
                        }
                    }, t = 0; t < o.length; t++) e(t)
            }
            Ro.prototype.clear = function() {
                if (!this.explicitlyCleared) {
                    this.explicitlyCleared = !0;
                    for (var e = 0; e < this.markers.length; ++e) this.markers[e].clear();
                    mn(this, "clear")
                }
            }, Ro.prototype.find = function(e, t) {
                return this.primary.find(e, t)
            }, Ce(Ro);
            var Io = 0,
                Do = function(e, t, n, r, i) {
                    if (!(this instanceof Do)) return new Do(e, t, n, r, i);
                    null == n && (n = 0), Mo.call(this, [new So([new en("", null)])]), this.first = n, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = n;
                    var o = lt(n, 0);
                    this.sel = Li(o), this.history = new Ui(null), this.id = ++Io, this.modeOption = t, this.lineSep = r, this.direction = "rtl" == i ? "rtl" : "ltr", this.extend = !1, "string" == typeof e && (e = this.splitLines(e)), ki(this, {
                        from: o,
                        to: o,
                        text: e
                    }), no(this, Li(o), V)
                };
            Do.prototype = Q(Mo.prototype, {
                constructor: Do,
                iter: function(e, t, n) {
                    n ? this.iterN(e - this.first, t - e, n) : this.iterN(this.first, this.first + this.size, e)
                },
                insert: function(e, t) {
                    for (var n = 0, r = 0; r < t.length; ++r) n += t[r].height;
                    this.insertInner(e - this.first, t, n)
                },
                remove: function(e, t) {
                    this.removeInner(e - this.first, t)
                },
                getValue: function(e) {
                    var t = nt(this, this.first, this.first + this.size);
                    return !1 === e ? t : t.join(e || this.lineSeparator())
                },
                setValue: oi(function(e) {
                    var t = lt(this.first, 0),
                        n = this.first + this.size - 1;
                    po(this, {
                        from: t,
                        to: lt(n, et(this, n).text.length),
                        text: this.splitLines(e),
                        origin: "setValue",
                        full: !0
                    }, !0), this.cm && kr(this.cm, 0, 0), no(this, Li(t), V)
                }),
                replaceRange: function(e, t, n, r) {
                    yo(this, e, t = mt(this, t), n = n ? mt(this, n) : t, r)
                },
                getRange: function(e, t, n) {
                    var r = tt(this, mt(this, e), mt(this, t));
                    return !1 === n ? r : r.join(n || this.lineSeparator())
                },
                getLine: function(e) {
                    var t = this.getLineHandle(e);
                    return t && t.text
                },
                getLineHandle: function(e) {
                    if (at(this, e)) return et(this, e)
                },
                getLineNumber: function(e) {
                    return it(e)
                },
                getLineHandleVisualStart: function(e) {
                    return "number" == typeof e && (e = et(this, e)), qt(e)
                },
                lineCount: function() {
                    return this.size
                },
                firstLine: function() {
                    return this.first
                },
                lastLine: function() {
                    return this.first + this.size - 1
                },
                clipPos: function(e) {
                    return mt(this, e)
                },
                getCursor: function(e) {
                    var t = this.sel.primary();
                    return null == e || "head" == e ? t.head : "anchor" == e ? t.anchor : "end" == e || "to" == e || !1 === e ? t.to() : t.from()
                },
                listSelections: function() {
                    return this.sel.ranges
                },
                somethingSelected: function() {
                    return this.sel.somethingSelected()
                },
                setCursor: oi(function(e, t, n) {
                    eo(this, mt(this, "number" == typeof e ? lt(e, t || 0) : e), null, n)
                }),
                setSelection: oi(function(e, t, n) {
                    eo(this, mt(this, e), mt(this, t || e), n)
                }),
                extendSelection: oi(function(e, t, n) {
                    Ji(this, mt(this, e), t && mt(this, t), n)
                }),
                extendSelections: oi(function(e, t) {
                    Qi(this, vt(this, e), t)
                }),
                extendSelectionsBy: oi(function(e, t) {
                    Qi(this, vt(this, K(this.sel.ranges, e)), t)
                }),
                setSelections: oi(function(e, t, n) {
                    if (e.length) {
                        for (var r = [], i = 0; i < e.length; i++) r[i] = new Ei(mt(this, e[i].anchor), mt(this, e[i].head));
                        null == t && (t = Math.min(e.length - 1, this.sel.primIndex)), no(this, Ci(this.cm, r, t), n)
                    }
                }),
                addSelection: oi(function(e, t, n) {
                    var r = this.sel.ranges.slice(0);
                    r.push(new Ei(mt(this, e), mt(this, t || e))), no(this, Ci(this.cm, r, r.length - 1), n)
                }),
                getSelection: function(e) {
                    for (var t, n = this.sel.ranges, r = 0; r < n.length; r++) {
                        var i = tt(this, n[r].from(), n[r].to());
                        t = t ? t.concat(i) : i
                    }
                    return !1 === e ? t : t.join(e || this.lineSeparator())
                },
                getSelections: function(e) {
                    for (var t = [], n = this.sel.ranges, r = 0; r < n.length; r++) {
                        var i = tt(this, n[r].from(), n[r].to());
                        !1 !== e && (i = i.join(e || this.lineSeparator())), t[r] = i
                    }
                    return t
                },
                replaceSelection: function(e, t, n) {
                    for (var r = [], i = 0; i < this.sel.ranges.length; i++) r[i] = e;
                    this.replaceSelections(r, t, n || "+input")
                },
                replaceSelections: oi(function(e, t, n) {
                    for (var r = [], i = this.sel, o = 0; o < i.ranges.length; o++) {
                        var a = i.ranges[o];
                        r[o] = {
                            from: a.from(),
                            to: a.to(),
                            text: this.splitLines(e[o]),
                            origin: n
                        }
                    }
                    for (var s = t && "end" != t && function(e, t, n) {
                            for (var r = [], i = lt(e.first, 0), o = i, a = 0; a < t.length; a++) {
                                var s = t[a],
                                    l = Oi(s.from, i, o),
                                    c = Oi(Ai(s), i, o);
                                if (i = s.to, o = c, "around" == n) {
                                    var u = e.sel.ranges[a],
                                        h = ct(u.head, u.anchor) < 0;
                                    r[a] = new Ei(h ? c : l, h ? l : c)
                                } else r[a] = new Ei(l, l)
                            }
                            return new Ti(r, e.sel.primIndex)
                        }(this, r, t), l = r.length - 1; 0 <= l; l--) po(this, r[l]);
                    s ? to(this, s) : this.cm && Nr(this.cm)
                }),
                undo: oi(function() {
                    mo(this, "undo")
                }),
                redo: oi(function() {
                    mo(this, "redo")
                }),
                undoSelection: oi(function() {
                    mo(this, "undo", !0)
                }),
                redoSelection: oi(function() {
                    mo(this, "redo", !0)
                }),
                setExtending: function(e) {
                    this.extend = e
                },
                getExtending: function() {
                    return this.extend
                },
                historySize: function() {
                    for (var e = this.history, t = 0, n = 0, r = 0; r < e.done.length; r++) e.done[r].ranges || ++t;
                    for (var i = 0; i < e.undone.length; i++) e.undone[i].ranges || ++n;
                    return {
                        undo: t,
                        redo: n
                    }
                },
                clearHistory: function() {
                    this.history = new Ui(this.history.maxGeneration)
                },
                markClean: function() {
                    this.cleanGeneration = this.changeGeneration(!0)
                },
                changeGeneration: function(e) {
                    return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation
                },
                isClean: function(e) {
                    return this.history.generation == (e || this.cleanGeneration)
                },
                getHistory: function() {
                    return {
                        done: Zi(this.history.done),
                        undone: Zi(this.history.undone)
                    }
                },
                setHistory: function(e) {
                    var t = this.history = new Ui(this.history.maxGeneration);
                    t.done = Zi(e.done.slice(0), null, !0), t.undone = Zi(e.undone.slice(0), null, !0)
                },
                setGutterMarker: oi(function(e, n, r) {
                    return wo(this, e, "gutter", function(e) {
                        var t = e.gutterMarkers || (e.gutterMarkers = {});
                        return !(t[n] = r) && ne(t) && (e.gutterMarkers = null), !0
                    })
                }),
                clearGutter: oi(function(t) {
                    var n = this;
                    this.iter(function(e) {
                        e.gutterMarkers && e.gutterMarkers[t] && wo(n, e, "gutter", function() {
                            return e.gutterMarkers[t] = null, ne(e.gutterMarkers) && (e.gutterMarkers = null), !0
                        })
                    })
                }),
                lineInfo: function(e) {
                    var t;
                    if ("number" == typeof e) {
                        if (!at(this, e)) return null;
                        if (!(e = et(this, t = e))) return null
                    } else if (null == (t = it(e))) return null;
                    return {
                        line: t,
                        handle: e,
                        text: e.text,
                        gutterMarkers: e.gutterMarkers,
                        textClass: e.textClass,
                        bgClass: e.bgClass,
                        wrapClass: e.wrapClass,
                        widgets: e.widgets
                    }
                },
                addLineClass: oi(function(e, n, r) {
                    return wo(this, e, "gutter" == n ? "gutter" : "class", function(e) {
                        var t = "text" == n ? "textClass" : "background" == n ? "bgClass" : "gutter" == n ? "gutterClass" : "wrapClass";
                        if (e[t]) {
                            if (M(r).test(e[t])) return !1;
                            e[t] += " " + r
                        } else e[t] = r;
                        return !0
                    })
                }),
                removeLineClass: oi(function(e, o, a) {
                    return wo(this, e, "gutter" == o ? "gutter" : "class", function(e) {
                        var t = "text" == o ? "textClass" : "background" == o ? "bgClass" : "gutter" == o ? "gutterClass" : "wrapClass",
                            n = e[t];
                        if (!n) return !1;
                        if (null == a) e[t] = null;
                        else {
                            var r = n.match(M(a));
                            if (!r) return !1;
                            var i = r.index + r[0].length;
                            e[t] = n.slice(0, r.index) + (r.index && i != n.length ? " " : "") + n.slice(i) || null
                        }
                        return !0
                    })
                }),
                addLineWidget: oi(function(e, t, n) {
                    return function(r, e, t, n) {
                        var i = new To(r, t, n),
                            o = r.cm;
                        return o && i.noHScroll && (o.display.alignWidgets = !0), wo(r, e, "widget", function(e) {
                            var t = e.widgets || (e.widgets = []);
                            if (null == i.insertAt ? t.push(i) : t.splice(Math.min(t.length - 1, Math.max(0, i.insertAt)), 0, i), i.line = e, o && !Zt(r, e)) {
                                var n = Jt(e) < r.scrollTop;
                                rt(e, e.height + Cn(i)), n && Dr(o, i.height), o.curOp.forceUpdate = !0
                            }
                            return !0
                        }), o && mn(o, "lineWidgetAdded", o, i, "number" == typeof e ? e : it(e)), i
                    }(this, e, t, n)
                }),
                removeLineWidget: function(e) {
                    e.clear()
                },
                markText: function(e, t, n) {
                    return Ao(this, mt(this, e), mt(this, t), n, n && n.type || "range")
                },
                setBookmark: function(e, t) {
                    var n = {
                        replacedWith: t && (null == t.nodeType ? t.widget : t),
                        insertLeft: t && t.insertLeft,
                        clearWhenEmpty: !1,
                        shared: t && t.shared,
                        handleMouseEvents: t && t.handleMouseEvents
                    };
                    return Ao(this, e = mt(this, e), e, n, "bookmark")
                },
                findMarksAt: function(e) {
                    var t = [],
                        n = et(this, (e = mt(this, e)).line).markedSpans;
                    if (n)
                        for (var r = 0; r < n.length; ++r) {
                            var i = n[r];
                            (null == i.from || i.from <= e.ch) && (null == i.to || i.to >= e.ch) && t.push(i.marker.parent || i.marker)
                        }
                    return t
                },
                findMarks: function(i, o, a) {
                    i = mt(this, i), o = mt(this, o);
                    var s = [],
                        l = i.line;
                    return this.iter(i.line, o.line + 1, function(e) {
                        var t = e.markedSpans;
                        if (t)
                            for (var n = 0; n < t.length; n++) {
                                var r = t[n];
                                null != r.to && l == i.line && i.ch >= r.to || null == r.from && l != i.line || null != r.from && l == o.line && r.from >= o.ch || a && !a(r.marker) || s.push(r.marker.parent || r.marker)
                            }++l
                    }), s
                },
                getAllMarks: function() {
                    var r = [];
                    return this.iter(function(e) {
                        var t = e.markedSpans;
                        if (t)
                            for (var n = 0; n < t.length; ++n) null != t[n].from && r.push(t[n].marker)
                    }), r
                },
                posFromIndex: function(n) {
                    var r, i = this.first,
                        o = this.lineSeparator().length;
                    return this.iter(function(e) {
                        var t = e.text.length + o;
                        if (n < t) return r = n, !0;
                        n -= t, ++i
                    }), mt(this, lt(i, r))
                },
                indexFromPos: function(e) {
                    var t = (e = mt(this, e)).ch;
                    if (e.line < this.first || e.ch < 0) return 0;
                    var n = this.lineSeparator().length;
                    return this.iter(this.first, e.line, function(e) {
                        t += e.text.length + n
                    }), t
                },
                copy: function(e) {
                    var t = new Do(nt(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
                    return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t
                },
                linkedDoc: function(e) {
                    e = e || {};
                    var t = this.first,
                        n = this.first + this.size;
                    null != e.from && e.from > t && (t = e.from), null != e.to && e.to < n && (n = e.to);
                    var r = new Do(nt(this, t, n), e.mode || this.modeOption, t, this.lineSep, this.direction);
                    return e.sharedHist && (r.history = this.history), (this.linked || (this.linked = [])).push({
                            doc: r,
                            sharedHist: e.sharedHist
                        }), r.linked = [{
                            doc: this,
                            isParent: !0,
                            sharedHist: e.sharedHist
                        }],
                        function(e, t) {
                            for (var n = 0; n < t.length; n++) {
                                var r = t[n],
                                    i = r.find(),
                                    o = e.clipPos(i.from),
                                    a = e.clipPos(i.to);
                                if (ct(o, a)) {
                                    var s = Ao(e, o, a, r.primary, r.primary.type);
                                    r.markers.push(s), s.parent = r
                                }
                            }
                        }(r, Po(this)), r
                },
                unlinkDoc: function(e) {
                    if (e instanceof Ra && (e = e.doc), this.linked)
                        for (var t = 0; t < this.linked.length; ++t) {
                            if (this.linked[t].doc == e) {
                                this.linked.splice(t, 1), e.unlinkDoc(this), Oo(Po(this));
                                break
                            }
                        }
                    if (e.history == this.history) {
                        var n = [e.id];
                        zi(e, function(e) {
                            return n.push(e.id)
                        }, !0), e.history = new Ui(null), e.history.done = Zi(this.history.done, n), e.history.undone = Zi(this.history.undone, n)
                    }
                },
                iterLinkedDocs: function(e) {
                    zi(this, e)
                },
                getMode: function() {
                    return this.mode
                },
                getEditor: function() {
                    return this.cm
                },
                splitLines: function(e) {
                    return this.lineSep ? e.split(this.lineSep) : Ue(e)
                },
                lineSeparator: function() {
                    return this.lineSep || "\n"
                },
                setDirection: oi(function(e) {
                    "rtl" != e && (e = "ltr"), e != this.direction && (this.direction = e, this.iter(function(e) {
                        return e.order = null
                    }), this.cm && function(e) {
                        ni(e, function() {
                            Bi(e), mr(e)
                        })
                    }(this.cm))
                })
            }), Do.prototype.eachLine = Do.prototype.iter;
            var No = 0;

            function ko(e) {
                var i = this;
                if (zo(i), !Me(i, e) && !Ln(i.display, e)) {
                    Le(e), _ && (No = +new Date);
                    var o = pr(i, e, !0),
                        t = e.dataTransfer.files;
                    if (o && !i.isReadOnly())
                        if (t && t.length && window.FileReader && window.File)
                            for (var a = t.length, s = Array(a), l = 0, n = function(e, n) {
                                    if (!i.options.allowDropFileTypes || -1 != U(i.options.allowDropFileTypes, e.type)) {
                                        var r = new FileReader;
                                        r.onload = ri(i, function() {
                                            var e = r.result;
                                            if (/[\x00-\x08\x0e-\x1f]{2}/.test(e) && (e = ""), s[n] = e, ++l == a) {
                                                var t = {
                                                    from: o = mt(i.doc, o),
                                                    to: o,
                                                    text: i.doc.splitLines(s.join(i.doc.lineSeparator())),
                                                    origin: "paste"
                                                };
                                                po(i.doc, t), to(i.doc, Li(o, Ai(t)))
                                            }
                                        }), r.readAsText(e)
                                    }
                                }, r = 0; r < a; ++r) n(t[r], r);
                        else {
                            if (i.state.draggingText && -1 < i.doc.sel.contains(o)) return i.state.draggingText(e), void setTimeout(function() {
                                return i.display.input.focus()
                            }, 20);
                            try {
                                var c = e.dataTransfer.getData("Text");
                                if (c) {
                                    var u;
                                    if (i.state.draggingText && !i.state.draggingText.copy && (u = i.listSelections()), ro(i.doc, Li(o, o)), u)
                                        for (var h = 0; h < u.length; ++h) yo(i.doc, "", u[h].anchor, u[h].head, "drag");
                                    i.replaceSelection(c, "around", "paste"), i.display.input.focus()
                                }
                            } catch (e) {}
                        }
                }
            }

            function zo(e) {
                e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null)
            }

            function Fo(t) {
                if (document.getElementsByClassName) {
                    for (var e = document.getElementsByClassName("CodeMirror"), n = [], r = 0; r < e.length; r++) {
                        var i = e[r].CodeMirror;
                        i && n.push(i)
                    }
                    n.length && n[0].operation(function() {
                        for (var e = 0; e < n.length; e++) t(n[e])
                    })
                }
            }
            var Bo = !1;

            function Uo() {
                Bo || (function() {
                    var e;
                    be(window, "resize", function() {
                        null == e && (e = setTimeout(function() {
                            e = null, Fo(Ho)
                        }, 100))
                    }), be(window, "blur", function() {
                        return Fo(Ar)
                    })
                }(), Bo = !0)
            }

            function Ho(e) {
                var t = e.display;
                t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize()
            }
            for (var Go = {
                    3: "Pause",
                    8: "Backspace",
                    9: "Tab",
                    13: "Enter",
                    16: "Shift",
                    17: "Ctrl",
                    18: "Alt",
                    19: "Pause",
                    20: "CapsLock",
                    27: "Esc",
                    32: "Space",
                    33: "PageUp",
                    34: "PageDown",
                    35: "End",
                    36: "Home",
                    37: "Left",
                    38: "Up",
                    39: "Right",
                    40: "Down",
                    44: "PrintScrn",
                    45: "Insert",
                    46: "Delete",
                    59: ";",
                    61: "=",
                    91: "Mod",
                    92: "Mod",
                    93: "Mod",
                    106: "*",
                    107: "=",
                    109: "-",
                    110: ".",
                    111: "/",
                    145: "ScrollLock",
                    173: "-",
                    186: ";",
                    187: "=",
                    188: ",",
                    189: "-",
                    190: ".",
                    191: "/",
                    192: "`",
                    219: "[",
                    220: "\\",
                    221: "]",
                    222: "'",
                    63232: "Up",
                    63233: "Down",
                    63234: "Left",
                    63235: "Right",
                    63272: "Delete",
                    63273: "Home",
                    63275: "End",
                    63276: "PageUp",
                    63277: "PageDown",
                    63302: "Insert"
                }, Vo = 0; Vo < 10; Vo++) Go[Vo + 48] = Go[Vo + 96] = String(Vo);
            for (var Wo = 65; Wo <= 90; Wo++) Go[Wo] = String.fromCharCode(Wo);
            for (var jo = 1; jo <= 12; jo++) Go[jo + 111] = Go[jo + 63235] = "F" + jo;
            var qo = {};

            function Xo(e) {
                var t, n, r, i, o = e.split(/-(?!$)/);
                e = o[o.length - 1];
                for (var a = 0; a < o.length - 1; a++) {
                    var s = o[a];
                    if (/^(cmd|meta|m)$/i.test(s)) i = !0;
                    else if (/^a(lt)?$/i.test(s)) t = !0;
                    else if (/^(c|ctrl|control)$/i.test(s)) n = !0;
                    else {
                        if (!/^s(hift)?$/i.test(s)) throw new Error("Unrecognized modifier name: " + s);
                        r = !0
                    }
                }
                return t && (e = "Alt-" + e), n && (e = "Ctrl-" + e), i && (e = "Cmd-" + e), r && (e = "Shift-" + e), e
            }

            function Yo(e) {
                var t = {};
                for (var n in e)
                    if (e.hasOwnProperty(n)) {
                        var r = e[n];
                        if (/^(name|fallthrough|(de|at)tach)$/.test(n)) continue;
                        if ("..." == r) {
                            delete e[n];
                            continue
                        }
                        for (var i = K(n.split(" "), Xo), o = 0; o < i.length; o++) {
                            var a = void 0,
                                s = void 0;
                            a = o == i.length - 1 ? (s = i.join(" "), r) : (s = i.slice(0, o + 1).join(" "), "...");
                            var l = t[s];
                            if (l) {
                                if (l != a) throw new Error("Inconsistent bindings for " + s)
                            } else t[s] = a
                        }
                        delete e[n]
                    }
                for (var c in t) e[c] = t[c];
                return e
            }

            function Zo(e, t, n, r) {
                var i = (t = $o(t)).call ? t.call(e, r) : t[e];
                if (!1 === i) return "nothing";
                if ("..." === i) return "multi";
                if (null != i && n(i)) return "handled";
                if (t.fallthrough) {
                    if ("[object Array]" != Object.prototype.toString.call(t.fallthrough)) return Zo(e, t.fallthrough, n, r);
                    for (var o = 0; o < t.fallthrough.length; o++) {
                        var a = Zo(e, t.fallthrough[o], n, r);
                        if (a) return a
                    }
                }
            }

            function Ko(e) {
                var t = "string" == typeof e ? e : Go[e.keyCode];
                return "Ctrl" == t || "Alt" == t || "Shift" == t || "Mod" == t
            }

            function Jo(e, t, n) {
                var r = e;
                return t.altKey && "Alt" != r && (e = "Alt-" + e), (y ? t.metaKey : t.ctrlKey) && "Ctrl" != r && (e = "Ctrl-" + e), (y ? t.ctrlKey : t.metaKey) && "Cmd" != r && (e = "Cmd-" + e), !n && t.shiftKey && "Shift" != r && (e = "Shift-" + e), e
            }

            function Qo(e, t) {
                if (v && 34 == e.keyCode && e.char) return !1;
                var n = Go[e.keyCode];
                return null != n && !e.altGraphKey && (3 == e.keyCode && e.code && (n = e.code), Jo(n, e, t))
            }

            function $o(e) {
                return "string" == typeof e ? qo[e] : e
            }

            function ea(t, e) {
                for (var n = t.doc.sel.ranges, r = [], i = 0; i < n.length; i++) {
                    for (var o = e(n[i]); r.length && ct(o.from, Z(r).to) <= 0;) {
                        var a = r.pop();
                        if (ct(a.from, o.from) < 0) {
                            o.from = a.from;
                            break
                        }
                    }
                    r.push(o)
                }
                ni(t, function() {
                    for (var e = r.length - 1; 0 <= e; e--) yo(t.doc, "", r[e].from, r[e].to, "+delete");
                    Nr(t)
                })
            }

            function ta(e, t, n) {
                var r = oe(e.text, t + n, n);
                return r < 0 || r > e.text.length ? null : r
            }

            function na(e, t, n) {
                var r = ta(e, t.ch, n);
                return null == r ? null : new lt(t.line, r, n < 0 ? "after" : "before")
            }

            function ra(e, t, n, r, i) {
                if (e) {
                    var o = ye(n, t.doc.direction);
                    if (o) {
                        var a, s = i < 0 ? Z(o) : o[0],
                            l = i < 0 == (1 == s.level) ? "after" : "before";
                        if (0 < s.level || "rtl" == t.doc.direction) {
                            var c = Fn(t, n);
                            a = i < 0 ? n.text.length - 1 : 0;
                            var u = Bn(t, c, a).top;
                            a = ae(function(e) {
                                return Bn(t, c, e).top == u
                            }, i < 0 == (1 == s.level) ? s.from : s.to - 1, a), "before" == l && (a = ta(n, a, 1))
                        } else a = i < 0 ? s.to : s.from;
                        return new lt(r, a, l)
                    }
                }
                return new lt(r, i < 0 ? n.text.length : 0, i < 0 ? "before" : "after")
            }
            qo.basic = {
                Left: "goCharLeft",
                Right: "goCharRight",
                Up: "goLineUp",
                Down: "goLineDown",
                End: "goLineEnd",
                Home: "goLineStartSmart",
                PageUp: "goPageUp",
                PageDown: "goPageDown",
                Delete: "delCharAfter",
                Backspace: "delCharBefore",
                "Shift-Backspace": "delCharBefore",
                Tab: "defaultTab",
                "Shift-Tab": "indentAuto",
                Enter: "newlineAndIndent",
                Insert: "toggleOverwrite",
                Esc: "singleSelection"
            }, qo.pcDefault = {
                "Ctrl-A": "selectAll",
                "Ctrl-D": "deleteLine",
                "Ctrl-Z": "undo",
                "Shift-Ctrl-Z": "redo",
                "Ctrl-Y": "redo",
                "Ctrl-Home": "goDocStart",
                "Ctrl-End": "goDocEnd",
                "Ctrl-Up": "goLineUp",
                "Ctrl-Down": "goLineDown",
                "Ctrl-Left": "goGroupLeft",
                "Ctrl-Right": "goGroupRight",
                "Alt-Left": "goLineStart",
                "Alt-Right": "goLineEnd",
                "Ctrl-Backspace": "delGroupBefore",
                "Ctrl-Delete": "delGroupAfter",
                "Ctrl-S": "save",
                "Ctrl-F": "find",
                "Ctrl-G": "findNext",
                "Shift-Ctrl-G": "findPrev",
                "Shift-Ctrl-F": "replace",
                "Shift-Ctrl-R": "replaceAll",
                "Ctrl-[": "indentLess",
                "Ctrl-]": "indentMore",
                "Ctrl-U": "undoSelection",
                "Shift-Ctrl-U": "redoSelection",
                "Alt-U": "redoSelection",
                fallthrough: "basic"
            }, qo.emacsy = {
                "Ctrl-F": "goCharRight",
                "Ctrl-B": "goCharLeft",
                "Ctrl-P": "goLineUp",
                "Ctrl-N": "goLineDown",
                "Alt-F": "goWordRight",
                "Alt-B": "goWordLeft",
                "Ctrl-A": "goLineStart",
                "Ctrl-E": "goLineEnd",
                "Ctrl-V": "goPageDown",
                "Shift-Ctrl-V": "goPageUp",
                "Ctrl-D": "delCharAfter",
                "Ctrl-H": "delCharBefore",
                "Alt-D": "delWordAfter",
                "Alt-Backspace": "delWordBefore",
                "Ctrl-K": "killLine",
                "Ctrl-T": "transposeChars",
                "Ctrl-O": "openLine"
            }, qo.macDefault = {
                "Cmd-A": "selectAll",
                "Cmd-D": "deleteLine",
                "Cmd-Z": "undo",
                "Shift-Cmd-Z": "redo",
                "Cmd-Y": "redo",
                "Cmd-Home": "goDocStart",
                "Cmd-Up": "goDocStart",
                "Cmd-End": "goDocEnd",
                "Cmd-Down": "goDocEnd",
                "Alt-Left": "goGroupLeft",
                "Alt-Right": "goGroupRight",
                "Cmd-Left": "goLineLeft",
                "Cmd-Right": "goLineRight",
                "Alt-Backspace": "delGroupBefore",
                "Ctrl-Alt-Backspace": "delGroupAfter",
                "Alt-Delete": "delGroupAfter",
                "Cmd-S": "save",
                "Cmd-F": "find",
                "Cmd-G": "findNext",
                "Shift-Cmd-G": "findPrev",
                "Cmd-Alt-F": "replace",
                "Shift-Cmd-Alt-F": "replaceAll",
                "Cmd-[": "indentLess",
                "Cmd-]": "indentMore",
                "Cmd-Backspace": "delWrappedLineLeft",
                "Cmd-Delete": "delWrappedLineRight",
                "Cmd-U": "undoSelection",
                "Shift-Cmd-U": "redoSelection",
                "Ctrl-Up": "goDocStart",
                "Ctrl-Down": "goDocEnd",
                fallthrough: ["basic", "emacsy"]
            }, qo.default = b ? qo.macDefault : qo.pcDefault;
            var ia = {
                selectAll: uo,
                singleSelection: function(e) {
                    return e.setSelection(e.getCursor("anchor"), e.getCursor("head"), V)
                },
                killLine: function(n) {
                    return ea(n, function(e) {
                        if (e.empty()) {
                            var t = et(n.doc, e.head.line).text.length;
                            return e.head.ch == t && e.head.line < n.lastLine() ? {
                                from: e.head,
                                to: lt(e.head.line + 1, 0)
                            } : {
                                from: e.head,
                                to: lt(e.head.line, t)
                            }
                        }
                        return {
                            from: e.from(),
                            to: e.to()
                        }
                    })
                },
                deleteLine: function(t) {
                    return ea(t, function(e) {
                        return {
                            from: lt(e.from().line, 0),
                            to: mt(t.doc, lt(e.to().line + 1, 0))
                        }
                    })
                },
                delLineLeft: function(e) {
                    return ea(e, function(e) {
                        return {
                            from: lt(e.from().line, 0),
                            to: e.from()
                        }
                    })
                },
                delWrappedLineLeft: function(n) {
                    return ea(n, function(e) {
                        var t = n.charCoords(e.head, "div").top + 5;
                        return {
                            from: n.coordsChar({
                                left: 0,
                                top: t
                            }, "div"),
                            to: e.from()
                        }
                    })
                },
                delWrappedLineRight: function(r) {
                    return ea(r, function(e) {
                        var t = r.charCoords(e.head, "div").top + 5,
                            n = r.coordsChar({
                                left: r.display.lineDiv.offsetWidth + 100,
                                top: t
                            }, "div");
                        return {
                            from: e.from(),
                            to: n
                        }
                    })
                },
                undo: function(e) {
                    return e.undo()
                },
                redo: function(e) {
                    return e.redo()
                },
                undoSelection: function(e) {
                    return e.undoSelection()
                },
                redoSelection: function(e) {
                    return e.redoSelection()
                },
                goDocStart: function(e) {
                    return e.extendSelection(lt(e.firstLine(), 0))
                },
                goDocEnd: function(e) {
                    return e.extendSelection(lt(e.lastLine()))
                },
                goLineStart: function(t) {
                    return t.extendSelectionsBy(function(e) {
                        return oa(t, e.head.line)
                    }, {
                        origin: "+move",
                        bias: 1
                    })
                },
                goLineStartSmart: function(t) {
                    return t.extendSelectionsBy(function(e) {
                        return aa(t, e.head)
                    }, {
                        origin: "+move",
                        bias: 1
                    })
                },
                goLineEnd: function(t) {
                    return t.extendSelectionsBy(function(e) {
                        return function(e, t) {
                            var n = et(e.doc, t),
                                r = function(e) {
                                    for (var t; t = Vt(e);) e = t.find(1, !0).line;
                                    return e
                                }(n);
                            r != n && (t = it(r));
                            return ra(!0, e, n, t, -1)
                        }(t, e.head.line)
                    }, {
                        origin: "+move",
                        bias: -1
                    })
                },
                goLineRight: function(n) {
                    return n.extendSelectionsBy(function(e) {
                        var t = n.cursorCoords(e.head, "div").top + 5;
                        return n.coordsChar({
                            left: n.display.lineDiv.offsetWidth + 100,
                            top: t
                        }, "div")
                    }, j)
                },
                goLineLeft: function(n) {
                    return n.extendSelectionsBy(function(e) {
                        var t = n.cursorCoords(e.head, "div").top + 5;
                        return n.coordsChar({
                            left: 0,
                            top: t
                        }, "div")
                    }, j)
                },
                goLineLeftSmart: function(r) {
                    return r.extendSelectionsBy(function(e) {
                        var t = r.cursorCoords(e.head, "div").top + 5,
                            n = r.coordsChar({
                                left: 0,
                                top: t
                            }, "div");
                        return n.ch < r.getLine(n.line).search(/\S/) ? aa(r, e.head) : n
                    }, j)
                },
                goLineUp: function(e) {
                    return e.moveV(-1, "line")
                },
                goLineDown: function(e) {
                    return e.moveV(1, "line")
                },
                goPageUp: function(e) {
                    return e.moveV(-1, "page")
                },
                goPageDown: function(e) {
                    return e.moveV(1, "page")
                },
                goCharLeft: function(e) {
                    return e.moveH(-1, "char")
                },
                goCharRight: function(e) {
                    return e.moveH(1, "char")
                },
                goColumnLeft: function(e) {
                    return e.moveH(-1, "column")
                },
                goColumnRight: function(e) {
                    return e.moveH(1, "column")
                },
                goWordLeft: function(e) {
                    return e.moveH(-1, "word")
                },
                goGroupRight: function(e) {
                    return e.moveH(1, "group")
                },
                goGroupLeft: function(e) {
                    return e.moveH(-1, "group")
                },
                goWordRight: function(e) {
                    return e.moveH(1, "word")
                },
                delCharBefore: function(e) {
                    return e.deleteH(-1, "char")
                },
                delCharAfter: function(e) {
                    return e.deleteH(1, "char")
                },
                delWordBefore: function(e) {
                    return e.deleteH(-1, "word")
                },
                delWordAfter: function(e) {
                    return e.deleteH(1, "word")
                },
                delGroupBefore: function(e) {
                    return e.deleteH(-1, "group")
                },
                delGroupAfter: function(e) {
                    return e.deleteH(1, "group")
                },
                indentAuto: function(e) {
                    return e.indentSelection("smart")
                },
                indentMore: function(e) {
                    return e.indentSelection("add")
                },
                indentLess: function(e) {
                    return e.indentSelection("subtract")
                },
                insertTab: function(e) {
                    return e.replaceSelection("\t")
                },
                insertSoftTab: function(e) {
                    for (var t = [], n = e.listSelections(), r = e.options.tabSize, i = 0; i < n.length; i++) {
                        var o = n[i].from(),
                            a = F(e.getLine(o.line), o.ch, r);
                        t.push(Y(r - a % r))
                    }
                    e.replaceSelections(t)
                },
                defaultTab: function(e) {
                    e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab")
                },
                transposeChars: function(a) {
                    return ni(a, function() {
                        for (var e = a.listSelections(), t = [], n = 0; n < e.length; n++)
                            if (e[n].empty()) {
                                var r = e[n].head,
                                    i = et(a.doc, r.line).text;
                                if (i)
                                    if (r.ch == i.length && (r = new lt(r.line, r.ch - 1)), 0 < r.ch) r = new lt(r.line, r.ch + 1), a.replaceRange(i.charAt(r.ch - 1) + i.charAt(r.ch - 2), lt(r.line, r.ch - 2), r, "+transpose");
                                    else if (r.line > a.doc.first) {
                                    var o = et(a.doc, r.line - 1).text;
                                    o && (r = new lt(r.line, 1), a.replaceRange(i.charAt(0) + a.doc.lineSeparator() + o.charAt(o.length - 1), lt(r.line - 1, o.length - 1), r, "+transpose"))
                                }
                                t.push(new Ei(r, r))
                            }
                        a.setSelections(t)
                    })
                },
                newlineAndIndent: function(r) {
                    return ni(r, function() {
                        for (var e = r.listSelections(), t = e.length - 1; 0 <= t; t--) r.replaceRange(r.doc.lineSeparator(), e[t].anchor, e[t].head, "+input");
                        e = r.listSelections();
                        for (var n = 0; n < e.length; n++) r.indentLine(e[n].from().line, null, !0);
                        Nr(r)
                    })
                },
                openLine: function(e) {
                    return e.replaceSelection("\n", "start")
                },
                toggleOverwrite: function(e) {
                    return e.toggleOverwrite()
                }
            };

            function oa(e, t) {
                var n = et(e.doc, t),
                    r = qt(n);
                return r != n && (t = it(r)), ra(!0, e, r, t, 1)
            }

            function aa(e, t) {
                var n = oa(e, t.line),
                    r = et(e.doc, n.line),
                    i = ye(r, e.doc.direction);
                if (i && 0 != i[0].level) return n;
                var o = Math.max(0, r.text.search(/\S/)),
                    a = t.line == n.line && t.ch <= o && t.ch;
                return lt(n.line, a ? 0 : o, n.sticky)
            }

            function sa(e, t, n) {
                if ("string" == typeof t && !(t = ia[t])) return !1;
                e.display.input.ensurePolled();
                var r = e.display.shift,
                    i = !1;
                try {
                    e.isReadOnly() && (e.state.suppressEdits = !0), n && (e.display.shift = !1), i = t(e) != G
                } finally {
                    e.display.shift = r, e.state.suppressEdits = !1
                }
                return i
            }
            var la = new B;

            function ca(e, t, n, r) {
                var i = e.state.keySeq;
                if (i) {
                    if (Ko(t)) return "handled";
                    if (/\'$/.test(t) ? e.state.keySeq = null : la.set(50, function() {
                            e.state.keySeq == i && (e.state.keySeq = null, e.display.input.reset())
                        }), ua(e, i + " " + t, n, r)) return !0
                }
                return ua(e, t, n, r)
            }

            function ua(e, t, n, r) {
                var i = function(e, t, n) {
                    for (var r = 0; r < e.state.keyMaps.length; r++) {
                        var i = Zo(t, e.state.keyMaps[r], n, e);
                        if (i) return i
                    }
                    return e.options.extraKeys && Zo(t, e.options.extraKeys, n, e) || Zo(t, e.options.keyMap, n, e)
                }(e, t, r);
                return "multi" == i && (e.state.keySeq = t), "handled" == i && mn(e, "keyHandled", e, t, n), "handled" != i && "multi" != i || (Le(n), Tr(e)), !!i
            }

            function ha(t, e) {
                var n = Qo(e, !0);
                return !!n && (e.shiftKey && !t.state.keySeq ? ca(t, "Shift-" + n, e, function(e) {
                    return sa(t, e, !0)
                }) || ca(t, n, e, function(e) {
                    if ("string" == typeof e ? /^go[A-Z]/.test(e) : e.motion) return sa(t, e)
                }) : ca(t, n, e, function(e) {
                    return sa(t, e)
                }))
            }
            var da = null;

            function pa(e) {
                var t = this;
                if (t.curOp.focus = O(), !Me(t, e)) {
                    _ && w < 11 && 27 == e.keyCode && (e.returnValue = !1);
                    var n = e.keyCode;
                    t.display.shift = 16 == n || e.shiftKey;
                    var r = ha(t, e);
                    v && (da = r ? n : null, !r && 88 == n && !Ge && (b ? e.metaKey : e.ctrlKey) && t.replaceSelection("", null, "cut")), 18 != n || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || function(e) {
                        var t = e.display.lineDiv;

                        function n(e) {
                            18 != e.keyCode && e.altKey || (E(t, "CodeMirror-crosshair"), we(document, "keyup", n), we(document, "mouseover", n))
                        }
                        I(t, "CodeMirror-crosshair"), be(document, "keyup", n), be(document, "mouseover", n)
                    }(t)
                }
            }

            function fa(e) {
                16 == e.keyCode && (this.doc.sel.shift = !1), Me(this, e)
            }

            function ma(e) {
                var t = this;
                if (!(Ln(t.display, e) || Me(t, e) || e.ctrlKey && !e.altKey || b && e.metaKey)) {
                    var n = e.keyCode,
                        r = e.charCode;
                    if (v && n == da) return da = null, void Le(e);
                    if (!v || e.which && !(e.which < 10) || !ha(t, e)) {
                        var i = String.fromCharCode(null == r ? n : r);
                        "\b" == i || function(t, e, n) {
                            return ca(t, "'" + n + "'", e, function(e) {
                                return sa(t, e, !0)
                            })
                        }(t, e, i) || t.display.input.onKeyPress(e)
                    }
                }
            }
            var va, ga, ya = function(e, t, n) {
                this.time = e, this.pos = t, this.button = n
            };

            function xa(e) {
                var t = this,
                    n = t.display;
                if (!(Me(t, e) || n.activeTouch && n.input.supportsTouch()))
                    if (n.input.ensurePolled(), n.shift = e.shiftKey, Ln(n, e)) x || (n.scroller.draggable = !1, setTimeout(function() {
                        return n.scroller.draggable = !0
                    }, 100));
                    else if (!wa(t, e)) {
                    var r = pr(t, e),
                        i = Ie(e),
                        o = r ? function(e, t) {
                            var n = +new Date;
                            return ga && ga.compare(n, e, t) ? (va = ga = null, "triple") : va && va.compare(n, e, t) ? (ga = new ya(n, e, t), va = null, "double") : (va = new ya(n, e, t), ga = null, "single")
                        }(r, i) : "single";
                    window.focus(), 1 == i && t.state.selectingText && t.state.selectingText(e), r && function(n, e, r, t, i) {
                        var o = "Click";
                        "double" == t ? o = "Double" + o : "triple" == t && (o = "Triple" + o);
                        return ca(n, Jo(o = (1 == e ? "Left" : 2 == e ? "Middle" : "Right") + o, i), i, function(e) {
                            if ("string" == typeof e && (e = ia[e]), !e) return !1;
                            var t = !1;
                            try {
                                n.isReadOnly() && (n.state.suppressEdits = !0), t = e(n, r) != G
                            } finally {
                                n.state.suppressEdits = !1
                            }
                            return t
                        })
                    }(t, i, r, o, e) || (1 == i ? r ? function(e, t, n, r) {
                        _ ? setTimeout(k(Er, e), 0) : e.curOp.focus = O();
                        var i, o = function(e, t, n) {
                                var r = e.getOption("configureMouse"),
                                    i = r ? r(e, t, n) : {};
                                if (null == i.unit) {
                                    var o = p ? n.shiftKey && n.metaKey : n.altKey;
                                    i.unit = o ? "rectangle" : "single" == t ? "char" : "double" == t ? "word" : "line"
                                }
                                null != i.extend && !e.doc.extend || (i.extend = e.doc.extend || n.shiftKey);
                                null == i.addNew && (i.addNew = b ? n.metaKey : n.ctrlKey);
                                null == i.moveOnDrag && (i.moveOnDrag = !(b ? n.altKey : n.ctrlKey));
                                return i
                            }(e, n, r),
                            a = e.doc.sel;
                        e.options.dragDrop && ke && !e.isReadOnly() && "single" == n && -1 < (i = a.contains(t)) && (ct((i = a.ranges[i]).from(), t) < 0 || 0 < t.xRel) && (0 < ct(i.to(), t) || t.xRel < 0) ? function(t, n, r, i) {
                            var o = t.display,
                                a = !1,
                                s = ri(t, function(e) {
                                    x && (o.scroller.draggable = !1), t.state.draggingText = !1, we(o.wrapper.ownerDocument, "mouseup", s), we(o.wrapper.ownerDocument, "mousemove", l), we(o.scroller, "dragstart", c), we(o.scroller, "drop", s), a || (Le(e), i.addNew || Ji(t.doc, r, null, null, i.extend), x || _ && 9 == w ? setTimeout(function() {
                                        o.wrapper.ownerDocument.body.focus(), o.input.focus()
                                    }, 20) : o.input.focus())
                                }),
                                l = function(e) {
                                    a = a || 10 <= Math.abs(n.clientX - e.clientX) + Math.abs(n.clientY - e.clientY)
                                },
                                c = function() {
                                    return a = !0
                                };
                            x && (o.scroller.draggable = !0);
                            (t.state.draggingText = s).copy = !i.moveOnDrag, o.scroller.dragDrop && o.scroller.dragDrop();
                            be(o.wrapper.ownerDocument, "mouseup", s), be(o.wrapper.ownerDocument, "mousemove", l), be(o.scroller, "dragstart", c), be(o.scroller, "drop", s), Cr(t), setTimeout(function() {
                                return o.input.focus()
                            }, 20)
                        }(e, r, t, o) : function(v, e, g, y) {
                            var a = v.display,
                                x = v.doc;
                            Le(e);
                            var b, _, w = x.sel,
                                t = w.ranges;
                            y.addNew && !y.extend ? (_ = x.sel.contains(g), b = -1 < _ ? t[_] : new Ei(g, g)) : (b = x.sel.primary(), _ = x.sel.primIndex);
                            if ("rectangle" == y.unit) y.addNew || (b = new Ei(g, g)), g = pr(v, e, !0, !0), _ = -1;
                            else {
                                var n = ba(v, g, y.unit);
                                b = y.extend ? Ki(b, n.anchor, n.head, y.extend) : n
                            }
                            y.addNew ? -1 == _ ? (_ = t.length, no(x, Ci(v, t.concat([b]), _), {
                                scroll: !1,
                                origin: "*mouse"
                            })) : 1 < t.length && t[_].empty() && "char" == y.unit && !y.extend ? (no(x, Ci(v, t.slice(0, _).concat(t.slice(_ + 1)), 0), {
                                scroll: !1,
                                origin: "*mouse"
                            }), w = x.sel) : $i(x, _, b, W) : (no(x, new Ti([b], _ = 0), W), w = x.sel);
                            var S = g;

                            function s(e) {
                                if (0 != ct(S, e))
                                    if (S = e, "rectangle" == y.unit) {
                                        for (var t = [], n = v.options.tabSize, r = F(et(x, g.line).text, g.ch, n), i = F(et(x, e.line).text, e.ch, n), o = Math.min(r, i), a = Math.max(r, i), s = Math.min(g.line, e.line), l = Math.min(v.lastLine(), Math.max(g.line, e.line)); s <= l; s++) {
                                            var c = et(x, s).text,
                                                u = q(c, o, n);
                                            o == a ? t.push(new Ei(lt(s, u), lt(s, u))) : c.length > u && t.push(new Ei(lt(s, u), lt(s, q(c, a, n))))
                                        }
                                        t.length || t.push(new Ei(g, g)), no(x, Ci(v, w.ranges.slice(0, _).concat(t), _), {
                                            origin: "*mouse",
                                            scroll: !1
                                        }), v.scrollIntoView(e)
                                    } else {
                                        var h, d = b,
                                            p = ba(v, e, y.unit),
                                            f = d.anchor;
                                        f = 0 < ct(p.anchor, f) ? (h = p.head, pt(d.from(), p.anchor)) : (h = p.anchor, dt(d.to(), p.head));
                                        var m = w.ranges.slice(0);
                                        m[_] = function(e, t) {
                                            var n = t.anchor,
                                                r = t.head,
                                                i = et(e.doc, n.line);
                                            if (0 == ct(n, r) && n.sticky == r.sticky) return t;
                                            var o = ye(i);
                                            if (!o) return t;
                                            var a = le(o, n.ch, n.sticky),
                                                s = o[a];
                                            if (s.from != n.ch && s.to != n.ch) return t;
                                            var l, c = a + (s.from == n.ch == (1 != s.level) ? 0 : 1);
                                            if (0 == c || c == o.length) return t;
                                            if (r.line != n.line) l = 0 < (r.line - n.line) * ("ltr" == e.doc.direction ? 1 : -1);
                                            else {
                                                var u = le(o, r.ch, r.sticky),
                                                    h = u - a || (r.ch - n.ch) * (1 == s.level ? -1 : 1);
                                                l = u == c - 1 || u == c ? h < 0 : 0 < h
                                            }
                                            var d = o[c + (l ? -1 : 0)],
                                                p = l == (1 == d.level),
                                                f = p ? d.from : d.to,
                                                m = p ? "after" : "before";
                                            return n.ch == f && n.sticky == m ? t : new Ei(new lt(n.line, f, m), r)
                                        }(v, new Ei(mt(x, f), h)), no(x, Ci(v, m, _), W)
                                    }
                            }
                            var l = a.wrapper.getBoundingClientRect(),
                                c = 0;

                            function r(e) {
                                v.state.selectingText = !1, c = 1 / 0, e && (Le(e), a.input.focus()), we(a.wrapper.ownerDocument, "mousemove", i), we(a.wrapper.ownerDocument, "mouseup", o), x.history.lastSelOrigin = null
                            }
                            var i = ri(v, function(e) {
                                    0 !== e.buttons && Ie(e) ? function e(t) {
                                        var n = ++c,
                                            r = pr(v, t, !0, "rectangle" == y.unit);
                                        if (r)
                                            if (0 != ct(r, S)) {
                                                v.curOp.focus = O(), s(r);
                                                var i = Or(a, x);
                                                (r.line >= i.to || r.line < i.from) && setTimeout(ri(v, function() {
                                                    c == n && e(t)
                                                }), 150)
                                            } else {
                                                var o = t.clientY < l.top ? -20 : t.clientY > l.bottom ? 20 : 0;
                                                o && setTimeout(ri(v, function() {
                                                    c == n && (a.scroller.scrollTop += o, e(t))
                                                }), 50)
                                            }
                                    }(e) : r(e)
                                }),
                                o = ri(v, r);
                            v.state.selectingText = o, be(a.wrapper.ownerDocument, "mousemove", i), be(a.wrapper.ownerDocument, "mouseup", o)
                        }(e, r, t, o)
                    }(t, r, o, e) : Oe(e) == n.scroller && Le(e) : 2 == i ? (r && Ji(t.doc, r), setTimeout(function() {
                        return n.input.focus()
                    }, 20)) : 3 == i && (S ? t.display.input.onContextMenu(e) : Cr(t)))
                }
            }

            function ba(e, t, n) {
                if ("char" == n) return new Ei(t, t);
                if ("word" == n) return e.findWordAt(t);
                if ("line" == n) return new Ei(lt(t.line, 0), mt(e.doc, lt(t.line + 1, 0)));
                var r = n(e, t);
                return new Ei(r.from, r.to)
            }

            function _a(e, t, n, r) {
                var i, o;
                if (t.touches) i = t.touches[0].clientX, o = t.touches[0].clientY;
                else try {
                    i = t.clientX, o = t.clientY
                } catch (t) {
                    return !1
                }
                if (i >= Math.floor(e.display.gutters.getBoundingClientRect().right)) return !1;
                r && Le(t);
                var a = e.display,
                    s = a.lineDiv.getBoundingClientRect();
                if (o > s.bottom || !Ee(e, n)) return Re(t);
                o -= s.top - a.viewOffset;
                for (var l = 0; l < e.display.gutterSpecs.length; ++l) {
                    var c = a.gutters.childNodes[l];
                    if (c && c.getBoundingClientRect().right >= i) return Se(e, n, e, ot(e.doc, o), e.display.gutterSpecs[l].className, t), Re(t)
                }
            }

            function wa(e, t) {
                return _a(e, t, "gutterClick", !0)
            }

            function Sa(e, t) {
                Ln(e.display, t) || function(e, t) {
                    return !!Ee(e, "gutterContextMenu") && _a(e, t, "gutterContextMenu", !1)
                }(e, t) || Me(e, t, "contextmenu") || S || e.display.input.onContextMenu(t)
            }

            function Ma(e) {
                e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), qn(e)
            }
            ya.prototype.compare = function(e, t, n) {
                return this.time + 400 > e && 0 == ct(t, this.pos) && n == this.button
            };
            var Ta = {
                    toString: function() {
                        return "CodeMirror.Init"
                    }
                },
                Ea = {},
                Ca = {};

            function La(e, t, n) {
                if (!t != !(n && n != Ta)) {
                    var r = e.display.dragFunctions,
                        i = t ? be : we;
                    i(e.display.scroller, "dragstart", r.start), i(e.display.scroller, "dragenter", r.enter), i(e.display.scroller, "dragover", r.over), i(e.display.scroller, "dragleave", r.leave), i(e.display.scroller, "drop", r.drop)
                }
            }

            function Aa(e) {
                e.options.lineWrapping ? (I(e.display.wrapper, "CodeMirror-wrap"), e.display.sizer.style.minWidth = "", e.display.sizerWidth = null) : (E(e.display.wrapper, "CodeMirror-wrap"), $t(e)), dr(e), mr(e), qn(e), setTimeout(function() {
                    return jr(e)
                }, 100)
            }

            function Ra(e, t) {
                var n = this;
                if (!(this instanceof Ra)) return new Ra(e, t);
                this.options = t = t ? z(t) : {}, z(Ea, t, !1);
                var r = t.value;
                "string" == typeof r ? r = new Do(r, t.mode, null, t.lineSeparator, t.direction) : t.mode && (r.modeOption = t.mode), this.doc = r;
                var i = new Ra.inputStyles[t.inputStyle](this),
                    o = this.display = new xi(e, r, i, t);
                for (var a in Ma(o.wrapper.CodeMirror = this), t.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), Yr(this), this.state = {
                            keyMaps: [],
                            overlays: [],
                            modeGen: 0,
                            overwrite: !1,
                            delayingBlurEvent: !1,
                            focused: !1,
                            suppressEdits: !1,
                            pasteIncoming: -1,
                            cutIncoming: -1,
                            selectingText: !1,
                            draggingText: !1,
                            highlight: new B,
                            keySeq: null,
                            specialChars: null
                        }, t.autofocus && !d && o.input.focus(), _ && w < 11 && setTimeout(function() {
                            return n.display.input.reset(!0)
                        }, 20),
                        function(i) {
                            var o = i.display;
                            be(o.scroller, "mousedown", ri(i, xa)), be(o.scroller, "dblclick", _ && w < 11 ? ri(i, function(e) {
                                if (!Me(i, e)) {
                                    var t = pr(i, e);
                                    if (t && !wa(i, e) && !Ln(i.display, e)) {
                                        Le(e);
                                        var n = i.findWordAt(t);
                                        Ji(i.doc, n.anchor, n.head)
                                    }
                                }
                            }) : function(e) {
                                return Me(i, e) || Le(e)
                            });
                            be(o.scroller, "contextmenu", function(e) {
                                return Sa(i, e)
                            });
                            var n, r = {
                                end: 0
                            };

                            function a() {
                                o.activeTouch && (n = setTimeout(function() {
                                    return o.activeTouch = null
                                }, 1e3), (r = o.activeTouch).end = +new Date)
                            }

                            function s(e, t) {
                                if (null == t.left) return !0;
                                var n = t.left - e.left,
                                    r = t.top - e.top;
                                return 400 < n * n + r * r
                            }
                            be(o.scroller, "touchstart", function(e) {
                                if (!Me(i, e) && ! function(e) {
                                        if (1 != e.touches.length) return !1;
                                        var t = e.touches[0];
                                        return t.radiusX <= 1 && t.radiusY <= 1
                                    }(e) && !wa(i, e)) {
                                    o.input.ensurePolled(), clearTimeout(n);
                                    var t = +new Date;
                                    o.activeTouch = {
                                        start: t,
                                        moved: !1,
                                        prev: t - r.end <= 300 ? r : null
                                    }, 1 == e.touches.length && (o.activeTouch.left = e.touches[0].pageX, o.activeTouch.top = e.touches[0].pageY)
                                }
                            }), be(o.scroller, "touchmove", function() {
                                o.activeTouch && (o.activeTouch.moved = !0)
                            }), be(o.scroller, "touchend", function(e) {
                                var t = o.activeTouch;
                                if (t && !Ln(o, e) && null != t.left && !t.moved && new Date - t.start < 300) {
                                    var n, r = i.coordsChar(o.activeTouch, "page");
                                    n = !t.prev || s(t, t.prev) ? new Ei(r, r) : !t.prev.prev || s(t, t.prev.prev) ? i.findWordAt(r) : new Ei(lt(r.line, 0), mt(i.doc, lt(r.line + 1, 0))), i.setSelection(n.anchor, n.head), i.focus(), Le(e)
                                }
                                a()
                            }), be(o.scroller, "touchcancel", a), be(o.scroller, "scroll", function() {
                                o.scroller.clientHeight && (Br(i, o.scroller.scrollTop), Hr(i, o.scroller.scrollLeft, !0), Se(i, "scroll", i))
                            }), be(o.scroller, "mousewheel", function(e) {
                                return Mi(i, e)
                            }), be(o.scroller, "DOMMouseScroll", function(e) {
                                return Mi(i, e)
                            }), be(o.wrapper, "scroll", function() {
                                return o.wrapper.scrollTop = o.wrapper.scrollLeft = 0
                            }), o.dragFunctions = {
                                enter: function(e) {
                                    Me(i, e) || Pe(e)
                                },
                                over: function(e) {
                                    Me(i, e) || (function(e, t) {
                                        var n = pr(e, t);
                                        if (n) {
                                            var r = document.createDocumentFragment();
                                            wr(e, n, r), e.display.dragCursor || (e.display.dragCursor = R("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), L(e.display.dragCursor, r)
                                        }
                                    }(i, e), Pe(e))
                                },
                                start: function(e) {
                                    return function(e, t) {
                                        if (_ && (!e.state.draggingText || +new Date - No < 100)) Pe(t);
                                        else if (!Me(e, t) && !Ln(e.display, t) && (t.dataTransfer.setData("Text", e.getSelection()), t.dataTransfer.effectAllowed = "copyMove", t.dataTransfer.setDragImage && !l)) {
                                            var n = R("img", null, null, "position: fixed; left: 0; top: 0;");
                                            n.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", v && (n.width = n.height = 1, e.display.wrapper.appendChild(n), n._top = n.offsetTop), t.dataTransfer.setDragImage(n, 0, 0), v && n.parentNode.removeChild(n)
                                        }
                                    }(i, e)
                                },
                                drop: ri(i, ko),
                                leave: function(e) {
                                    Me(i, e) || zo(i)
                                }
                            };
                            var e = o.input.getField();
                            be(e, "keyup", function(e) {
                                return fa.call(i, e)
                            }), be(e, "keydown", ri(i, pa)), be(e, "keypress", ri(i, ma)), be(e, "focus", function(e) {
                                return Lr(i, e)
                            }), be(e, "blur", function(e) {
                                return Ar(i, e)
                            })
                        }(this), Uo(), Kr(this), this.curOp.forceUpdate = !0, Fi(this, r), t.autofocus && !d || this.hasFocus() ? setTimeout(k(Lr, this), 20) : Ar(this), Ca) Ca.hasOwnProperty(a) && Ca[a](n, t[a], Ta);
                mi(this), t.finishInit && t.finishInit(this);
                for (var s = 0; s < Pa.length; ++s) Pa[s](n);
                Jr(this), x && t.lineWrapping && "optimizelegibility" == getComputedStyle(o.lineDiv).textRendering && (o.lineDiv.style.textRendering = "auto")
            }
            Ra.defaults = Ea, Ra.optionHandlers = Ca;
            var Pa = [];

            function Oa(e, t, n, r) {
                var i, o = e.doc;
                null == n && (n = "add"), "smart" == n && (o.mode.indent ? i = _t(e, t).state : n = "prev");
                var a = e.options.tabSize,
                    s = et(o, t),
                    l = F(s.text, null, a);
                s.stateAfter && (s.stateAfter = null);
                var c, u = s.text.match(/^\s*/)[0];
                if (r || /\S/.test(s.text)) {
                    if ("smart" == n && ((c = o.mode.indent(i, s.text.slice(u.length), s.text)) == G || 150 < c)) {
                        if (!r) return;
                        n = "prev"
                    }
                } else c = 0, n = "not";
                "prev" == n ? c = t > o.first ? F(et(o, t - 1).text, null, a) : 0 : "add" == n ? c = l + e.options.indentUnit : "subtract" == n ? c = l - e.options.indentUnit : "number" == typeof n && (c = l + n), c = Math.max(0, c);
                var h = "",
                    d = 0;
                if (e.options.indentWithTabs)
                    for (var p = Math.floor(c / a); p; --p) d += a, h += "\t";
                if (d < c && (h += Y(c - d)), h != u) return yo(o, h, lt(t, 0), lt(t, u.length), "+input"), !(s.stateAfter = null);
                for (var f = 0; f < o.sel.ranges.length; f++) {
                    var m = o.sel.ranges[f];
                    if (m.head.line == t && m.head.ch < u.length) {
                        var v = lt(t, u.length);
                        $i(o, f, new Ei(v, v));
                        break
                    }
                }
            }
            Ra.defineInitHook = function(e) {
                return Pa.push(e)
            };
            var Ia = null;

            function Da(e) {
                Ia = e
            }

            function Na(e, t, n, r, i) {
                var o = e.doc;
                e.display.shift = !1, r = r || o.sel;
                var a = +new Date - 200,
                    s = "paste" == i || e.state.pasteIncoming > a,
                    l = Ue(t),
                    c = null;
                if (s && 1 < r.ranges.length)
                    if (Ia && Ia.text.join("\n") == t) {
                        if (r.ranges.length % Ia.text.length == 0) {
                            c = [];
                            for (var u = 0; u < Ia.text.length; u++) c.push(o.splitLines(Ia.text[u]))
                        }
                    } else l.length == r.ranges.length && e.options.pasteLinesPerSelection && (c = K(l, function(e) {
                        return [e]
                    }));
                for (var h = e.curOp.updateInput, d = r.ranges.length - 1; 0 <= d; d--) {
                    var p = r.ranges[d],
                        f = p.from(),
                        m = p.to();
                    p.empty() && (n && 0 < n ? f = lt(f.line, f.ch - n) : e.state.overwrite && !s ? m = lt(m.line, Math.min(et(o, m.line).text.length, m.ch + Z(l).length)) : s && Ia && Ia.lineWise && Ia.text.join("\n") == t && (f = m = lt(f.line, 0)));
                    var v = {
                        from: f,
                        to: m,
                        text: c ? c[d % c.length] : l,
                        origin: i || (s ? "paste" : e.state.cutIncoming > a ? "cut" : "+input")
                    };
                    po(e.doc, v), mn(e, "inputRead", e, v)
                }
                t && !s && za(e, t), Nr(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = h), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1
            }

            function ka(e, t) {
                var n = e.clipboardData && e.clipboardData.getData("Text");
                if (n) return e.preventDefault(), t.isReadOnly() || t.options.disableInput || ni(t, function() {
                    return Na(t, n, 0, null, "paste")
                }), !0
            }

            function za(e, t) {
                if (e.options.electricChars && e.options.smartIndent)
                    for (var n = e.doc.sel, r = n.ranges.length - 1; 0 <= r; r--) {
                        var i = n.ranges[r];
                        if (!(100 < i.head.ch || r && n.ranges[r - 1].head.line == i.head.line)) {
                            var o = e.getModeAt(i.head),
                                a = !1;
                            if (o.electricChars) {
                                for (var s = 0; s < o.electricChars.length; s++)
                                    if (-1 < t.indexOf(o.electricChars.charAt(s))) {
                                        a = Oa(e, i.head.line, "smart");
                                        break
                                    }
                            } else o.electricInput && o.electricInput.test(et(e.doc, i.head.line).text.slice(0, i.head.ch)) && (a = Oa(e, i.head.line, "smart"));
                            a && mn(e, "electricInput", e, i.head.line)
                        }
                    }
            }

            function Fa(e) {
                for (var t = [], n = [], r = 0; r < e.doc.sel.ranges.length; r++) {
                    var i = e.doc.sel.ranges[r].head.line,
                        o = {
                            anchor: lt(i, 0),
                            head: lt(i + 1, 0)
                        };
                    n.push(o), t.push(e.getRange(o.anchor, o.head))
                }
                return {
                    text: t,
                    ranges: n
                }
            }

            function Ba(e, t, n, r) {
                e.setAttribute("autocorrect", n ? "" : "off"), e.setAttribute("autocapitalize", r ? "" : "off"), e.setAttribute("spellcheck", !!t)
            }

            function Ua() {
                var e = R("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),
                    t = R("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
                return x ? e.style.width = "1000px" : e.setAttribute("wrap", "off"), u && (e.style.border = "1px solid black"), Ba(e), t
            }

            function Ha(n, r, i, e, o) {
                var t = r,
                    a = i,
                    s = et(n, r.line);

                function l(e) {
                    var t;
                    if (null == (t = o ? function(t, n, s, e) {
                            var l = ye(n, t.doc.direction);
                            if (!l) return na(n, s, e);
                            s.ch >= n.text.length ? (s.ch = n.text.length, s.sticky = "before") : s.ch <= 0 && (s.ch = 0, s.sticky = "after");
                            var r = le(l, s.ch, s.sticky),
                                i = l[r];
                            if ("ltr" == t.doc.direction && i.level % 2 == 0 && (0 < e ? i.to > s.ch : i.from < s.ch)) return na(n, s, e);

                            function c(e, t) {
                                return ta(n, e instanceof lt ? e.ch : e, t)
                            }

                            function o(e) {
                                return t.options.lineWrapping ? (a = a || Fn(t, n), ir(t, n, a, e)) : {
                                    begin: 0,
                                    end: n.text.length
                                }
                            }
                            var a, u = o("before" == s.sticky ? c(s, -1) : s.ch);
                            if ("rtl" == t.doc.direction || 1 == i.level) {
                                var h = 1 == i.level == e < 0,
                                    d = c(s, h ? 1 : -1);
                                if (null != d && (h ? d <= i.to && d <= u.end : d >= i.from && d >= u.begin)) {
                                    var p = h ? "before" : "after";
                                    return new lt(s.line, d, p)
                                }
                            }

                            function f(e, t, n) {
                                for (var r = function(e, t) {
                                        return t ? new lt(s.line, c(e, 1), "before") : new lt(s.line, e, "after")
                                    }; 0 <= e && e < l.length; e += t) {
                                    var i = l[e],
                                        o = 0 < t == (1 != i.level),
                                        a = o ? n.begin : c(n.end, -1);
                                    if (i.from <= a && a < i.to) return r(a, o);
                                    if (a = o ? i.from : c(i.to, -1), n.begin <= a && a < n.end) return r(a, o)
                                }
                            }
                            var m = f(r + e, e, u);
                            if (m) return m;
                            var v = 0 < e ? u.end : c(u.begin, -1);
                            return null == v || 0 < e && v == n.text.length || !(m = f(0 < e ? 0 : l.length - 1, e, o(v))) ? null : m
                        }(n.cm, s, r, i) : na(s, r, i))) {
                        if (e || ! function() {
                                var e = r.line + i;
                                return !(e < n.first || e >= n.first + n.size) && (r = new lt(e, r.ch, r.sticky), s = et(n, e))
                            }()) return !1;
                        r = ra(o, n.cm, s, r.line, i)
                    } else r = t;
                    return !0
                }
                if ("char" == e) l();
                else if ("column" == e) l(!0);
                else if ("word" == e || "group" == e)
                    for (var c = null, u = "group" == e, h = n.cm && n.cm.getHelper(r, "wordChars"), d = !0; !(i < 0) || l(!d); d = !1) {
                        var p = s.text.charAt(r.ch) || "\n",
                            f = te(p, h) ? "w" : u && "\n" == p ? "n" : !u || /\s/.test(p) ? null : "p";
                        if (!u || d || f || (f = "s"), c && c != f) {
                            i < 0 && (i = 1, l(), r.sticky = "after");
                            break
                        }
                        if (f && (c = f), 0 < i && !l(!d)) break
                    }
                var m = lo(n, r, t, a, !0);
                return ut(t, m) && (m.hitSide = !0), m
            }

            function Ga(e, t, n, r) {
                var i, o, a = e.doc,
                    s = t.left;
                if ("page" == r) {
                    var l = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight),
                        c = Math.max(l - .5 * sr(e.display), 3);
                    i = (0 < n ? t.bottom : t.top) + n * c
                } else "line" == r && (i = 0 < n ? t.bottom + 3 : t.top - 3);
                for (;
                    (o = nr(e, s, i)).outside;) {
                    if (n < 0 ? i <= 0 : i >= a.height) {
                        o.hitSide = !0;
                        break
                    }
                    i += 5 * n
                }
                return o
            }

            function Va(e) {
                this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new B, this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null
            }

            function Wa(e, t) {
                var n = zn(e, t.line);
                if (!n || n.hidden) return null;
                var r = et(e.doc, t.line),
                    i = Nn(n, r, t.line),
                    o = ye(r, e.doc.direction),
                    a = "left";
                o && (a = le(o, t.ch) % 2 ? "right" : "left");
                var s = Gn(i.map, t.ch, a);
                return s.offset = "right" == s.collapse ? s.end : s.start, s
            }

            function ja(e, t) {
                return t && (e.bad = !0), e
            }

            function qa(e, t, n) {
                var r;
                if (t == e.display.lineDiv) {
                    if (!(r = e.display.lineDiv.childNodes[n])) return ja(e.clipPos(lt(e.display.viewTo - 1)), !0);
                    t = null, n = 0
                } else
                    for (r = t;; r = r.parentNode) {
                        if (!r || r == e.display.lineDiv) return null;
                        if (r.parentNode && r.parentNode == e.display.lineDiv) break
                    }
                for (var i = 0; i < e.display.view.length; i++) {
                    var o = e.display.view[i];
                    if (o.node == r) return Xa(o, t, n)
                }
            }

            function Xa(c, e, t) {
                var n = c.text.firstChild,
                    r = !1;
                if (!e || !P(n, e)) return ja(lt(it(c.line), 0), !0);
                if (e == n && (r = !0, e = n.childNodes[t], t = 0, !e)) {
                    var i = c.rest ? Z(c.rest) : c.line;
                    return ja(lt(it(i), i.text.length), r)
                }
                var o = 3 == e.nodeType ? e : null,
                    a = e;
                for (o || 1 != e.childNodes.length || 3 != e.firstChild.nodeType || (o = e.firstChild, t = t && o.nodeValue.length); a.parentNode != n;) a = a.parentNode;
                var u = c.measure,
                    h = u.maps;

                function s(e, t, n) {
                    for (var r = -1; r < (h ? h.length : 0); r++)
                        for (var i = r < 0 ? u.map : h[r], o = 0; o < i.length; o += 3) {
                            var a = i[o + 2];
                            if (a == e || a == t) {
                                var s = it(r < 0 ? c.line : c.rest[r]),
                                    l = i[o] + n;
                                return (n < 0 || a != e) && (l = i[o + (n ? 1 : 0)]), lt(s, l)
                            }
                        }
                }
                var l = s(o, a, t);
                if (l) return ja(l, r);
                for (var d = a.nextSibling, p = o ? o.nodeValue.length - t : 0; d; d = d.nextSibling) {
                    if (l = s(d, d.firstChild, 0)) return ja(lt(l.line, l.ch - p), r);
                    p += d.textContent.length
                }
                for (var f = a.previousSibling, m = t; f; f = f.previousSibling) {
                    if (l = s(f, f.firstChild, -1)) return ja(lt(l.line, l.ch + m), r);
                    m += f.textContent.length
                }
            }
            Va.prototype.init = function(e) {
                var t = this,
                    a = this,
                    s = a.cm,
                    l = a.div = e.lineDiv;

                function n(e) {
                    if (!Me(s, e)) {
                        if (s.somethingSelected()) Da({
                            lineWise: !1,
                            text: s.getSelections()
                        }), "cut" == e.type && s.replaceSelection("", null, "cut");
                        else {
                            if (!s.options.lineWiseCopyCut) return;
                            var t = Fa(s);
                            Da({
                                lineWise: !0,
                                text: t.text
                            }), "cut" == e.type && s.operation(function() {
                                s.setSelections(t.ranges, 0, V), s.replaceSelection("", null, "cut")
                            })
                        }
                        if (e.clipboardData) {
                            e.clipboardData.clearData();
                            var n = Ia.text.join("\n");
                            if (e.clipboardData.setData("Text", n), e.clipboardData.getData("Text") == n) return void e.preventDefault()
                        }
                        var r = Ua(),
                            i = r.firstChild;
                        s.display.lineSpace.insertBefore(r, s.display.lineSpace.firstChild), i.value = Ia.text.join("\n");
                        var o = document.activeElement;
                        N(i), setTimeout(function() {
                            s.display.lineSpace.removeChild(r), o.focus(), o == l && a.showPrimarySelection()
                        }, 50)
                    }
                }
                Ba(l, s.options.spellcheck, s.options.autocorrect, s.options.autocapitalize), be(l, "paste", function(e) {
                    Me(s, e) || ka(e, s) || w <= 11 && setTimeout(ri(s, function() {
                        return t.updateFromDOM()
                    }), 20)
                }), be(l, "compositionstart", function(e) {
                    t.composing = {
                        data: e.data,
                        done: !1
                    }
                }), be(l, "compositionupdate", function(e) {
                    t.composing || (t.composing = {
                        data: e.data,
                        done: !1
                    })
                }), be(l, "compositionend", function(e) {
                    t.composing && (e.data != t.composing.data && t.readFromDOMSoon(), t.composing.done = !0)
                }), be(l, "touchstart", function() {
                    return a.forceCompositionEnd()
                }), be(l, "input", function() {
                    t.composing || t.readFromDOMSoon()
                }), be(l, "copy", n), be(l, "cut", n)
            }, Va.prototype.prepareSelection = function() {
                var e = _r(this.cm, !1);
                return e.focus = this.cm.state.focused, e
            }, Va.prototype.showSelection = function(e, t) {
                e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e))
            }, Va.prototype.getSelection = function() {
                return this.cm.display.wrapper.ownerDocument.getSelection()
            }, Va.prototype.showPrimarySelection = function() {
                var e = this.getSelection(),
                    t = this.cm,
                    n = t.doc.sel.primary(),
                    r = n.from(),
                    i = n.to();
                if (t.display.viewTo == t.display.viewFrom || r.line >= t.display.viewTo || i.line < t.display.viewFrom) e.removeAllRanges();
                else {
                    var o = qa(t, e.anchorNode, e.anchorOffset),
                        a = qa(t, e.focusNode, e.focusOffset);
                    if (!o || o.bad || !a || a.bad || 0 != ct(pt(o, a), r) || 0 != ct(dt(o, a), i)) {
                        var s = t.display.view,
                            l = r.line >= t.display.viewFrom && Wa(t, r) || {
                                node: s[0].measure.map[2],
                                offset: 0
                            },
                            c = i.line < t.display.viewTo && Wa(t, i);
                        if (!c) {
                            var u = s[s.length - 1].measure,
                                h = u.maps ? u.maps[u.maps.length - 1] : u.map;
                            c = {
                                node: h[h.length - 1],
                                offset: h[h.length - 2] - h[h.length - 3]
                            }
                        }
                        if (l && c) {
                            var d, p = e.rangeCount && e.getRangeAt(0);
                            try {
                                d = T(l.node, l.offset, c.offset, c.node)
                            } catch (e) {}
                            d && (!m && t.state.focused ? (e.collapse(l.node, l.offset), d.collapsed || (e.removeAllRanges(), e.addRange(d))) : (e.removeAllRanges(), e.addRange(d)), p && null == e.anchorNode ? e.addRange(p) : m && this.startGracePeriod()), this.rememberSelection()
                        } else e.removeAllRanges()
                    }
                }
            }, Va.prototype.startGracePeriod = function() {
                var e = this;
                clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
                    e.gracePeriod = !1, e.selectionChanged() && e.cm.operation(function() {
                        return e.cm.curOp.selectionChanged = !0
                    })
                }, 20)
            }, Va.prototype.showMultipleSelections = function(e) {
                L(this.cm.display.cursorDiv, e.cursors), L(this.cm.display.selectionDiv, e.selection)
            }, Va.prototype.rememberSelection = function() {
                var e = this.getSelection();
                this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset
            }, Va.prototype.selectionInEditor = function() {
                var e = this.getSelection();
                if (!e.rangeCount) return !1;
                var t = e.getRangeAt(0).commonAncestorContainer;
                return P(this.div, t)
            }, Va.prototype.focus = function() {
                "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0), this.div.focus())
            }, Va.prototype.blur = function() {
                this.div.blur()
            }, Va.prototype.getField = function() {
                return this.div
            }, Va.prototype.supportsTouch = function() {
                return !0
            }, Va.prototype.receivedFocus = function() {
                var t = this;
                this.selectionInEditor() ? this.pollSelection() : ni(this.cm, function() {
                    return t.cm.curOp.selectionChanged = !0
                }), this.polling.set(this.cm.options.pollInterval, function e() {
                    t.cm.state.focused && (t.pollSelection(), t.polling.set(t.cm.options.pollInterval, e))
                })
            }, Va.prototype.selectionChanged = function() {
                var e = this.getSelection();
                return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset
            }, Va.prototype.pollSelection = function() {
                if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
                    var e = this.getSelection(),
                        t = this.cm;
                    if (h && a && this.cm.display.gutterSpecs.length && function(e) {
                            for (var t = e; t; t = t.parentNode)
                                if (/CodeMirror-gutter-wrapper/.test(t.className)) return !0;
                            return !1
                        }(e.anchorNode)) return this.cm.triggerOnKeyDown({
                        type: "keydown",
                        keyCode: 8,
                        preventDefault: Math.abs
                    }), this.blur(), void this.focus();
                    if (!this.composing) {
                        this.rememberSelection();
                        var n = qa(t, e.anchorNode, e.anchorOffset),
                            r = qa(t, e.focusNode, e.focusOffset);
                        n && r && ni(t, function() {
                            no(t.doc, Li(n, r), V), (n.bad || r.bad) && (t.curOp.selectionChanged = !0)
                        })
                    }
                }
            }, Va.prototype.pollContent = function() {
                null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
                var e, t, n, r = this.cm,
                    i = r.display,
                    o = r.doc.sel.primary(),
                    a = o.from(),
                    s = o.to();
                if (0 == a.ch && a.line > r.firstLine() && (a = lt(a.line - 1, et(r.doc, a.line - 1).length)), s.ch == et(r.doc, s.line).text.length && s.line < r.lastLine() && (s = lt(s.line + 1, 0)), a.line < i.viewFrom || s.line > i.viewTo - 1) return !1;
                n = a.line == i.viewFrom || 0 == (e = fr(r, a.line)) ? (t = it(i.view[0].line), i.view[0].node) : (t = it(i.view[e].line), i.view[e - 1].node.nextSibling);
                var l, c, u = fr(r, s.line);
                if (c = u == i.view.length - 1 ? (l = i.viewTo - 1, i.lineDiv.lastChild) : (l = it(i.view[u + 1].line) - 1, i.view[u + 1].node.previousSibling), !n) return !1;
                for (var h = r.doc.splitLines(function(s, e, t, l, c) {
                        var n = "",
                            u = !1,
                            h = s.doc.lineSeparator(),
                            d = !1;

                        function p() {
                            u && (n += h, d && (n += h), u = d = !1)
                        }

                        function f(e) {
                            e && (p(), n += e)
                        }

                        function m(e) {
                            if (1 == e.nodeType) {
                                var t = e.getAttribute("cm-text");
                                if (t) return void f(t);
                                var n, r = e.getAttribute("cm-marker");
                                if (r) {
                                    var i = s.findMarks(lt(l, 0), lt(c + 1, 0), function(t) {
                                        return function(e) {
                                            return e.id == t
                                        }
                                    }(+r));
                                    return void(i.length && (n = i[0].find(0)) && f(tt(s.doc, n.from, n.to).join(h)))
                                }
                                if ("false" == e.getAttribute("contenteditable")) return;
                                var o = /^(pre|div|p|li|table|br)$/i.test(e.nodeName);
                                if (!/^br$/i.test(e.nodeName) && 0 == e.textContent.length) return;
                                o && p();
                                for (var a = 0; a < e.childNodes.length; a++) m(e.childNodes[a]);
                                /^(pre|p)$/i.test(e.nodeName) && (d = !0), o && (u = !0)
                            } else 3 == e.nodeType && f(e.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "))
                        }
                        for (; m(e), e != t;) e = e.nextSibling, d = !1;
                        return n
                    }(r, n, c, t, l)), d = tt(r.doc, lt(t, 0), lt(l, et(r.doc, l).text.length)); 1 < h.length && 1 < d.length;)
                    if (Z(h) == Z(d)) h.pop(), d.pop(), l--;
                    else {
                        if (h[0] != d[0]) break;
                        h.shift(), d.shift(), t++
                    }
                for (var p = 0, f = 0, m = h[0], v = d[0], g = Math.min(m.length, v.length); p < g && m.charCodeAt(p) == v.charCodeAt(p);) ++p;
                for (var y = Z(h), x = Z(d), b = Math.min(y.length - (1 == h.length ? p : 0), x.length - (1 == d.length ? p : 0)); f < b && y.charCodeAt(y.length - f - 1) == x.charCodeAt(x.length - f - 1);) ++f;
                if (1 == h.length && 1 == d.length && t == a.line)
                    for (; p && p > a.ch && y.charCodeAt(y.length - f - 1) == x.charCodeAt(x.length - f - 1);) p--, f++;
                h[h.length - 1] = y.slice(0, y.length - f).replace(/^\u200b+/, ""), h[0] = h[0].slice(p).replace(/\u200b+$/, "");
                var _ = lt(t, p),
                    w = lt(l, d.length ? Z(d).length - f : 0);
                return 1 < h.length || h[0] || ct(_, w) ? (yo(r.doc, h, _, w, "+input"), !0) : void 0
            }, Va.prototype.ensurePolled = function() {
                this.forceCompositionEnd()
            }, Va.prototype.reset = function() {
                this.forceCompositionEnd()
            }, Va.prototype.forceCompositionEnd = function() {
                this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus())
            }, Va.prototype.readFromDOMSoon = function() {
                var e = this;
                null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
                    if (e.readDOMTimeout = null, e.composing) {
                        if (!e.composing.done) return;
                        e.composing = null
                    }
                    e.updateFromDOM()
                }, 80))
            }, Va.prototype.updateFromDOM = function() {
                var e = this;
                !this.cm.isReadOnly() && this.pollContent() || ni(this.cm, function() {
                    return mr(e.cm)
                })
            }, Va.prototype.setUneditable = function(e) {
                e.contentEditable = "false"
            }, Va.prototype.onKeyPress = function(e) {
                0 == e.charCode || this.composing || (e.preventDefault(), this.cm.isReadOnly() || ri(this.cm, Na)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0))
            }, Va.prototype.readOnlyChanged = function(e) {
                this.div.contentEditable = String("nocursor" != e)
            }, Va.prototype.onContextMenu = function() {}, Va.prototype.resetPosition = function() {}, Va.prototype.needsContentAttribute = !0;

            function Ya(e) {
                this.cm = e, this.prevInput = "", this.pollingFast = !1, this.polling = new B, this.hasSelection = !1, this.composing = null
            }
            var Za, Ka, Ja, Qa, $a;

            function es(e, t, r, n) {
                Za.defaults[e] = t, r && (Ka[e] = n ? function(e, t, n) {
                    n != Ta && r(e, t, n)
                } : r)
            }
            Ya.prototype.init = function(n) {
                var e = this,
                    r = this,
                    i = this.cm;
                this.createField(n);
                var o = this.textarea;

                function t(e) {
                    if (!Me(i, e)) {
                        if (i.somethingSelected()) Da({
                            lineWise: !1,
                            text: i.getSelections()
                        });
                        else {
                            if (!i.options.lineWiseCopyCut) return;
                            var t = Fa(i);
                            Da({
                                lineWise: !0,
                                text: t.text
                            }), "cut" == e.type ? i.setSelections(t.ranges, null, V) : (r.prevInput = "", o.value = t.text.join("\n"), N(o))
                        }
                        "cut" == e.type && (i.state.cutIncoming = +new Date)
                    }
                }
                n.wrapper.insertBefore(this.wrapper, n.wrapper.firstChild), u && (o.style.width = "0px"), be(o, "input", function() {
                    _ && 9 <= w && e.hasSelection && (e.hasSelection = null), r.poll()
                }), be(o, "paste", function(e) {
                    Me(i, e) || ka(e, i) || (i.state.pasteIncoming = +new Date, r.fastPoll())
                }), be(o, "cut", t), be(o, "copy", t), be(n.scroller, "paste", function(e) {
                    if (!Ln(n, e) && !Me(i, e)) {
                        if (!o.dispatchEvent) return i.state.pasteIncoming = +new Date, void r.focus();
                        var t = new Event("paste");
                        t.clipboardData = e.clipboardData, o.dispatchEvent(t)
                    }
                }), be(n.lineSpace, "selectstart", function(e) {
                    Ln(n, e) || Le(e)
                }), be(o, "compositionstart", function() {
                    var e = i.getCursor("from");
                    r.composing && r.composing.range.clear(), r.composing = {
                        start: e,
                        range: i.markText(e, i.getCursor("to"), {
                            className: "CodeMirror-composing"
                        })
                    }
                }), be(o, "compositionend", function() {
                    r.composing && (r.poll(), r.composing.range.clear(), r.composing = null)
                })
            }, Ya.prototype.createField = function(e) {
                this.wrapper = Ua(), this.textarea = this.wrapper.firstChild
            }, Ya.prototype.prepareSelection = function() {
                var e = this.cm,
                    t = e.display,
                    n = e.doc,
                    r = _r(e);
                if (e.options.moveInputWithCursor) {
                    var i = $n(e, n.sel.primary().head, "div"),
                        o = t.wrapper.getBoundingClientRect(),
                        a = t.lineDiv.getBoundingClientRect();
                    r.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, i.top + a.top - o.top)), r.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, i.left + a.left - o.left))
                }
                return r
            }, Ya.prototype.showSelection = function(e) {
                var t = this.cm.display;
                L(t.cursorDiv, e.cursors), L(t.selectionDiv, e.selection), null != e.teTop && (this.wrapper.style.top = e.teTop + "px", this.wrapper.style.left = e.teLeft + "px")
            }, Ya.prototype.reset = function(e) {
                if (!this.contextMenuPending && !this.composing) {
                    var t = this.cm;
                    if (t.somethingSelected()) {
                        this.prevInput = "";
                        var n = t.getSelection();
                        this.textarea.value = n, t.state.focused && N(this.textarea), _ && 9 <= w && (this.hasSelection = n)
                    } else e || (this.prevInput = this.textarea.value = "", _ && 9 <= w && (this.hasSelection = null))
                }
            }, Ya.prototype.getField = function() {
                return this.textarea
            }, Ya.prototype.supportsTouch = function() {
                return !1
            }, Ya.prototype.focus = function() {
                if ("nocursor" != this.cm.options.readOnly && (!d || O() != this.textarea)) try {
                    this.textarea.focus()
                } catch (e) {}
            }, Ya.prototype.blur = function() {
                this.textarea.blur()
            }, Ya.prototype.resetPosition = function() {
                this.wrapper.style.top = this.wrapper.style.left = 0
            }, Ya.prototype.receivedFocus = function() {
                this.slowPoll()
            }, Ya.prototype.slowPoll = function() {
                var e = this;
                this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
                    e.poll(), e.cm.state.focused && e.slowPoll()
                })
            }, Ya.prototype.fastPoll = function() {
                var t = !1,
                    n = this;
                n.pollingFast = !0, n.polling.set(20, function e() {
                    n.poll() || t ? (n.pollingFast = !1, n.slowPoll()) : (t = !0, n.polling.set(60, e))
                })
            }, Ya.prototype.poll = function() {
                var e = this,
                    t = this.cm,
                    n = this.textarea,
                    r = this.prevInput;
                if (this.contextMenuPending || !t.state.focused || He(n) && !r && !this.composing || t.isReadOnly() || t.options.disableInput || t.state.keySeq) return !1;
                var i = n.value;
                if (i == r && !t.somethingSelected()) return !1;
                if (_ && 9 <= w && this.hasSelection === i || b && /[\uf700-\uf7ff]/.test(i)) return t.display.input.reset(), !1;
                if (t.doc.sel == t.display.selForContextMenu) {
                    var o = i.charCodeAt(0);
                    if (8203 != o || r || (r = "â€‹"), 8666 == o) return this.reset(), this.cm.execCommand("undo")
                }
                for (var a = 0, s = Math.min(r.length, i.length); a < s && r.charCodeAt(a) == i.charCodeAt(a);) ++a;
                return ni(t, function() {
                    Na(t, i.slice(a), r.length - a, null, e.composing ? "*compose" : null), 1e3 < i.length || -1 < i.indexOf("\n") ? n.value = e.prevInput = "" : e.prevInput = i, e.composing && (e.composing.range.clear(), e.composing.range = t.markText(e.composing.start, t.getCursor("to"), {
                        className: "CodeMirror-composing"
                    }))
                }), !0
            }, Ya.prototype.ensurePolled = function() {
                this.pollingFast && this.poll() && (this.pollingFast = !1)
            }, Ya.prototype.onKeyPress = function() {
                _ && 9 <= w && (this.hasSelection = null), this.fastPoll()
            }, Ya.prototype.onContextMenu = function(e) {
                var n = this,
                    r = n.cm,
                    i = r.display,
                    o = n.textarea;
                n.contextMenuPending && n.contextMenuPending();
                var t = pr(r, e),
                    a = i.scroller.scrollTop;
                if (t && !v) {
                    r.options.resetSelectionOnContextMenu && -1 == r.doc.sel.contains(t) && ri(r, no)(r.doc, Li(t), V);
                    var s, l = o.style.cssText,
                        c = n.wrapper.style.cssText,
                        u = n.wrapper.offsetParent.getBoundingClientRect();
                    if (n.wrapper.style.cssText = "position: static", o.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - u.top - 5) + "px; left: " + (e.clientX - u.left - 5) + "px;\n      z-index: 1000; background: " + (_ ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", x && (s = window.scrollY), i.input.focus(), x && window.scrollTo(null, s), i.input.reset(), r.somethingSelected() || (o.value = n.prevInput = " "), n.contextMenuPending = p, i.selForContextMenu = r.doc.sel, clearTimeout(i.detectingSelectAll), _ && 9 <= w && d(), S) {
                        Pe(e);
                        var h = function() {
                            we(window, "mouseup", h), setTimeout(p, 20)
                        };
                        be(window, "mouseup", h)
                    } else setTimeout(p, 50)
                }

                function d() {
                    if (null != o.selectionStart) {
                        var e = r.somethingSelected(),
                            t = "â€‹" + (e ? o.value : "");
                        o.value = "â‡š", o.value = t, n.prevInput = e ? "" : "â€‹", o.selectionStart = 1, o.selectionEnd = t.length, i.selForContextMenu = r.doc.sel
                    }
                }

                function p() {
                    if (n.contextMenuPending == p && (n.contextMenuPending = !1, n.wrapper.style.cssText = c, o.style.cssText = l, _ && w < 9 && i.scrollbars.setScrollTop(i.scroller.scrollTop = a), null != o.selectionStart)) {
                        (!_ || _ && w < 9) && d();
                        var e = 0,
                            t = function() {
                                i.selForContextMenu == r.doc.sel && 0 == o.selectionStart && 0 < o.selectionEnd && "â€‹" == n.prevInput ? ri(r, uo)(r) : e++ < 10 ? i.detectingSelectAll = setTimeout(t, 500) : (i.selForContextMenu = null, i.input.reset())
                            };
                        i.detectingSelectAll = setTimeout(t, 200)
                    }
                }
            }, Ya.prototype.readOnlyChanged = function(e) {
                e || this.reset(), this.textarea.disabled = "nocursor" == e
            }, Ya.prototype.setUneditable = function() {}, Ya.prototype.needsContentAttribute = !1, Ka = (Za = Ra).optionHandlers, Za.defineOption = es, Za.Init = Ta, es("value", "", function(e, t) {
                return e.setValue(t)
            }, !0), es("mode", null, function(e, t) {
                e.doc.modeOption = t, Ii(e)
            }, !0), es("indentUnit", 2, Ii, !0), es("indentWithTabs", !1), es("smartIndent", !0), es("tabSize", 4, function(e) {
                Di(e), qn(e), mr(e)
            }, !0), es("lineSeparator", null, function(e, r) {
                if (e.doc.lineSep = r) {
                    var i = [],
                        o = e.doc.first;
                    e.doc.iter(function(e) {
                        for (var t = 0;;) {
                            var n = e.text.indexOf(r, t);
                            if (-1 == n) break;
                            t = n + r.length, i.push(lt(o, n))
                        }
                        o++
                    });
                    for (var t = i.length - 1; 0 <= t; t--) yo(e.doc, r, i[t], lt(i[t].line, i[t].ch + r.length))
                }
            }), es("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(e, t, n) {
                e.state.specialChars = new RegExp(t.source + (t.test("\t") ? "" : "|\t"), "g"), n != Ta && e.refresh()
            }), es("specialCharPlaceholder", an, function(e) {
                return e.refresh()
            }, !0), es("electricChars", !0), es("inputStyle", d ? "contenteditable" : "textarea", function() {
                throw new Error("inputStyle can not (yet) be changed in a running editor")
            }, !0), es("spellcheck", !1, function(e, t) {
                return e.getInputField().spellcheck = t
            }, !0), es("autocorrect", !1, function(e, t) {
                return e.getInputField().autocorrect = t
            }, !0), es("autocapitalize", !1, function(e, t) {
                return e.getInputField().autocapitalize = t
            }, !0), es("rtlMoveVisually", !f), es("wholeLineUpdateBefore", !0), es("theme", "default", function(e) {
                Ma(e), yi(e)
            }, !0), es("keyMap", "default", function(e, t, n) {
                var r = $o(t),
                    i = n != Ta && $o(n);
                i && i.detach && i.detach(e, r), r.attach && r.attach(e, i || null)
            }), es("extraKeys", null), es("configureMouse", null), es("lineWrapping", !1, Aa, !0), es("gutters", [], function(e, t) {
                e.display.gutterSpecs = vi(t, e.options.lineNumbers), yi(e)
            }, !0), es("fixedGutter", !0, function(e, t) {
                e.display.gutters.style.left = t ? ur(e.display) + "px" : "0", e.refresh()
            }, !0), es("coverGutterNextToScrollbar", !1, function(e) {
                return jr(e)
            }, !0), es("scrollbarStyle", "native", function(e) {
                Yr(e), jr(e), e.display.scrollbars.setScrollTop(e.doc.scrollTop), e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)
            }, !0), es("lineNumbers", !1, function(e, t) {
                e.display.gutterSpecs = vi(e.options.gutters, t), yi(e)
            }, !0), es("firstLineNumber", 1, yi, !0), es("lineNumberFormatter", function(e) {
                return e
            }, yi, !0), es("showCursorWhenSelecting", !1, br, !0), es("resetSelectionOnContextMenu", !0), es("lineWiseCopyCut", !0), es("pasteLinesPerSelection", !0), es("selectionsMayTouch", !1), es("readOnly", !1, function(e, t) {
                "nocursor" == t && (Ar(e), e.display.input.blur()), e.display.input.readOnlyChanged(t)
            }), es("disableInput", !1, function(e, t) {
                t || e.display.input.reset()
            }, !0), es("dragDrop", !0, La), es("allowDropFileTypes", null), es("cursorBlinkRate", 530), es("cursorScrollMargin", 0), es("cursorHeight", 1, br, !0), es("singleCursorHeightPerLine", !0, br, !0), es("workTime", 100), es("workDelay", 100), es("flattenSpans", !0, Di, !0), es("addModeClass", !1, Di, !0), es("pollInterval", 100), es("undoDepth", 200, function(e, t) {
                return e.doc.history.undoDepth = t
            }), es("historyEventDelay", 1250), es("viewportMargin", 10, function(e) {
                return e.refresh()
            }, !0), es("maxHighlightLength", 1e4, Di, !0), es("moveInputWithCursor", !0, function(e, t) {
                t || e.display.input.resetPosition()
            }), es("tabindex", null, function(e, t) {
                return e.display.input.getField().tabIndex = t || ""
            }), es("autofocus", null), es("direction", "ltr", function(e, t) {
                return e.doc.setDirection(t)
            }, !0), es("phrases", null), Qa = (Ja = Ra).optionHandlers, $a = Ja.helpers = {}, Ja.prototype = {
                constructor: Ja,
                focus: function() {
                    window.focus(), this.display.input.focus()
                },
                setOption: function(e, t) {
                    var n = this.options,
                        r = n[e];
                    n[e] == t && "mode" != e || (n[e] = t, Qa.hasOwnProperty(e) && ri(this, Qa[e])(this, t, r), Se(this, "optionChange", this, e))
                },
                getOption: function(e) {
                    return this.options[e]
                },
                getDoc: function() {
                    return this.doc
                },
                addKeyMap: function(e, t) {
                    this.state.keyMaps[t ? "push" : "unshift"]($o(e))
                },
                removeKeyMap: function(e) {
                    for (var t = this.state.keyMaps, n = 0; n < t.length; ++n)
                        if (t[n] == e || t[n].name == e) return t.splice(n, 1), !0
                },
                addOverlay: ii(function(e, t) {
                    var n = e.token ? e : Ja.getMode(this.options, e);
                    if (n.startState) throw new Error("Overlays may not be stateful.");
                    ! function(e, t, n) {
                        for (var r = 0, i = n(t); r < e.length && n(e[r]) <= i;) r++;
                        e.splice(r, 0, t)
                    }(this.state.overlays, {
                        mode: n,
                        modeSpec: e,
                        opaque: t && t.opaque,
                        priority: t && t.priority || 0
                    }, function(e) {
                        return e.priority
                    }), this.state.modeGen++, mr(this)
                }),
                removeOverlay: ii(function(e) {
                    for (var t = this.state.overlays, n = 0; n < t.length; ++n) {
                        var r = t[n].modeSpec;
                        if (r == e || "string" == typeof e && r.name == e) return t.splice(n, 1), this.state.modeGen++, void mr(this)
                    }
                }),
                indentLine: ii(function(e, t, n) {
                    "string" != typeof t && "number" != typeof t && (t = null == t ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"), at(this.doc, e) && Oa(this, e, t, n)
                }),
                indentSelection: ii(function(e) {
                    for (var t = this.doc.sel.ranges, n = -1, r = 0; r < t.length; r++) {
                        var i = t[r];
                        if (i.empty()) i.head.line > n && (Oa(this, i.head.line, e, !0), n = i.head.line, r == this.doc.sel.primIndex && Nr(this));
                        else {
                            var o = i.from(),
                                a = i.to(),
                                s = Math.max(n, o.line);
                            n = Math.min(this.lastLine(), a.line - (a.ch ? 0 : 1)) + 1;
                            for (var l = s; l < n; ++l) Oa(this, l, e);
                            var c = this.doc.sel.ranges;
                            0 == o.ch && t.length == c.length && 0 < c[r].from().ch && $i(this.doc, r, new Ei(o, c[r].to()), V)
                        }
                    }
                }),
                getTokenAt: function(e, t) {
                    return Et(this, e, t)
                },
                getLineTokens: function(e, t) {
                    return Et(this, lt(e), t, !0)
                },
                getTokenTypeAt: function(e) {
                    e = mt(this.doc, e);
                    var t, n = bt(this, et(this.doc, e.line)),
                        r = 0,
                        i = (n.length - 1) / 2,
                        o = e.ch;
                    if (0 == o) t = n[2];
                    else
                        for (;;) {
                            var a = r + i >> 1;
                            if ((a ? n[2 * a - 1] : 0) >= o) i = a;
                            else {
                                if (!(n[2 * a + 1] < o)) {
                                    t = n[2 * a + 2];
                                    break
                                }
                                r = 1 + a
                            }
                        }
                    var s = t ? t.indexOf("overlay ") : -1;
                    return s < 0 ? t : 0 == s ? null : t.slice(0, s - 1)
                },
                getModeAt: function(e) {
                    var t = this.doc.mode;
                    return t.innerMode ? Ja.innerMode(t, this.getTokenAt(e).state).mode : t
                },
                getHelper: function(e, t) {
                    return this.getHelpers(e, t)[0]
                },
                getHelpers: function(e, t) {
                    var n = [];
                    if (!$a.hasOwnProperty(t)) return n;
                    var r = $a[t],
                        i = this.getModeAt(e);
                    if ("string" == typeof i[t]) r[i[t]] && n.push(r[i[t]]);
                    else if (i[t])
                        for (var o = 0; o < i[t].length; o++) {
                            var a = r[i[t][o]];
                            a && n.push(a)
                        } else i.helperType && r[i.helperType] ? n.push(r[i.helperType]) : r[i.name] && n.push(r[i.name]);
                    for (var s = 0; s < r._global.length; s++) {
                        var l = r._global[s];
                        l.pred(i, this) && -1 == U(n, l.val) && n.push(l.val)
                    }
                    return n
                },
                getStateAfter: function(e, t) {
                    var n = this.doc;
                    return _t(this, (e = ft(n, null == e ? n.first + n.size - 1 : e)) + 1, t).state
                },
                cursorCoords: function(e, t) {
                    var n = this.doc.sel.primary();
                    return $n(this, null == e ? n.head : "object" == typeof e ? mt(this.doc, e) : e ? n.from() : n.to(), t || "page")
                },
                charCoords: function(e, t) {
                    return Qn(this, mt(this.doc, e), t || "page")
                },
                coordsChar: function(e, t) {
                    return nr(this, (e = Jn(this, e, t || "page")).left, e.top)
                },
                lineAtHeight: function(e, t) {
                    return e = Jn(this, {
                        top: e,
                        left: 0
                    }, t || "page").top, ot(this.doc, e + this.display.viewOffset)
                },
                heightAtLine: function(e, t, n) {
                    var r, i = !1;
                    if ("number" == typeof e) {
                        var o = this.doc.first + this.doc.size - 1;
                        e < this.doc.first ? e = this.doc.first : o < e && (e = o, i = !0), r = et(this.doc, e)
                    } else r = e;
                    return Kn(this, r, {
                        top: 0,
                        left: 0
                    }, t || "page", n || i).top + (i ? this.doc.height - Jt(r) : 0)
                },
                defaultTextHeight: function() {
                    return sr(this.display)
                },
                defaultCharWidth: function() {
                    return lr(this.display)
                },
                getViewport: function() {
                    return {
                        from: this.display.viewFrom,
                        to: this.display.viewTo
                    }
                },
                addWidget: function(e, t, n, r, i) {
                    var o = this.display,
                        a = (e = $n(this, mt(this.doc, e))).bottom,
                        s = e.left;
                    if (t.style.position = "absolute", t.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(t), o.sizer.appendChild(t), "over" == r) a = e.top;
                    else if ("above" == r || "near" == r) {
                        var l = Math.max(o.wrapper.clientHeight, this.doc.height),
                            c = Math.max(o.sizer.clientWidth, o.lineSpace.clientWidth);
                        ("above" == r || e.bottom + t.offsetHeight > l) && e.top > t.offsetHeight ? a = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= l && (a = e.bottom), s + t.offsetWidth > c && (s = c - t.offsetWidth)
                    }
                    t.style.top = a + "px", t.style.left = t.style.right = "", "right" == i ? (s = o.sizer.clientWidth - t.offsetWidth, t.style.right = "0px") : ("left" == i ? s = 0 : "middle" == i && (s = (o.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = s + "px"), n && function(e, t) {
                        var n = Ir(e, t);
                        null != n.scrollTop && Br(e, n.scrollTop), null != n.scrollLeft && Hr(e, n.scrollLeft)
                    }(this, {
                        left: s,
                        top: a,
                        right: s + t.offsetWidth,
                        bottom: a + t.offsetHeight
                    })
                },
                triggerOnKeyDown: ii(pa),
                triggerOnKeyPress: ii(ma),
                triggerOnKeyUp: fa,
                triggerOnMouseDown: ii(xa),
                execCommand: function(e) {
                    if (ia.hasOwnProperty(e)) return ia[e].call(null, this)
                },
                triggerElectric: ii(function(e) {
                    za(this, e)
                }),
                findPosH: function(e, t, n, r) {
                    var i = 1;
                    t < 0 && (i = -1, t = -t);
                    for (var o = mt(this.doc, e), a = 0; a < t && !(o = Ha(this.doc, o, i, n, r)).hitSide; ++a);
                    return o
                },
                moveH: ii(function(t, n) {
                    var r = this;
                    this.extendSelectionsBy(function(e) {
                        return r.display.shift || r.doc.extend || e.empty() ? Ha(r.doc, e.head, t, n, r.options.rtlMoveVisually) : t < 0 ? e.from() : e.to()
                    }, j)
                }),
                deleteH: ii(function(n, r) {
                    var e = this.doc.sel,
                        i = this.doc;
                    e.somethingSelected() ? i.replaceSelection("", null, "+delete") : ea(this, function(e) {
                        var t = Ha(i, e.head, n, r, !1);
                        return n < 0 ? {
                            from: t,
                            to: e.head
                        } : {
                            from: e.head,
                            to: t
                        }
                    })
                }),
                findPosV: function(e, t, n, r) {
                    var i = 1,
                        o = r;
                    t < 0 && (i = -1, t = -t);
                    for (var a = mt(this.doc, e), s = 0; s < t; ++s) {
                        var l = $n(this, a, "div");
                        if (null == o ? o = l.left : l.left = o, (a = Ga(this, l, i, n)).hitSide) break
                    }
                    return a
                },
                moveV: ii(function(r, i) {
                    var o = this,
                        a = this.doc,
                        s = [],
                        l = !this.display.shift && !a.extend && a.sel.somethingSelected();
                    if (a.extendSelectionsBy(function(e) {
                            if (l) return r < 0 ? e.from() : e.to();
                            var t = $n(o, e.head, "div");
                            null != e.goalColumn && (t.left = e.goalColumn), s.push(t.left);
                            var n = Ga(o, t, r, i);
                            return "page" == i && e == a.sel.primary() && Dr(o, Qn(o, n, "div").top - t.top), n
                        }, j), s.length)
                        for (var e = 0; e < a.sel.ranges.length; e++) a.sel.ranges[e].goalColumn = s[e]
                }),
                findWordAt: function(e) {
                    var t = et(this.doc, e.line).text,
                        n = e.ch,
                        r = e.ch;
                    if (t) {
                        var i = this.getHelper(e, "wordChars");
                        "before" != e.sticky && r != t.length || !n ? ++r : --n;
                        for (var o = t.charAt(n), a = te(o, i) ? function(e) {
                                return te(e, i)
                            } : /\s/.test(o) ? function(e) {
                                return /\s/.test(e)
                            } : function(e) {
                                return !/\s/.test(e) && !te(e)
                            }; 0 < n && a(t.charAt(n - 1));) --n;
                        for (; r < t.length && a(t.charAt(r));) ++r
                    }
                    return new Ei(lt(e.line, n), lt(e.line, r))
                },
                toggleOverwrite: function(e) {
                    null != e && e == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? I(this.display.cursorDiv, "CodeMirror-overwrite") : E(this.display.cursorDiv, "CodeMirror-overwrite"), Se(this, "overwriteToggle", this, this.state.overwrite))
                },
                hasFocus: function() {
                    return this.display.input.getField() == O()
                },
                isReadOnly: function() {
                    return !(!this.options.readOnly && !this.doc.cantEdit)
                },
                scrollTo: ii(function(e, t) {
                    kr(this, e, t)
                }),
                getScrollInfo: function() {
                    var e = this.display.scroller;
                    return {
                        left: e.scrollLeft,
                        top: e.scrollTop,
                        height: e.scrollHeight - On(this) - this.display.barHeight,
                        width: e.scrollWidth - On(this) - this.display.barWidth,
                        clientHeight: Dn(this),
                        clientWidth: In(this)
                    }
                },
                scrollIntoView: ii(function(e, t) {
                    null == e ? (e = {
                        from: this.doc.sel.primary().head,
                        to: null
                    }, null == t && (t = this.options.cursorScrollMargin)) : "number" == typeof e ? e = {
                        from: lt(e, 0),
                        to: null
                    } : null == e.from && (e = {
                        from: e,
                        to: null
                    }), e.to || (e.to = e.from), e.margin = t || 0, null != e.from.line ? function(e, t) {
                        zr(e), e.curOp.scrollToPos = t
                    }(this, e) : Fr(this, e.from, e.to, e.margin)
                }),
                setSize: ii(function(e, t) {
                    function n(e) {
                        return "number" == typeof e || /^\d+$/.test(String(e)) ? e + "px" : e
                    }
                    var r = this;
                    null != e && (this.display.wrapper.style.width = n(e)), null != t && (this.display.wrapper.style.height = n(t)), this.options.lineWrapping && jn(this);
                    var i = this.display.viewFrom;
                    this.doc.iter(i, this.display.viewTo, function(e) {
                        if (e.widgets)
                            for (var t = 0; t < e.widgets.length; t++)
                                if (e.widgets[t].noHScroll) {
                                    vr(r, i, "widget");
                                    break
                                }++i
                    }), this.curOp.forceUpdate = !0, Se(this, "refresh", this)
                }),
                operation: function(e) {
                    return ni(this, e)
                },
                startOperation: function() {
                    return Kr(this)
                },
                endOperation: function() {
                    return Jr(this)
                },
                refresh: ii(function() {
                    var e = this.display.cachedTextHeight;
                    mr(this), this.curOp.forceUpdate = !0, qn(this), kr(this, this.doc.scrollLeft, this.doc.scrollTop), di(this.display), (null == e || .5 < Math.abs(e - sr(this.display))) && dr(this), Se(this, "refresh", this)
                }),
                swapDoc: ii(function(e) {
                    var t = this.doc;
                    return t.cm = null, this.state.selectingText && this.state.selectingText(), Fi(this, e), qn(this), this.display.input.reset(), kr(this, e.scrollLeft, e.scrollTop), this.curOp.forceScroll = !0, mn(this, "swapDoc", this, t), t
                }),
                phrase: function(e) {
                    var t = this.options.phrases;
                    return t && Object.prototype.hasOwnProperty.call(t, e) ? t[e] : e
                },
                getInputField: function() {
                    return this.display.input.getField()
                },
                getWrapperElement: function() {
                    return this.display.wrapper
                },
                getScrollerElement: function() {
                    return this.display.scroller
                },
                getGutterElement: function() {
                    return this.display.gutters
                }
            }, Ce(Ja), Ja.registerHelper = function(e, t, n) {
                $a.hasOwnProperty(e) || ($a[e] = Ja[e] = {
                    _global: []
                }), $a[e][t] = n
            }, Ja.registerGlobalHelper = function(e, t, n, r) {
                Ja.registerHelper(e, t, r), $a[e]._global.push({
                    pred: n,
                    val: r
                })
            };
            var ts, ns = "iter insert remove copy getEditor constructor".split(" ");
            for (var rs in Do.prototype) Do.prototype.hasOwnProperty(rs) && U(ns, rs) < 0 && (Ra.prototype[rs] = function(e) {
                return function() {
                    return e.apply(this.doc, arguments)
                }
            }(Do.prototype[rs]));
            return Ce(Do), Ra.inputStyles = {
                textarea: Ya,
                contenteditable: Va
            }, Ra.defineMode = function(e) {
                Ra.defaults.mode || "null" == e || (Ra.defaults.mode = e),
                    function(e, t) {
                        2 < arguments.length && (t.dependencies = Array.prototype.slice.call(arguments, 2)), We[e] = t
                    }.apply(this, arguments)
            }, Ra.defineMIME = function(e, t) {
                je[e] = t
            }, Ra.defineMode("null", function() {
                return {
                    token: function(e) {
                        return e.skipToEnd()
                    }
                }
            }), Ra.defineMIME("text/plain", "null"), Ra.defineExtension = function(e, t) {
                Ra.prototype[e] = t
            }, Ra.defineDocExtension = function(e, t) {
                Do.prototype[e] = t
            }, Ra.fromTextArea = function(t, n) {
                if ((n = n ? z(n) : {}).value = t.value, !n.tabindex && t.tabIndex && (n.tabindex = t.tabIndex), !n.placeholder && t.placeholder && (n.placeholder = t.placeholder), null == n.autofocus) {
                    var e = O();
                    n.autofocus = e == t || null != t.getAttribute("autofocus") && e == document.body
                }

                function r() {
                    t.value = s.getValue()
                }
                var i;
                if (t.form && (be(t.form, "submit", r), !n.leaveSubmitMethodAlone)) {
                    var o = t.form;
                    i = o.submit;
                    try {
                        var a = o.submit = function() {
                            r(), o.submit = i, o.submit(), o.submit = a
                        }
                    } catch (e) {}
                }
                n.finishInit = function(e) {
                    e.save = r, e.getTextArea = function() {
                        return t
                    }, e.toTextArea = function() {
                        e.toTextArea = isNaN, r(), t.parentNode.removeChild(e.getWrapperElement()), t.style.display = "", t.form && (we(t.form, "submit", r), n.leaveSubmitMethodAlone || "function" != typeof t.form.submit || (t.form.submit = i))
                    }
                }, t.style.display = "none";
                var s = Ra(function(e) {
                    return t.parentNode.insertBefore(e, t.nextSibling)
                }, n);
                return s
            }, (ts = Ra).off = we, ts.on = be, ts.wheelEventPixels = Si, ts.Doc = Do, ts.splitLines = Ue, ts.countColumn = F, ts.findColumn = q, ts.isWordChar = ee, ts.Pass = G, ts.signal = Se, ts.Line = en, ts.changeEnd = Ai, ts.scrollbarModel = Xr, ts.Pos = lt, ts.cmpPos = ct, ts.modes = We, ts.mimeModes = je, ts.resolveMode = qe, ts.getMode = Xe, ts.modeExtensions = Ye, ts.extendMode = Ze, ts.copyState = Ke, ts.startState = Qe, ts.innerMode = Je, ts.commands = ia, ts.keyMap = qo, ts.keyName = Qo, ts.isModifierKey = Ko, ts.lookupKey = Zo, ts.normalizeKeyMap = Yo, ts.StringStream = $e, ts.SharedTextMarker = Ro, ts.TextMarker = Lo, ts.LineWidget = To, ts.e_preventDefault = Le, ts.e_stopPropagation = Ae, ts.e_stop = Pe, ts.addClass = I, ts.contains = P, ts.rmClass = E, ts.keyNames = Go, Ra.version = "5.49.2", Ra
        }, "object" == typeof n && void 0 !== t ? t.exports = i() : "function" == typeof define && define.amd ? define(i) : r.CodeMirror = i()
    }, {}],
    6: [function(e, t, n) {
        var r;
        r = function(R) {
            "use strict";

            function P(e, t, n, r, i, o) {
                this.indented = e, this.column = t, this.type = n, this.info = r, this.align = i, this.prev = o
            }

            function O(e, t, n, r) {
                var i = e.indented;
                return e.context && "statement" == e.context.type && "statement" != n && (i = e.context.indented), e.context = new P(i, t, n, r, null, e.context)
            }

            function I(e) {
                var t = e.context.type;
                return ")" != t && "]" != t && "}" != t || (e.indented = e.context.indented), e.context = e.context.prev
            }

            function D(e, t, n) {
                return "variable" == t.prevToken || "type" == t.prevToken || (!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0, n)) || (!(!t.typeAtEndOfLine || e.column() != e.indentation()) || void 0))
            }

            function N(e) {
                for (;;) {
                    if (!e || "top" == e.type) return !0;
                    if ("}" == e.type && "namespace" != e.prev.info) return !1;
                    e = e.prev
                }
            }

            function e(e) {
                for (var t = {}, n = e.split(" "), r = 0; r < n.length; ++r) t[n[r]] = !0;
                return t
            }

            function k(e, t) {
                return "function" == typeof e ? e(t) : e.propertyIsEnumerable(t)
            }
            R.defineMode("clike", function(e, s) {
                var o, a, l = e.indentUnit,
                    c = s.statementIndentUnit || l,
                    u = s.dontAlignCalls,
                    h = s.keywords || {},
                    d = s.types || {},
                    p = s.builtin || {},
                    f = s.blockKeywords || {},
                    m = s.defKeywords || {},
                    v = s.atoms || {},
                    g = s.hooks || {},
                    y = s.multiLineStrings,
                    x = !1 !== s.indentStatements,
                    t = !1 !== s.indentSwitch,
                    b = s.namespaceSeparator,
                    _ = s.isPunctuationChar || /[\[\]{}\(\),;\:\.]/,
                    w = s.numberStart || /[\d\.]/,
                    S = s.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,
                    M = s.isOperatorChar || /[+\-*&%=<>!?|\/]/,
                    T = s.isIdentifierChar || /[\w\$_\xa1-\uffff]/,
                    E = s.isReservedIdentifier || !1;

                function C(e, t) {
                    var n = e.next();
                    if (g[n]) {
                        var r = g[n](e, t);
                        if (!1 !== r) return r
                    }
                    if ('"' == n || "'" == n) return t.tokenize = function(o) {
                        return function(e, t) {
                            for (var n, r = !1, i = !1; null != (n = e.next());) {
                                if (n == o && !r) {
                                    i = !0;
                                    break
                                }
                                r = !r && "\\" == n
                            }
                            return !i && (r || y) || (t.tokenize = null), "string"
                        }
                    }(n), t.tokenize(e, t);
                    if (_.test(n)) return o = n, null;
                    if (w.test(n)) {
                        if (e.backUp(1), e.match(S)) return "number";
                        e.next()
                    }
                    if ("/" == n) {
                        if (e.eat("*")) return (t.tokenize = L)(e, t);
                        if (e.eat("/")) return e.skipToEnd(), "comment"
                    }
                    if (M.test(n)) {
                        for (; !e.match(/^\/[\/*]/, !1) && e.eat(M););
                        return "operator"
                    }
                    if (e.eatWhile(T), b)
                        for (; e.match(b);) e.eatWhile(T);
                    var i = e.current();
                    return k(h, i) ? (k(f, i) && (o = "newstatement"), k(m, i) && (a = !0), "keyword") : k(d, i) ? "type" : k(p, i) || E && E(i) ? (k(f, i) && (o = "newstatement"), "builtin") : k(v, i) ? "atom" : "variable"
                }

                function L(e, t) {
                    for (var n, r = !1; n = e.next();) {
                        if ("/" == n && r) {
                            t.tokenize = null;
                            break
                        }
                        r = "*" == n
                    }
                    return "comment"
                }

                function A(e, t) {
                    s.typeFirstDefinitions && e.eol() && N(t.context) && (t.typeAtEndOfLine = D(e, t, e.pos))
                }
                return {
                    startState: function(e) {
                        return {
                            tokenize: null,
                            context: new P((e || 0) - l, 0, "top", null, !1),
                            indented: 0,
                            startOfLine: !0,
                            prevToken: null
                        }
                    },
                    token: function(e, t) {
                        var n = t.context;
                        if (e.sol() && (null == n.align && (n.align = !1), t.indented = e.indentation(), t.startOfLine = !0), e.eatSpace()) return A(e, t), null;
                        o = a = null;
                        var r = (t.tokenize || C)(e, t);
                        if ("comment" == r || "meta" == r) return r;
                        if (null == n.align && (n.align = !0), ";" == o || ":" == o || "," == o && e.match(/^\s*(?:\/\/.*)?$/, !1))
                            for (;
                                "statement" == t.context.type;) I(t);
                        else if ("{" == o) O(t, e.column(), "}");
                        else if ("[" == o) O(t, e.column(), "]");
                        else if ("(" == o) O(t, e.column(), ")");
                        else if ("}" == o) {
                            for (;
                                "statement" == n.type;) n = I(t);
                            for ("}" == n.type && (n = I(t));
                                "statement" == n.type;) n = I(t)
                        } else o == n.type ? I(t) : x && (("}" == n.type || "top" == n.type) && ";" != o || "statement" == n.type && "newstatement" == o) && O(t, e.column(), "statement", e.current());
                        if ("variable" == r && ("def" == t.prevToken || s.typeFirstDefinitions && D(e, t, e.start) && N(t.context) && e.match(/^\s*\(/, !1)) && (r = "def"), g.token) {
                            var i = g.token(e, t, r);
                            void 0 !== i && (r = i)
                        }
                        return "def" == r && !1 === s.styleDefs && (r = "variable"), t.startOfLine = !1, t.prevToken = a ? "def" : r || o, A(e, t), r
                    },
                    indent: function(e, t) {
                        if (e.tokenize != C && null != e.tokenize || e.typeAtEndOfLine) return R.Pass;
                        var n = e.context,
                            r = t && t.charAt(0),
                            i = r == n.type;
                        if ("statement" == n.type && "}" == r && (n = n.prev), s.dontIndentStatements)
                            for (;
                                "statement" == n.type && s.dontIndentStatements.test(n.info);) n = n.prev;
                        if (g.indent) {
                            var o = g.indent(e, n, t, l);
                            if ("number" == typeof o) return o
                        }
                        var a = n.prev && "switch" == n.prev.info;
                        if (s.allmanIndentation && /[{(]/.test(r)) {
                            for (;
                                "top" != n.type && "}" != n.type;) n = n.prev;
                            return n.indented
                        }
                        return "statement" == n.type ? n.indented + ("{" == r ? 0 : c) : !n.align || u && ")" == n.type ? ")" != n.type || i ? n.indented + (i ? 0 : l) + (i || !a || /^(?:case|default)\b/.test(t) ? 0 : l) : n.indented + c : n.column + (i ? 0 : 1)
                    },
                    electricInput: t ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
                    blockCommentStart: "/*",
                    blockCommentEnd: "*/",
                    blockCommentContinue: " * ",
                    lineComment: "//",
                    fold: "brace"
                }
            });
            var t = "auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile inline restrict asm fortran",
                n = "alignas alignof and and_eq audit axiom bitand bitor catch class compl concept constexpr const_cast decltype delete dynamic_cast explicit export final friend import module mutable namespace new noexcept not not_eq operator or or_eq override private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw try typeid typename using virtual xor xor_eq",
                r = "bycopy byref in inout oneway out self super atomic nonatomic retain copy readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd @interface @implementation @end @protocol @encode @property @synthesize @dynamic @class @public @package @private @protected @required @optional @try @catch @finally @import @selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available",
                i = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION  NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT",
                o = e("int long char short double float unsigned signed void bool"),
                a = e("SEL instancetype id Class Protocol BOOL");

            function s(e) {
                return k(o, e) || /.+_t$/.test(e)
            }

            function l(e) {
                return s(e) || k(a, e)
            }
            var c = "case do else for if switch while struct enum union",
                u = "struct enum union";

            function h(e, t) {
                if (!t.startOfLine) return !1;
                for (var n, r = null; n = e.peek();) {
                    if ("\\" == n && e.match(/^.$/)) {
                        r = h;
                        break
                    }
                    if ("/" == n && e.match(/^\/[\/\*]/, !1)) break;
                    e.next()
                }
                return t.tokenize = r, "meta"
            }

            function d(e, t) {
                return "type" == t.prevToken && "type"
            }

            function p(e) {
                return !(!e || e.length < 2) && ("_" == e[0] && ("_" == e[1] || e[1] !== e[1].toLowerCase()))
            }

            function f(e) {
                return e.eatWhile(/[\w\.']/), "number"
            }

            function m(e, t) {
                if (e.backUp(1), e.match(/(R|u8R|uR|UR|LR)/)) {
                    var n = e.match(/"([^\s\\()]{0,16})\(/);
                    return !!n && (t.cpp11RawStringDelim = n[1], (t.tokenize = y)(e, t))
                }
                return e.match(/(u8|u|U|L)/) ? !!e.match(/["']/, !1) && "string" : (e.next(), !1)
            }

            function v(e) {
                var t = /(\w+)::~?(\w+)$/.exec(e);
                return t && t[1] == t[2]
            }

            function g(e, t) {
                for (var n; null != (n = e.next());)
                    if ('"' == n && !e.eat('"')) {
                        t.tokenize = null;
                        break
                    }
                return "string"
            }

            function y(e, t) {
                var n = t.cpp11RawStringDelim.replace(/[^\w\s]/g, "\\$&");
                return e.match(new RegExp(".*?\\)" + n + '"')) ? t.tokenize = null : e.skipToEnd(), "string"
            }

            function x(e, t) {
                "string" == typeof e && (e = [e]);
                var n = [];

                function r(e) {
                    if (e)
                        for (var t in e) e.hasOwnProperty(t) && n.push(t)
                }
                r(t.keywords), r(t.types), r(t.builtin), r(t.atoms), n.length && (t.helperType = e[0], R.registerHelper("hintWords", e[0], n));
                for (var i = 0; i < e.length; ++i) R.defineMIME(e[i], t)
            }

            function b(e, t) {
                for (var n = !1; !e.eol();) {
                    if (!n && e.match('"""')) {
                        t.tokenize = null;
                        break
                    }
                    n = "\\" == e.next() && !n
                }
                return "string"
            }

            function _(r) {
                return function(e, t) {
                    for (var n; n = e.next();) {
                        if ("*" == n && e.eat("/")) {
                            if (1 != r) return t.tokenize = _(r - 1), t.tokenize(e, t);
                            t.tokenize = null;
                            break
                        }
                        if ("/" == n && e.eat("*")) return t.tokenize = _(r + 1), t.tokenize(e, t)
                    }
                    return "comment"
                }
            }
            x(["text/x-csrc", "text/x-c", "text/x-chdr"], {
                name: "clike",
                keywords: e(t),
                types: s,
                blockKeywords: e(c),
                defKeywords: e(u),
                typeFirstDefinitions: !0,
                atoms: e("NULL true false"),
                isReservedIdentifier: p,
                hooks: {
                    "#": h,
                    "*": d
                },
                modeProps: {
                    fold: ["brace", "include"]
                }
            }), x(["text/x-c++src", "text/x-c++hdr"], {
                name: "clike",
                keywords: e(t + " " + n),
                types: s,
                blockKeywords: e(c + " class try catch"),
                defKeywords: e(u + " class namespace"),
                typeFirstDefinitions: !0,
                atoms: e("true false NULL nullptr"),
                dontIndentStatements: /^template$/,
                isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
                isReservedIdentifier: p,
                hooks: {
                    "#": h,
                    "*": d,
                    u: m,
                    U: m,
                    L: m,
                    R: m,
                    0: f,
                    1: f,
                    2: f,
                    3: f,
                    4: f,
                    5: f,
                    6: f,
                    7: f,
                    8: f,
                    9: f,
                    token: function(e, t, n) {
                        if ("variable" == n && "(" == e.peek() && (";" == t.prevToken || null == t.prevToken || "}" == t.prevToken) && v(e.current())) return "def"
                    }
                },
                namespaceSeparator: "::",
                modeProps: {
                    fold: ["brace", "include"]
                }
            }), x("text/x-java", {
                name: "clike",
                keywords: e("abstract assert break case catch class const continue default do else enum extends final finally for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),
                types: e("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),
                blockKeywords: e("catch class do else finally for if switch try while"),
                defKeywords: e("class interface enum @interface"),
                typeFirstDefinitions: !0,
                atoms: e("true false null"),
                number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
                hooks: {
                    "@": function(e) {
                        return !e.match("interface", !1) && (e.eatWhile(/[\w\$_]/), "meta")
                    }
                },
                modeProps: {
                    fold: ["brace", "import"]
                }
            }), x("text/x-csharp", {
                name: "clike",
                keywords: e("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),
                types: e("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),
                blockKeywords: e("catch class do else finally for foreach if struct switch try while"),
                defKeywords: e("class interface namespace struct var"),
                typeFirstDefinitions: !0,
                atoms: e("true false null"),
                hooks: {
                    "@": function(e, t) {
                        return e.eat('"') ? (t.tokenize = g)(e, t) : (e.eatWhile(/[\w\$_]/), "meta")
                    }
                }
            }), x("text/x-scala", {
                name: "clike",
                keywords: e("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),
                types: e("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),
                multiLineStrings: !0,
                blockKeywords: e("catch class enum do else finally for forSome if match switch try while"),
                defKeywords: e("class enum def object package trait type val var"),
                atoms: e("true false null"),
                indentStatements: !1,
                indentSwitch: !1,
                isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
                hooks: {
                    "@": function(e) {
                        return e.eatWhile(/[\w\$_]/), "meta"
                    },
                    '"': function(e, t) {
                        return !!e.match('""') && (t.tokenize = b, t.tokenize(e, t))
                    },
                    "'": function(e) {
                        return e.eatWhile(/[\w\$_\xa1-\uffff]/), "atom"
                    },
                    "=": function(e, t) {
                        var n = t.context;
                        return !("}" != n.type || !n.align || !e.eat(">")) && (t.context = new P(n.indented, n.column, n.type, n.info, null, n.prev), "operator")
                    },
                    "/": function(e, t) {
                        return !!e.eat("*") && (t.tokenize = _(1), t.tokenize(e, t))
                    }
                },
                modeProps: {
                    closeBrackets: {
                        pairs: '()[]{}""',
                        triples: '"'
                    }
                }
            }), x("text/x-kotlin", {
                name: "clike",
                keywords: e("package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam"),
                types: e("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"),
                intendSwitch: !1,
                indentStatements: !1,
                multiLineStrings: !0,
                number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
                blockKeywords: e("catch class do else finally for if where try while enum"),
                defKeywords: e("class val var object interface fun"),
                atoms: e("true false null this"),
                hooks: {
                    "@": function(e) {
                        return e.eatWhile(/[\w\$_]/), "meta"
                    },
                    "*": function(e, t) {
                        return "." == t.prevToken ? "variable" : "operator"
                    },
                    '"': function(e, t) {
                        return t.tokenize = function(o) {
                            return function(e, t) {
                                for (var n, r = !1, i = !1; !e.eol();) {
                                    if (!o && !r && e.match('"')) {
                                        i = !0;
                                        break
                                    }
                                    if (o && e.match('"""')) {
                                        i = !0;
                                        break
                                    }
                                    n = e.next(), !r && "$" == n && e.match("{") && e.skipTo("}"), r = !r && "\\" == n && !o
                                }
                                return !i && o || (t.tokenize = null), "string"
                            }
                        }(e.match('""')), t.tokenize(e, t)
                    },
                    "/": function(e, t) {
                        return !!e.eat("*") && (t.tokenize = _(1), t.tokenize(e, t))
                    },
                    indent: function(e, t, n, r) {
                        var i = n && n.charAt(0);
                        return "}" != e.prevToken && ")" != e.prevToken || "" != n ? "operator" == e.prevToken && "}" != n && "}" != e.context.type || "variable" == e.prevToken && "." == i || ("}" == e.prevToken || ")" == e.prevToken) && "." == i ? 2 * r + t.indented : t.align && "}" == t.type ? t.indented + (e.context.type == (n || "").charAt(0) ? 0 : r) : void 0 : e.indented
                    }
                },
                modeProps: {
                    closeBrackets: {
                        triples: '"'
                    }
                }
            }), x(["x-shader/x-vertex", "x-shader/x-fragment"], {
                name: "clike",
                keywords: e("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),
                types: e("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),
                blockKeywords: e("for while do if else struct"),
                builtin: e("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),
                atoms: e("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),
                indentSwitch: !1,
                hooks: {
                    "#": h
                },
                modeProps: {
                    fold: ["brace", "include"]
                }
            }), x("text/x-nesc", {
                name: "clike",
                keywords: e(t + " as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),
                types: s,
                blockKeywords: e(c),
                atoms: e("null true false"),
                hooks: {
                    "#": h
                },
                modeProps: {
                    fold: ["brace", "include"]
                }
            }), x("text/x-objectivec", {
                name: "clike",
                keywords: e(t + " " + r),
                types: l,
                builtin: e(i),
                blockKeywords: e(c + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
                defKeywords: e(u + " @interface @implementation @protocol @class"),
                dontIndentStatements: /^@.*$/,
                typeFirstDefinitions: !0,
                atoms: e("YES NO NULL Nil nil true false nullptr"),
                isReservedIdentifier: p,
                hooks: {
                    "#": h,
                    "*": d
                },
                modeProps: {
                    fold: ["brace", "include"]
                }
            }), x("text/x-objectivec++", {
                name: "clike",
                keywords: e(t + " " + r + " " + n),
                types: l,
                builtin: e(i),
                blockKeywords: e(c + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
                defKeywords: e(u + " @interface @implementation @protocol @class class namespace"),
                dontIndentStatements: /^@.*$|^template$/,
                typeFirstDefinitions: !0,
                atoms: e("YES NO NULL Nil nil true false nullptr"),
                isReservedIdentifier: p,
                hooks: {
                    "#": h,
                    "*": d,
                    u: m,
                    U: m,
                    L: m,
                    R: m,
                    0: f,
                    1: f,
                    2: f,
                    3: f,
                    4: f,
                    5: f,
                    6: f,
                    7: f,
                    8: f,
                    9: f,
                    token: function(e, t, n) {
                        if ("variable" == n && "(" == e.peek() && (";" == t.prevToken || null == t.prevToken || "}" == t.prevToken) && v(e.current())) return "def"
                    }
                },
                namespaceSeparator: "::",
                modeProps: {
                    fold: ["brace", "include"]
                }
            }), x("text/x-squirrel", {
                name: "clike",
                keywords: e("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),
                types: s,
                blockKeywords: e("case catch class else for foreach if switch try while"),
                defKeywords: e("function local class"),
                typeFirstDefinitions: !0,
                atoms: e("true false null"),
                hooks: {
                    "#": h
                },
                modeProps: {
                    fold: ["brace", "include"]
                }
            });
            var w = null;
            x("text/x-ceylon", {
                name: "clike",
                keywords: e("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),
                types: function(e) {
                    var t = e.charAt(0);
                    return t === t.toUpperCase() && t !== t.toLowerCase()
                },
                blockKeywords: e("case catch class dynamic else finally for function if interface module new object switch try while"),
                defKeywords: e("class dynamic function interface module object package value"),
                builtin: e("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),
                isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
                isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
                numberStart: /[\d#$]/,
                number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
                multiLineStrings: !0,
                typeFirstDefinitions: !0,
                atoms: e("true false null larger smaller equal empty finished"),
                indentSwitch: !1,
                styleDefs: !1,
                hooks: {
                    "@": function(e) {
                        return e.eatWhile(/[\w\$_]/), "meta"
                    },
                    '"': function(e, t) {
                        return t.tokenize = function o(a) {
                            return function(e, t) {
                                for (var n, r = !1, i = !1; !e.eol();) {
                                    if (!r && e.match('"') && ("single" == a || e.match('""'))) {
                                        i = !0;
                                        break
                                    }
                                    if (!r && e.match("``")) {
                                        w = o(a), i = !0;
                                        break
                                    }
                                    n = e.next(), r = "single" == a && !r && "\\" == n
                                }
                                return i && (t.tokenize = null), "string"
                            }
                        }(e.match('""') ? "triple" : "single"), t.tokenize(e, t)
                    },
                    "`": function(e, t) {
                        return !(!w || !e.match("`")) && (t.tokenize = w, w = null, t.tokenize(e, t))
                    },
                    "'": function(e) {
                        return e.eatWhile(/[\w\$_\xa1-\uffff]/), "atom"
                    },
                    token: function(e, t, n) {
                        if (("variable" == n || "type" == n) && "." == t.prevToken) return "variable-2"
                    }
                },
                modeProps: {
                    fold: ["brace", "import"],
                    closeBrackets: {
                        triples: '"'
                    }
                }
            })
        }, "object" == typeof n && "object" == typeof t ? r(e("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], r) : r(CodeMirror)
    }, {
        "../../lib/codemirror": 5
    }],
    7: [function(e, t, n) {
        t.exports = function(e, t, n, r) {
            if (r = (n = window.getComputedStyle) ? n(e) : e.currentStyle) return r[t.replace(/-(\w)/gi, function(e, t) {
                return t.toUpperCase()
            })]
        }
    }, {}],
    8: [function(e, t, n) {
        t.exports = function(e) {
            "string" == typeof e && (e = [e]);
            for (var t = [].slice.call(arguments, 1), n = [], r = 0; r < e.length - 1; r++) n.push(e[r], t[r] || "");
            return n.push(e[r]), n.join("")
        }
    }, {}],
    9: [function(e, t, n) {
        var r, i;
        r = this, i = function(e) {
            "use strict";

            function n(e, t) {
                e.prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t
            }

            function w(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function F(e) {
                return "string" == typeof e
            }

            function p(e) {
                return "function" == typeof e
            }

            function S(e) {
                return "number" == typeof e
            }

            function r(e) {
                return void 0 === e
            }

            function M(e) {
                return "object" == typeof e
            }

            function D(e) {
                return !1 !== e
            }

            function t() {
                return "undefined" != typeof window
            }

            function T(e) {
                return p(e) || F(e)
            }

            function i(e) {
                return (We = $e(e, Ve)) && Kt
            }

            function B(e, t) {
                return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
            }

            function E(e, t) {
                return !t && console.warn(e)
            }

            function a(e, t) {
                return e && (Ve[e] = t) && We && (We[e] = t) || Ve
            }

            function C() {
                return 0
            }

            function N(e) {
                var t, n, r = e[0];
                if (M(r) || p(r) || (e = [e]), !(t = (r._gsap || {}).harness)) {
                    for (n = Je.length; n-- && !Je[n].targetTest(r););
                    t = Je[n]
                }
                for (n = e.length; n--;) e[n] && (e[n]._gsap || (e[n]._gsap = new bt(e[n], t))) || e.splice(n, 1);
                return e
            }

            function k(e) {
                return e._gsap || N(it(e))[0]._gsap
            }

            function o(e, t) {
                var n = e[t];
                return p(n) ? e[t]() : r(n) && e.getAttribute(t) || n
            }

            function f(e, t) {
                return (e = e.split(",")).forEach(t) || e
            }

            function U(e) {
                return Math.round(1e4 * e) / 1e4
            }

            function s(e, t) {
                for (var n = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < n;);
                return r < n
            }

            function l(e, t, n) {
                var r, i = S(e[1]),
                    o = (i ? 2 : 1) + (t < 2 ? 0 : 1),
                    a = e[o];
                return i && (a.duration = e[1]), 1 === t ? (a.runBackwards = 1, a.immediateRender = D(a.immediateRender)) : 2 === t && (r = e[o - 1], a.startAt = r, a.immediateRender = D(a.immediateRender)), a.parent = n, a
            }

            function z() {
                var e, t, n = qe.length,
                    r = qe.slice(0);
                for (Xe = {}, e = qe.length = 0; e < n; e++)(t = r[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
            }

            function c(e, t, n, r) {
                qe.length && z(), e.render(t, n, r), qe.length && z()
            }

            function u(e) {
                var t = parseFloat(e);
                return t || 0 === t ? t : e
            }

            function h(e) {
                return e
            }

            function H(e, t) {
                for (var n in t) n in e || (e[n] = t[n]);
                return e
            }

            function L(e, t) {
                for (var n in t) n in e || "duration" === n || "ease" === n || (e[n] = t[n])
            }

            function d(e, t) {
                for (var n in t) e[n] = M(t[n]) ? d(e[n] || (e[n] = {}), t[n]) : t[n];
                return e
            }

            function G(e, t) {
                var n, r = {};
                for (n in e) n in t || (r[n] = e[n]);
                return r
            }

            function m(e, t, n, r) {
                void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                var i = t._prev,
                    o = t._next;
                i ? i._next = o : e[n] === t && (e[n] = o), o ? o._prev = i : e[r] === t && (e[r] = i), t._dp = e, t._next = t._prev = t.parent = null
            }

            function V(e, t) {
                !e.parent || t && !e.parent.autoRemoveChildren || e.parent.remove(e), e._act = 0
            }

            function v(e) {
                for (var t = e; t;) t._dirty = 1, t = t.parent;
                return e
            }

            function g(e) {
                return e._repeat ? et(e._tTime, e = e.duration() + e._rDelay) * e : 0
            }

            function y(e, t) {
                return (e - t._start) * t._ts + (0 < t._ts ? 0 : t._dirty ? t.totalDuration() : t._tDur)
            }

            function x(e, t, n) {
                if (t.parent && V(t), t._start = n + t._delay, t._end = t._start + (t.totalDuration() / t._ts || 0), function(e, t, n, r, i) {
                        void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                        var o, a = e[r];
                        if (i)
                            for (o = t[i]; a && a[i] > o;) a = a._prev;
                        a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[r] = t, t._prev = a, t.parent = e
                    }(e, t, "_first", "_last", e._sort ? "_start" : 0), (e._recent = t)._time || !t._dur && t._initted) {
                    var r = (e.rawTime() - t._start) * t._ts;
                    (!t._dur || nt(0, t.totalDuration(), r) - t._tTime > Ae) && t.render(r, !0)
                }
                if (v(e), e._dp && e._time >= e._dur && e._ts && e._dur < e.duration())
                    for (var i = e; i._dp;) i.totalTime(i._tTime, !0), i = i._dp;
                return e
            }

            function b(e, t, n, r) {
                return Ct(e, t), e._initted ? !n && e._pt && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && he !== ut.frame ? (qe.push(e), e._lazy = [t, r], 1) : void 0 : 1
            }

            function _(e) {
                if (e instanceof St) return v(e);
                var t = e._repeat;
                return e._tDur = t ? t < 0 ? 1e12 : U(e._dur * (t + 1) + e._rDelay * t) : e._dur, v(e.parent), e
            }

            function A(e, t) {
                var n, r, i = e.labels,
                    o = e._recent || tt,
                    a = 1e8 <= e.duration() ? o.endTime(!1) : e._dur;
                return F(t) && (isNaN(t) || t in i) ? "<" === (n = t.charAt(0)) || ">" === n ? ("<" === n ? o._start : o.endTime(0 <= o._repeat)) + (parseFloat(t.substr(1)) || 0) : (n = t.indexOf("=")) < 0 ? (t in i || (i[t] = a), i[t]) : (r = +(t.charAt(n - 1) + t.substr(n + 1)), 1 < n ? A(e, t.substr(0, n - 1)) + r : a + r) : null == t ? a : +t
            }

            function R(e, t) {
                return e || 0 === e ? t(e) : t
            }

            function P(e) {
                return (e + "").substr((parseFloat(e) + "").length)
            }

            function O(e) {
                return e && M(e) && "length" in e && (!e.length || e.length - 1 in e && M(e[0])) && !e.nodeType && e !== se
            }

            function I(e) {
                if (p(e)) return e;
                var f = M(e) ? e : {
                        each: e
                    },
                    m = vt(f.ease),
                    v = f.from || 0,
                    g = parseFloat(f.base) || 0,
                    y = {},
                    t = 0 < v && v < 1,
                    x = isNaN(v) || t,
                    b = f.axis,
                    _ = v,
                    w = v;
                return F(v) ? _ = w = {
                        center: .5,
                        edges: .5,
                        end: 1
                    }[v] || 0 : !t && x && (_ = v[0], w = v[1]),
                    function(e, t, n) {
                        var r, i, o, a, s, l, c, u, h, d = (n || f).length,
                            p = y[d];
                        if (!p) {
                            if (!(h = "auto" === f.grid ? 0 : (f.grid || [1, 1e8])[1])) {
                                for (c = -1e8; c < (c = n[h++].getBoundingClientRect().left) && h < d;);
                                h--
                            }
                            for (p = y[d] = [], r = x ? Math.min(h, d) * _ - .5 : v % h, i = x ? d * w / h - .5 : v / h | 0, u = 1e8, l = c = 0; l < d; l++) o = l % h - r, a = i - (l / h | 0), p[l] = s = b ? Math.abs("y" === b ? a : o) : Ie(o * o + a * a), c < s && (c = s), s < u && (u = s);
                            p.max = c - u, p.min = u, p.v = d = (parseFloat(f.amount) || parseFloat(f.each) * (d < h ? d - 1 : b ? "y" === b ? d / h : h : Math.max(h, d / h)) || 0) * ("edges" === v ? -1 : 1), p.b = d < 0 ? g - d : g, p.u = P(f.amount || f.each) || 0, m = m && d < 0 ? mt(m) : m
                        }
                        return d = (p[e] - p.min) / p.max || 0, U(p.b + (m ? m(d) : d) * p.v) + p.u
                    }
            }

            function W(t) {
                var n = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                return function(e) {
                    return ~~(Math.round(parseFloat(e) / t) * t * n) / n + (S(e) ? 0 : P(e))
                }
            }

            function j(l, e) {
                var c, u, t = ke(l);
                return !t && M(l) && (c = t = l.radius || 1e8, l.values ? (l = it(l.values), (u = !S(l[0])) && (c *= c)) : l = W(l.increment)), R(e, t ? p(l) ? function(e) {
                    return u = l(e), Math.abs(u - e) <= c ? u : e
                } : function(e) {
                    for (var t, n, r = parseFloat(u ? e.x : e), i = parseFloat(u ? e.y : 0), o = 1e8, a = 0, s = l.length; s--;)(t = u ? (t = l[s].x - r) * t + (n = l[s].y - i) * n : Math.abs(l[s] - r)) < o && (o = t, a = s);
                    return a = !c || o <= c ? l[a] : e, u || a === e || S(e) ? a : a + P(e)
                } : W(l))
            }

            function q(e, t, n, r) {
                return R(ke(e) ? !t : !0 === n ? !!(n = 0) : !r, function() {
                    return ke(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && ~~(Math.round((e + Math.random() * (t - e)) / n) * n * r) / r
                })
            }

            function X(t, n, e) {
                return R(e, function(e) {
                    return t[~~n(e)]
                })
            }

            function Y(e) {
                for (var t, n, r, i, o = 0, a = ""; ~(t = e.indexOf("random(", o));) r = e.indexOf(")", t), i = "[" === e.charAt(t + 7), n = e.substr(t + 7, r - t - 7).match(i ? Ge : ze), a += e.substr(o, t - o) + q(i ? n : +n[0], +n[1], +n[2] || 1e-5), o = r + 1;
                return a + e.substr(o, e.length - o)
            }

            function Z(e, t, n) {
                var r, i, o, a = e.labels,
                    s = 1e8;
                for (r in a)(i = a[r] - t) < 0 == !!n && i && s > (i = Math.abs(i)) && (o = r, s = i);
                return o
            }

            function K(e) {
                return V(e), e.progress() < 1 && at(e, "onInterrupt"), e
            }

            function J(e, t, n) {
                return 255 * (6 * (e = e < 0 ? e + 1 : 1 < e ? e - 1 : e) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) + .5 | 0
            }

            function Q(e, t) {
                var n, r, i, o, a, s, l, c, u, h, d = e ? S(e) ? [e >> 16, e >> 8 & 255, 255 & e] : 0 : st.black;
                if (!d) {
                    if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), st[e]) d = st[e];
                    else if ("#" === e.charAt(0)) 4 === e.length && (e = "#" + (n = e.charAt(1)) + n + (r = e.charAt(2)) + r + (i = e.charAt(3)) + i), d = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & 255, 255 & e];
                    else if ("hsl" === e.substr(0, 3))
                        if (d = h = e.match(ze), t) {
                            if (~e.indexOf("=")) return e.match(Fe)
                        } else o = +d[0] % 360 / 360, a = +d[1] / 100, n = 2 * (s = +d[2] / 100) - (r = s <= .5 ? s * (a + 1) : s + a - s * a), 3 < d.length && (d[3] *= 1), d[0] = J(o + 1 / 3, n, r), d[1] = J(o, n, r), d[2] = J(o - 1 / 3, n, r);
                    else d = e.match(ze) || st.transparent;
                    d = d.map(Number)
                }
                return t && !h && (n = d[0] / 255, r = d[1] / 255, i = d[2] / 255, s = ((l = Math.max(n, r, i)) + (c = Math.min(n, r, i))) / 2, l === c ? o = a = 0 : (u = l - c, a = .5 < s ? u / (2 - l - c) : u / (l + c), o = l === n ? (r - i) / u + (r < i ? 6 : 0) : l === r ? (i - n) / u + 2 : (n - r) / u + 4, o *= 60), d[0] = o + .5 | 0, d[1] = 100 * a + .5 | 0, d[2] = 100 * s + .5 | 0), d
            }

            function $(e, t) {
                var n, r, i, o = (e + "").match(lt),
                    a = 0,
                    s = "";
                if (!o) return e;
                for (n = 0; n < o.length; n++) r = o[n], a += (i = e.substr(a, e.indexOf(r, a) - a)).length + r.length, 3 === (r = Q(r, t)).length && r.push(1), s += i + (t ? "hsla(" + r[0] + "," + r[1] + "%," + r[2] + "%," + r[3] : "rgba(" + r.join(",")) + ")";
                return s + e.substr(a)
            }

            function ee(e) {
                var t, n = e.join(" ");
                lt.lastIndex = 0, lt.test(n) && (t = ct.test(n), e[0] = $(e[0], t), e[1] = $(e[1], t))
            }

            function te(e) {
                var t = (e + "").split("("),
                    n = dt[t[0]];
                return n && 1 < t.length && n.config ? n.config.apply(null, ~e.indexOf("{") ? [function(e) {
                    for (var t, n, r, i = {}, o = e.substr(1, e.length - 3).split(":"), a = o[0], s = 1, l = o.length; s < l; s++) n = o[s], t = s !== l - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, t), i[a] = isNaN(r) ? r.replace(ft, "").trim() : +r, a = n.substr(t + 1).trim();
                    return i
                }(t[1])] : Ue.exec(e)[1].split(",").map(u)) : dt._CE && pt.test(e) ? dt._CE("", e) : n
            }

            function ne(e, t, n, r) {
                void 0 === n && (n = function(e) {
                    return 1 - t(1 - e)
                }), void 0 === r && (r = function(e) {
                    return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
                });
                var i, o = {
                    easeIn: t,
                    easeOut: n,
                    easeInOut: r
                };
                return f(e, function(e) {
                    for (var t in dt[e] = Ve[e] = o, dt[i = e.toLowerCase()] = n, o) dt[i + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = dt[e + "." + t] = o[t]
                }), o
            }

            function re(t) {
                return function(e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            }

            function ie(n, e, t) {
                function r(e) {
                    return 1 === e ? 1 : i * Math.pow(2, -10 * e) * Ne((e - a) * o) + 1
                }
                var i = 1 <= e ? e : 1,
                    o = (t || (n ? .3 : .45)) / (e < 1 ? e : 1),
                    a = o / Re * (Math.asin(1 / i) || 0),
                    s = "out" === n ? r : "in" === n ? function(e) {
                        return 1 - r(1 - e)
                    } : re(r);
                return o = Re / o, s.config = function(e, t) {
                    return ie(n, e, t)
                }, s
            }

            function oe(t, n) {
                function r(e) {
                    return --e * e * ((n + 1) * e + n) + 1
                }
                void 0 === n && (n = 1.70158);
                var e = "out" === t ? r : "in" === t ? function(e) {
                    return 1 - r(1 - e)
                } : re(r);
                return e.config = function(e) {
                    return oe(t, e)
                }, e
            }
            var ae, se, le, ce, ue, he, de, pe, fe, me, ve, ge, ye, xe, be, _e, we, Se, Me, Te, Ee, Ce = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                Le = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                Ae = 1e-8,
                Re = 2 * Math.PI,
                Pe = Re / 4,
                Oe = 0,
                Ie = Math.sqrt,
                De = Math.cos,
                Ne = Math.sin,
                ke = Array.isArray,
                ze = /(?:-?\.?\d|\.)+/gi,
                Fe = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
                Be = /[-+=\.]*\d+(?:\.|e-|e)*\d*/gi,
                Ue = /\(([^()]+)\)/i,
                He = /[\+-]=-?[\.\d]+/,
                Ge = /[#\-+\.]*\b[a-z\d-=+%.]+/gi,
                Ve = {},
                We = {},
                je = {},
                qe = [],
                Xe = {},
                Ye = {},
                Ze = {},
                Ke = 30,
                Je = [],
                Qe = "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
                $e = function(e, t) {
                    for (var n in t) e[n] = t[n];
                    return e
                },
                et = function(e, t) {
                    return (e /= t) && ~~e === e ? ~~e - 1 : ~~e
                },
                tt = {
                    _start: 0,
                    endTime: C
                },
                nt = function(e, t, n) {
                    return n < e ? e : t < n ? t : n
                },
                rt = [].slice,
                it = function(e, t) {
                    return !F(e) || t || !le && ht() ? ke(e) ? function(e, n, r) {
                        return void 0 === r && (r = []), e.forEach(function(e) {
                            var t;
                            return F(e) && !n || O(e) ? (t = r).push.apply(t, it(e)) : r.push(e)
                        }) || r
                    }(e, t) : O(e) ? rt.call(e, 0) : e ? [e] : [] : rt.call(ce.querySelectorAll(e), 0)
                },
                ot = function(t, e, n, r, i) {
                    var o = e - t,
                        a = r - n;
                    return R(i, function(e) {
                        return n + (e - t) / o * a
                    })
                },
                at = function(e, t, n) {
                    var r, i, o = e.vars,
                        a = o[t];
                    if (a) return r = o[t + "Params"], i = o.callbackScope || e, n && qe.length && z(), r ? a.apply(i, r) : a.call(i)
                },
                st = {
                    aqua: [0, 255, 255],
                    lime: [0, 255, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, 255],
                    navy: [0, 0, 128],
                    white: [255, 255, 255],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    orange: [255, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [255, 0, 0],
                    pink: [255, 192, 203],
                    cyan: [0, 255, 255],
                    transparent: [255, 255, 255, 0]
                },
                lt = function() {
                    var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                    for (e in st) t += "|" + e + "\\b";
                    return new RegExp(t + ")", "gi")
                }(),
                ct = /hsl[a]?\(/,
                ut = (ye = Date.now, xe = 500, be = 33, _e = ye(), we = _e, Me = Se = 1 / 60, ge = {
                    time: 0,
                    frame: 0,
                    tick: function() {
                        gt(!0)
                    },
                    wake: function() {
                        ue && (!le && t() && (se = le = window, ce = se.document || {}, Ve.gsap = Kt, (se.gsapVersions || (se.gsapVersions = [])).push(Kt.version), i(We || se.GreenSockGlobals || !se.gsap && se || {}), ve = se.requestAnimationFrame), fe && ge.sleep(), me = ve || function(e) {
                            return setTimeout(e, 1e3 * (Me - ge.time) + 1 | 0)
                        }, pe = 1, gt(2))
                    },
                    sleep: function() {
                        (ve ? se.cancelAnimationFrame : clearTimeout)(fe), pe = 0, me = C
                    },
                    lagSmoothing: function(e, t) {
                        xe = e || 1e8, be = Math.min(t, xe, 0)
                    },
                    fps: function(e) {
                        Se = 1 / (e || 60), Me = ge.time + Se
                    },
                    add: function(e) {
                        Te.indexOf(e) < 0 && Te.push(e), ht()
                    },
                    remove: function(e) {
                        var t;
                        ~(t = Te.indexOf(e)) && Te.splice(t, 1)
                    },
                    _listeners: Te = []
                }),
                ht = function() {
                    return !pe && ut.wake()
                },
                dt = {},
                pt = /^[\d.\-M][\d.\-,\s]/,
                ft = /["']/g,
                mt = function(t) {
                    return function(e) {
                        return 1 - t(1 - e)
                    }
                },
                vt = function(e, t) {
                    return e && (p(e) ? e : dt[e] || te(e)) || t
                };

            function gt(t) {
                var e, n, r = ye() - we,
                    i = !0 === t;
                xe < r && (_e += r - be), we += r, ge.time = (we - _e) / 1e3, (0 < (e = ge.time - Me) || i) && (ge.frame++, Me += e + (Se <= e ? .004 : Se - e), n = 1), i || (fe = me(gt)), n && Te.forEach(function(e) {
                    return e(ge.time, r, ge.frame, t)
                })
            }

            function yt(e) {
                return e < 1 / 2.75 ? Ee * e * e : e < 1 / 2.75 * 2 ? Ee * Math.pow(e - 1.5 / 2.75, 2) + .75 : e < 1 / 2.75 * 2.5 ? Ee * (e -= 2.25 / 2.75) * e + .9375 : Ee * Math.pow(e - 2.625 / 2.75, 2) + .984375
            }
            f("Linear,Quad,Cubic,Quart,Quint,Strong", function(e, t) {
                var n = t < 5 ? t + 1 : t;
                ne(e + ",Power" + (n - 1), t ? function(e) {
                    return Math.pow(e, n)
                } : function(e) {
                    return e
                }, function(e) {
                    return 1 - Math.pow(1 - e, n)
                }, function(e) {
                    return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2
                })
            }), dt.Linear.easeNone = dt.none = dt.Linear.easeIn, ne("Elastic", ie("in"), ie("out"), ie()), Ee = 7.5625, ne("Bounce", function(e) {
                return 1 - yt(1 - e)
            }, yt), ne("Expo", function(e) {
                return e ? Math.pow(2, 10 * (e - 1)) : 0
            }), ne("Circ", function(e) {
                return -(Ie(1 - e * e) - 1)
            }), ne("Sine", function(e) {
                return 1 - De(e * Pe)
            }), ne("Back", oe("in"), oe("out"), oe()), dt.SteppedEase = dt.steps = Ve.SteppedEase = {
                config: function(e, t) {
                    void 0 === e && (e = 1);
                    var n = 1 / e,
                        r = e + (t ? 0 : 1),
                        i = t ? 1 : 0;
                    return function(e) {
                        return ((r * nt(0, .99999999, e) | 0) + i) * n
                    }
                }
            }, Le.ease = dt["quad.out"];
            var xt, bt = function(e, t) {
                    this.id = Oe++, (e._gsap = this).target = e, this.harness = t, this.get = t ? t.get : o, this.set = t ? t.getSetter : zt
                },
                _t = ((xt = wt.prototype).delay = function(e) {
                    return e || 0 === e ? (this._delay = e, this) : this._delay
                }, xt.duration = function(e) {
                    var t = arguments.length,
                        n = this._repeat,
                        r = 0 < n ? n * ((t ? e : this._dur) + this._rDelay) : 0;
                    return t ? this.totalDuration(n < 0 ? e : e + r) : this.totalDuration() && this._dur
                }, xt.totalDuration = function(e) {
                    if (!arguments.length) return this._tDur;
                    var t = this._repeat,
                        n = (e || this._rDelay) && t < 0;
                    return this._tDur = n ? 1e12 : e, this._dur = n ? e : (e - t * this._rDelay) / (t + 1), this._dirty = 0, v(this.parent), this
                }, xt.totalTime = function(e, t) {
                    if (ht(), !arguments.length) return this._tTime;
                    var n, r = this.parent || this._dp;
                    if (r && r.smoothChildTiming && this._ts) {
                        for (n = this._start, this._start = r._time - (0 < this._ts ? e / this._ts : ((this._dirty ? this.totalDuration() : this._tDur) - e) / -this._ts), this._end += this._start - n, r._dirty || v(r); r.parent;) r.parent._time !== r._start + (0 < r._ts ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
                        this.parent || x(this._dp, this, this._start - this._delay)
                    }
                    return this._tTime === e && (this._dur || t) || (this._ts || (this._pTime = e), c(this, e, t)), this
                }, xt.time = function(e, t) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + g(this)) % this._dur || (e ? this._dur : 0), t) : this._time
                }, xt.totalProgress = function(e, t) {
                    return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._tTime / this.totalDuration()
                }, xt.progress = function(e, t) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + g(this), t) : this.duration() ? this._time / this._dur : this.ratio
                }, xt.iteration = function(e, t) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? et(this._tTime, n) + 1 : 1
                }, xt.timeScale = function(e) {
                    return arguments.length ? null !== this._pauseTS ? (this._pauseTS = e, this) : (this._ts = e, function(e) {
                        for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                        return e
                    }(this.totalTime(this.parent ? y(this.parent._time, this) : this._tTime, !0))) : this._ts || this._pauseTS || 0
                }, xt.paused = function(e) {
                    var t = !this._ts;
                    return arguments.length ? (t !== e && (e ? (this._pauseTS = this._ts, this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (this._ts = this._pauseTS || 1, this._pauseTS = null, e = this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= Ae), this.totalTime(e, !0))), this) : t
                }, xt.startTime = function(e) {
                    return arguments.length ? (this.parent && this.parent._sort && x(this.parent, this, e - this._delay), this) : this._start
                }, xt.endTime = function(e) {
                    return this._start + (D(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                }, xt.rawTime = function(e) {
                    var t = this.parent || this._dp;
                    return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? y(t.rawTime(e), this) : this._tTime : this._tTime
                }, xt.repeat = function(e) {
                    return arguments.length ? (this._repeat = e, _(this)) : this._repeat
                }, xt.repeatDelay = function(e) {
                    return arguments.length ? (this._rDelay = e, _(this)) : this._rDelay
                }, xt.yoyo = function(e) {
                    return arguments.length ? (this._yoyo = e, this) : this._yoyo
                }, xt.seek = function(e, t) {
                    return this.totalTime(A(this, e), D(t))
                }, xt.restart = function(e, t) {
                    return this.play().totalTime(e ? -this._delay : 0, D(t))
                }, xt.play = function(e, t) {
                    return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
                }, xt.reverse = function(e, t) {
                    return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
                }, xt.pause = function(e, t) {
                    return null != e && this.seek(e, t), this.paused(!0)
                }, xt.resume = function() {
                    return this.paused(!1)
                }, xt.reversed = function(e) {
                    var t = this._ts || this._pauseTS || 0;
                    return arguments.length ? (e !== this.reversed() && (this[null === this._pauseTS ? "_ts" : "_pauseTS"] = Math.abs(t) * (e ? -1 : 1), this.totalTime(this._tTime, !0)), this) : t < 0
                }, xt.invalidate = function() {
                    return this._initted = 0, this
                }, xt.isActive = function(e) {
                    var t, n = this.parent || this._dp,
                        r = this._start;
                    return !(n && !(this._ts && (this._initted || !e) && n.isActive(e) && (t = n.rawTime(!0)) >= r && t < this.endTime(!0) - Ae))
                }, xt.eventCallback = function(e, t, n) {
                    var r = this.vars;
                    return 1 < arguments.length ? (t ? (r[e] = t, n && (r[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete r[e], this) : r[e]
                }, xt.then = function(r) {
                    var i = this;
                    return new Promise(function(t) {
                        function e() {
                            var e = i.then;
                            i.then = null, (n = n(i)) && (n.then || n === i) && (i._prom = n, i.then = e), t(n), i.then = e
                        }
                        var n = r || h;
                        i._initted && 1 === i.totalProgress() && 0 <= i._ts || !i._tTime && i._ts < 0 ? e() : i._prom = e
                    })
                }, xt.kill = function() {
                    K(this)
                }, wt);

            function wt(e, t) {
                var n = e.parent || ae;
                this.vars = e, this._dur = this._tDur = +e.duration || 0, this._delay = +e.delay || 0, (this._repeat = e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase, _(this)), this._ts = 1, this.data = e.data, pe || ut.wake(), n && x(n, this, t || 0 === t ? t : n._time), e.reversed && this.reversed(!0), e.paused && this.paused(!0)
            }
            H(_t.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: 0,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -Ae,
                _prom: 0,
                _pauseTS: null
            });
            var St = function(r) {
                function e(e, t) {
                    var n;
                    return void 0 === e && (e = {}), (n = r.call(this, e, t) || this).labels = {}, n.smoothChildTiming = D(e.smoothChildTiming), n.autoRemoveChildren = !!e.autoRemoveChildren, n._sort = D(e.sortChildren), n
                }
                n(e, r);
                var t = e.prototype;
                return t.to = function(e, t, n, r) {
                    return new Pt(e, l(arguments, 0, this), A(this, S(t) ? r : n)), this
                }, t.from = function(e, t, n, r) {
                    return new Pt(e, l(arguments, 1, this), A(this, S(t) ? r : n)), this
                }, t.fromTo = function(e, t, n, r, i) {
                    return new Pt(e, l(arguments, 2, this), A(this, S(t) ? i : r)), this
                }, t.set = function(e, t, n) {
                    return t.duration = 0, t.parent = this, t.repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new Pt(e, t, A(this, n)), this
                }, t.call = function(e, t, n) {
                    return x(this, Pt.delayedCall(0, e, t), A(this, n))
                }, t.staggerTo = function(e, t, n, r, i, o, a) {
                    return n.duration = t, n.stagger = n.stagger || r, n.onComplete = o, n.onCompleteParams = a, n.parent = this, new Pt(e, n, A(this, i)), this
                }, t.staggerFrom = function(e, t, n, r, i, o, a) {
                    return n.runBackwards = 1, n.immediateRender = D(n.immediateRender), this.staggerTo(e, t, n, r, i, o, a)
                }, t.staggerFromTo = function(e, t, n, r, i, o, a, s) {
                    return r.startAt = n, r.immediateRender = D(r.immediateRender), this.staggerTo(e, t, r, i, o, a, s)
                }, t.render = function(e, t, n) {
                    var r, i, o, a, s, l, c, u, h, d, p, f = this._time,
                        m = this._dirty ? this.totalDuration() : this._tDur,
                        v = this._dur,
                        g = m - Ae < e && 0 <= e && this !== ae ? m : e < Ae ? 0 : e,
                        y = this._zTime < 0 != e < 0 && (this._initted || !v);
                    if (g !== this._tTime || n || y) {
                        if (y && (v || (f = this._zTime), !e && t || (this._zTime = e)), r = g, h = this._start, l = 0 === (u = this._ts), f !== this._time && v && (r += this._time - f), this._repeat && (p = this._yoyo, s = v + this._rDelay, (v < (r = U(g % s)) || m === g) && (r = v), (a = ~~(g / s)) && a === g / s && (r = v, a--), p && 1 & a && (r = v - r), a !== (d = et(this._tTime, s)) && !this._lock)) {
                            var x = p && 1 & d,
                                b = x === (p && 1 & a);
                            if (a < d && (x = !x), f = x ? 0 : v, this._lock = 1, this.render(f, t, !v)._lock = 0, !t && this.parent && at(this, "onRepeat"), f !== this._time || l != !this._ts) return this;
                            if (b && (this._lock = 2, f = x ? v + 1e-4 : -1e-4, this.render(f, !0)), this._lock = 0, !this._ts && !l) return this
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(e, t, n) {
                                var r;
                                if (t < n)
                                    for (r = e._first; r && r._start <= n;) {
                                        if (!r._dur && "isPause" === r.data && r._start > t) return r;
                                        r = r._next
                                    } else
                                        for (r = e._last; r && r._start >= n;) {
                                            if (!r._dur && "isPause" === r.data && r._start < t) return r;
                                            r = r._prev
                                        }
                            }(this, U(f), U(r))) && (g -= r - (r = c._start)), this._tTime = g, this._time = r, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1), f || !r || t || at(this, "onStart"), f <= r && 0 <= e)
                            for (i = this._first; i;) {
                                if (o = i._next, (i._act || r >= i._start) && i._ts && c !== i) {
                                    if (i.parent !== this) return this.render(e, t, n);
                                    if (i.render(0 < i._ts ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, t, n), r !== this._time || !this._ts && !l) {
                                        c = 0;
                                        break
                                    }
                                }
                                i = o
                            } else {
                                i = this._last;
                                for (var _ = e < 0 ? e : r; i;) {
                                    if (o = i._prev, (i._act || _ <= i._end) && i._ts && c !== i) {
                                        if (i.parent !== this) return this.render(e, t, n);
                                        if (i.render(0 < i._ts ? (_ - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (_ - i._start) * i._ts, t, n), r !== this._time || !this._ts && !l) {
                                            c = 0;
                                            break
                                        }
                                    }
                                    i = o
                                }
                            }
                        if (c && !t && (this.pause(), c.render(f <= r ? 0 : -Ae)._zTime = f <= r ? 1 : -1, this._ts)) return this._start = h, this.render(e, t, n);
                        this._onUpdate && !t && at(this, "onUpdate", !0), (g === m || !g && this._ts < 0) && (h !== this._start && Math.abs(u) === Math.abs(this._ts) || (!r || m >= this.totalDuration()) && (!e && v || !(g && 0 < this._ts || !g && this._ts < 0) || V(this, 1), t || e < 0 && !f || (at(this, g === m ? "onComplete" : "onReverseComplete", !0), this._prom && this._prom())))
                    }
                    return this
                }, t.add = function(e, t) {
                    var n = this;
                    if (S(t) || (t = A(this, t)), !(e instanceof _t)) {
                        if (ke(e)) return e.forEach(function(e) {
                            return n.add(e, t)
                        }), v(this);
                        if (F(e)) return this.addLabel(e, t);
                        if (!p(e)) return this;
                        e = Pt.delayedCall(0, e)
                    }
                    return this !== e ? x(this, e, t) : this
                }, t.getChildren = function(e, t, n, r) {
                    void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === r && (r = -1e8);
                    for (var i = [], o = this._first; o;) o._start >= r && (o instanceof Pt ? t && i.push(o) : (n && i.push(o), e && i.push.apply(i, o.getChildren(!0, t, n)))), o = o._next;
                    return i
                }, t.getById = function(e) {
                    for (var t = this.getChildren(1, 1, 1), n = t.length; n--;)
                        if (t[n].vars.id === e) return t[n]
                }, t.remove = function(e) {
                    return F(e) ? this.removeLabel(e) : p(e) ? this.killTweensOf(e) : (m(this, e), e === this._recent && (this._recent = this._last), v(this))
                }, t.totalTime = function(e, t) {
                    return arguments.length ? (this._forcing = 1, this.parent || this._dp || !this._ts || (this._start = ut.time - (0 < this._ts ? e / this._ts : (this.totalDuration() - e) / -this._ts)), r.prototype.totalTime.call(this, e, t), this._forcing = 0, this) : this._tTime
                }, t.addLabel = function(e, t) {
                    return this.labels[e] = A(this, t), this
                }, t.removeLabel = function(e) {
                    return delete this.labels[e], this
                }, t.addPause = function(e, t, n) {
                    var r = Pt.delayedCall(0, t || C, n);
                    return r.data = "isPause", this._hasPause = 1, x(this, r, A(this, e))
                }, t.removePause = function(e) {
                    var t = this._first;
                    for (e = A(this, e); t;) t._start === e && "isPause" === t.data && V(t), t = t._next
                }, t.killTweensOf = function(e, t, n) {
                    for (var r = this.getTweensOf(e, n), i = r.length; i--;) Tt !== r[i] && r[i].kill(e, t);
                    return this
                }, t.getTweensOf = function(e, t) {
                    for (var n, r = [], i = it(e), o = this._first; o;) o instanceof Pt ? !s(o._targets, i) || t && !o.isActive("started" === t) || r.push(o) : (n = o.getTweensOf(i, t)).length && r.push.apply(r, n), o = o._next;
                    return r
                }, t.tweenTo = function(e, t) {
                    var n = this,
                        r = A(n, e),
                        i = t && t.startAt,
                        o = Pt.to(n, H({
                            ease: "none",
                            lazy: !1,
                            time: r,
                            duration: Math.abs(r - (i && "time" in i ? i.time : n._time)) / n.timeScale() || Ae,
                            onStart: function() {
                                n.pause();
                                var e = Math.abs(r - n._time) / n.timeScale();
                                o._dur !== e && (o._dur = e, o.render(o._time, !0, !0)), t && t.onStart && t.onStart.apply(o, t.onStartParams || [])
                            }
                        }, t));
                    return o
                }, t.tweenFromTo = function(e, t, n) {
                    return this.tweenTo(t, H({
                        startAt: {
                            time: A(this, e)
                        }
                    }, n))
                }, t.recent = function() {
                    return this._recent
                }, t.nextLabel = function(e) {
                    return void 0 === e && (e = this._time), Z(this, A(this, e))
                }, t.previousLabel = function(e) {
                    return void 0 === e && (e = this._time), Z(this, A(this, e), 1)
                }, t.currentLabel = function(e) {
                    return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + Ae)
                }, t.shiftChildren = function(e, t, n) {
                    void 0 === n && (n = 0);
                    for (var r, i = this._first, o = this.labels; i;) i._start >= n && (i._start += e), i = i._next;
                    if (t)
                        for (r in o) o[r] >= n && (o[r] += e);
                    return v(this)
                }, t.invalidate = function() {
                    var e = this._first;
                    for (this._lock = 0; e;) e.invalidate(), e = e._next;
                    return r.prototype.invalidate.call(this)
                }, t.clear = function(e) {
                    void 0 === e && (e = !0);
                    for (var t, n = this._first; n;) t = n._next, this.remove(n), n = t;
                    return this._time = this._tTime = 0, e && (this.labels = {}), v(this)
                }, t.totalDuration = function(e) {
                    var t, n, r = 0,
                        i = this,
                        o = i._last,
                        a = 1e8,
                        s = i._repeat,
                        l = s * i._rDelay || 0,
                        c = s < 0;
                    if (arguments.length) return c ? i : i.timeScale(i.totalDuration() / e);
                    if (i._dirty) {
                        for (; o;) t = o._prev, o._dirty && o.totalDuration(), o._start > a && i._sort && o._ts && !i._lock ? (i._lock = 1, x(i, o, o._start - o._delay), i._lock = 0) : a = o._start, o._start < 0 && o._ts && (r -= o._start, (!i.parent && !i._dp || i.parent && i.parent.smoothChildTiming) && (i._start += o._start / i._ts, i._time -= o._start, i._tTime -= o._start), i.shiftChildren(-o._start, !1, -1e20), a = 0), r < (n = o._end = o._start + o._tDur / Math.abs(o._ts || o._pauseTS || Ae)) && o._ts && (r = U(n)), o = t;
                        i._dur = i === ae && i._time > r ? i._time : Math.min(1e8, r), i._tDur = c && (i._dur || l) ? 1e12 : Math.min(1e8, r * (s + 1) + l), i._end = i._start + (i._tDur / Math.abs(i._ts || i._pauseTS || Ae) || 0), i._dirty = 0
                    }
                    return i._tDur
                }, e.updateRoot = function(e) {
                    if (ae._ts && (c(ae, y(e, ae)), he = ut.frame), ut.frame >= Ke) {
                        Ke += Ce.autoSleep || 120;
                        var t = ae._first;
                        if ((!t || !t._ts) && Ce.autoSleep && ut._listeners.length < 2) {
                            for (; t && !t._ts;) t = t._next;
                            t || ut.sleep()
                        }
                    }
                }, e
            }(_t);
            H(St.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });

            function Mt(e, t, n, r, i, o) {
                var a, s, l, c;
                if (Ye[e] && !1 !== (a = new Ye[e]).init(i, a.rawVars ? t[e] : function(e, t, n, r, i) {
                        if (p(e) && (e = Lt(e, i, t, n, r)), !M(e) || e.style && e.nodeType || ke(e)) return F(e) ? Lt(e, i, t, n, r) : e;
                        var o, a = {};
                        for (o in e) a[o] = Lt(e[o], i, t, n, r);
                        return a
                    }(t[e], r, i, o, n), n, r, o) && (n._pt = s = new jt(n._pt, i, e, 0, 1, a.render, a, 0, a.priority), n !== de))
                    for (l = n._ptLookup[n._targets.indexOf(i)], c = a._props.length; c--;) l[a._props[c]] = s;
                return a
            }
            var Tt, Et = function(e, t, n, r, i, o, a, s, l) {
                    p(r) && (r = r(i || 0, e, o));
                    var c, u = e[t],
                        h = "get" !== n ? n : p(u) ? l ? e[t.indexOf("set") || !p(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : u,
                        d = p(u) ? l ? kt : Nt : Dt;
                    if (F(r) && (~r.indexOf("random(") && (r = Y(r)), "=" === r.charAt(1) && (r = parseFloat(h) + parseFloat(r.substr(2)) * ("-" === r.charAt(0) ? -1 : 1) + (P(h) || 0))), h !== r) return isNaN(h + r) ? (u || t in e || B(t, r), function(e, t, n, r, i, o, a) {
                        var s, l, c, u, h, d, p, f, m = new jt(this._pt, e, t, 0, 1, Ut, null, i),
                            v = 0,
                            g = 0;
                        for (m.b = n, m.e = r, n += "", (p = ~(r += "").indexOf("random(")) && (r = Y(r)), o && (o(f = [n, r], e, t), n = f[0], r = f[1]), l = n.match(Be) || []; s = Be.exec(r);) u = s[0], h = r.substring(v, s.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[g++] && (d = parseFloat(l[g - 1]) || 0, m._pt = {
                            _next: m._pt,
                            p: h || 1 === g ? h : ",",
                            s: d,
                            c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - d,
                            m: c && c < 4 ? Math.round : 0
                        }, v = Be.lastIndex);
                        return m.c = v < r.length ? r.substring(v, r.length) : "", m.fp = a, (He.test(r) || p) && (m.e = 0), this._pt = m
                    }.call(this, e, t, h, r, d, s || Ce.stringFilter, l)) : (c = new jt(this._pt, e, t, +h || 0, r - (h || 0), "boolean" == typeof u ? Bt : Ft, 0, d), l && (c.fp = l), a && c.modifier(a, this, e), this._pt = c)
                },
                Ct = function e(t, n) {
                    var r, i, o, a, s, l, c, u, h, d, p, f, m = t.vars,
                        v = m.ease,
                        g = m.startAt,
                        y = m.immediateRender,
                        x = m.lazy,
                        b = m.onUpdate,
                        _ = m.onUpdateParams,
                        w = m.callbackScope,
                        S = m.runBackwards,
                        M = m.yoyoEase,
                        T = m.keyframes,
                        E = m.autoRevert,
                        C = t._dur,
                        L = t._startAt,
                        A = t._targets,
                        R = t.parent,
                        P = R && "nested" === R.data ? R.parent._targets : A,
                        O = "auto" === t._overwrite,
                        I = t.timeline;
                    if (!I || T && v || (v = "none"), t._ease = vt(v, Le.ease), t._yEase = M ? mt(vt(!0 === M ? v : M, Le.ease)) : 0, M && t._yoyo && !t._repeat && (M = t._yEase, t._yEase = t._ease, t._ease = M), !I) {
                        if (L && L.render(-1, !0).kill(), g) {
                            if (V(t._startAt = Pt.set(A, H({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: R,
                                    immediateRender: !0,
                                    lazy: D(x),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: b,
                                    onUpdateParams: _,
                                    callbackScope: w,
                                    stagger: 0
                                }, g))), y)
                                if (0 < n) E || (t._startAt = 0);
                                else if (C) return
                        } else if (S && C)
                            if (L) E || (t._startAt = 0);
                            else if (n && (y = !1), V(t._startAt = Pt.set(A, $e(G(m, je), {
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: y && D(x),
                                immediateRender: y,
                                stagger: 0,
                                parent: R
                            }))), y) {
                            if (!n) return
                        } else e(t._startAt, Ae);
                        for (r = G(m, je), f = (u = A[t._pt = 0] ? k(A[0]).harness : 0) && m[u.prop], x = C && D(x) || x && !C, i = 0; i < A.length; i++) {
                            if (c = (s = A[i])._gsap || N(A)[i]._gsap, t._ptLookup[i] = d = {}, Xe[c.id] && z(), p = P === A ? i : P.indexOf(s), u && !1 !== (h = new u).init(s, f || r, t, p, P) && (t._pt = a = new jt(t._pt, s, h.name, 0, 1, h.render, h, 0, h.priority), h._props.forEach(function(e) {
                                    d[e] = a
                                }), h.priority && (l = 1)), !u || f)
                                for (o in r) Ye[o] && (h = Mt(o, r, t, p, s, P)) ? h.priority && (l = 1) : d[o] = a = Et.call(t, s, o, "get", r[o], p, P, 0, m.stringFilter);
                            t._op && t._op[i] && t.kill(s, t._op[i]), O && t._pt && (Tt = t, ae.killTweensOf(s, d, "started"), Tt = 0), t._pt && x && (Xe[c.id] = 1)
                        }
                        l && Wt(t), t._onInit && t._onInit(t)
                    }
                    t._from = !I && !!m.runBackwards, t._onUpdate = b, t._initted = 1
                },
                Lt = function(e, t, n, r, i) {
                    return p(e) ? e.call(t, n, r, i) : F(e) && ~e.indexOf("random(") ? Y(e) : e
                },
                At = Qe + ",repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
                Rt = (At + ",id,stagger,delay,duration,paused").split(","),
                Pt = function(_) {
                    function i(e, t, n) {
                        var r;
                        "number" == typeof t && (n.duration = t, t = n, n = null);
                        var i, o, a, s, l, c, u, h, d = (r = _.call(this, function(e) {
                                var t = e.parent || ae,
                                    n = e.keyframes ? L : H;
                                if (D(e.inherit))
                                    for (; t;) n(e, t.vars.defaults), t = t.parent;
                                return e
                            }(t), n) || this).vars,
                            p = d.duration,
                            f = d.delay,
                            m = d.immediateRender,
                            v = d.stagger,
                            g = d.overwrite,
                            y = d.keyframes,
                            x = d.defaults,
                            b = ke(e) && S(e[0]) ? [e] : it(e);
                        if (r._targets = b.length ? N(b) : E("GSAP target " + e + " not found. https://greensock.com", !Ce.nullTargetWarn) || [], r._ptLookup = [], r._overwrite = g, y || v || T(p) || T(f)) {
                            if (t = r.vars, (i = r.timeline = new St({
                                    data: "nested",
                                    defaults: x || {}
                                })).kill(), i.parent = w(r), y) H(i.vars.defaults, {
                                ease: "none"
                            }), y.forEach(function(e) {
                                return i.to(b, e, ">")
                            });
                            else {
                                if (s = b.length, u = v ? I(v) : C, M(v))
                                    for (l in v) ~At.indexOf(l) && ((h = h || {})[l] = v[l]);
                                for (o = 0; o < s; o++) {
                                    for (l in a = {}, t) Rt.indexOf(l) < 0 && (a[l] = t[l]);
                                    a.stagger = 0, h && $e(a, h), t.yoyoEase && !t.repeat && (a.yoyoEase = t.yoyoEase), c = b[o], a.duration = +Lt(p, w(r), o, c, b), a.delay = (+Lt(f, w(r), o, c, b) || 0) - r._delay, !v && 1 === s && a.delay && (r._delay = f = a.delay, r._start += f, a.delay = 0), i.to(c, a, u(o, c, b))
                                }
                                p = f = 0
                            }
                            p || r.duration(p = i.duration())
                        } else r.timeline = 0;
                        return !0 === g && (Tt = w(r), ae.killTweensOf(b), Tt = 0), (m || !p && !y && r._start === r.parent._time && D(m) && function e(t) {
                            return !t || t._ts && e(t.parent)
                        }(w(r)) && "nested" !== r.parent.data) && (r._tTime = -Ae, r.render(Math.max(0, -f))), r
                    }
                    n(i, _);
                    var e = i.prototype;
                    return e.render = function(e, t, n) {
                        var r, i, o, a, s, l, c, u, h, d = this._time,
                            p = this._tDur,
                            f = this._dur,
                            m = p - Ae < e && 0 <= e ? p : e < Ae ? 0 : e;
                        if (f) {
                            if (m !== this._tTime || !e || n || this._startAt && this._zTime < 0 != e < 0) {
                                if (r = m, u = this.timeline, this._repeat) {
                                    if (a = f + this._rDelay, f < (r = U(m % a)) && (r = f), (o = ~~(m / a)) && o === m / a && (r = f, o--), (l = this._yoyo && 1 & o) && (h = this._yEase, r = f - r), s = et(this._tTime, a), r === d && !n && this._initted) return this;
                                    o !== s && this.vars.repeatRefresh && !this._lock && (this._lock = n = 1, this.render(a * o, !0).invalidate()._lock = 0)
                                }
                                if (!this._initted && b(this, r, n, t)) return this._tTime = 0, this;
                                for (this._tTime = m, this._time = r, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(r / f), this._from && (this.ratio = c = 1 - c), d || !r || t || at(this, "onStart"), i = this._pt; i;) i.r(c, i.d), i = i._next;
                                u && u.render(e < 0 ? e : !r && l ? -Ae : u._dur * c, t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (e < 0 && this._startAt && this._startAt.render(e, !0, n), at(this, "onUpdate")), this._repeat && o !== s && this.vars.onRepeat && !t && this.parent && at(this, "onRepeat"), m !== p && m || this._tTime !== m || (e < 0 && this._startAt && !this._onUpdate && this._startAt.render(e, !0, n), !e && f || !(m && 0 < this._ts || !m && this._ts < 0) || V(this, 1), t || e < 0 && !d || (at(this, m === p ? "onComplete" : "onReverseComplete", !0), this._prom && this._prom()))
                            }
                        } else ! function(e, t, n, r) {
                            var i, o = e._zTime < 0 ? 0 : 1,
                                a = t < 0 ? 0 : 1,
                                s = e._rDelay,
                                l = 0;
                            if (s && e._repeat && (l = nt(0, e._tDur, t), et(l, s) !== et(e._tTime, s) && (o = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), (e._initted || !b(e, t, r, n)) && (a !== o || r || e._zTime === Ae || !t && e._zTime)) {
                                for (e._zTime = t || (n ? Ae : 0), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = l, n || at(e, "onStart"), i = e._pt; i;) i.r(a, i.d), i = i._next;
                                !a && e._startAt && !e._onUpdate && e._start && e._startAt.render(t, !0, r), e._onUpdate && !n && at(e, "onUpdate"), l && e._repeat && !n && e.parent && at(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (e.ratio && V(e, 1), n || (at(e, e.ratio ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                            }
                        }(this, e, t, n);
                        return this
                    }, e.targets = function() {
                        return this._targets
                    }, e.invalidate = function() {
                        return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), _.prototype.invalidate.call(this)
                    }, e.kill = function(e, t) {
                        if (void 0 === t && (t = "all"), !(e || t && "all" !== t) && (this._lazy = 0, this.parent)) return K(this);
                        if (this.timeline) return this.timeline.killTweensOf(e, t, Tt && !0 !== Tt.vars.overwrite), this;
                        var n, r, i, o, a, s, l, c = this._targets,
                            u = e ? it(e) : c,
                            h = this._ptLookup,
                            d = this._pt;
                        if ((!t || "all" === t) && function(e, t) {
                                for (var n = e.length, r = n === t.length; r && n-- && e[n] === t[n];);
                                return n < 0
                            }(c, u)) return K(this);
                        for (n = this._op = this._op || [], "all" !== t && (F(t) && (a = {}, f(t, function(e) {
                                return a[e] = 1
                            }), t = a), t = function(e, t) {
                                var n, r, i, o, a = e[0] ? k(e[0]).harness : 0,
                                    s = a && a.aliases;
                                if (!s) return t;
                                for (r in n = $e({}, t), s)
                                    if (r in n)
                                        for (i = (o = s[r].split(",")).length; i--;) n[o[i]] = n[r];
                                return n
                            }(c, t)), l = c.length; l--;)
                            if (~u.indexOf(c[l]))
                                for (a in r = h[l], "all" === t ? (n[l] = t, o = r, i = {}) : (i = n[l] = n[l] || {}, o = t), o)(s = r && r[a]) && ("kill" in s.d && !0 !== s.d.kill(a) || m(this, s, "_pt"), delete r[a]), "all" !== i && (i[a] = 1);
                        return this._initted && !this._pt && d && K(this), this
                    }, i.to = function(e, t, n) {
                        return new i(e, t, n)
                    }, i.from = function(e, t) {
                        return new i(e, l(arguments, 1))
                    }, i.delayedCall = function(e, t, n, r) {
                        return new i(t, 0, {
                            immediateRender: !1,
                            lazy: !1,
                            overwrite: !1,
                            delay: e,
                            onComplete: t,
                            onReverseComplete: t,
                            onCompleteParams: n,
                            onReverseCompleteParams: n,
                            callbackScope: r
                        })
                    }, i.fromTo = function(e, t, n) {
                        return new i(e, l(arguments, 2))
                    }, i.set = function(e, t) {
                        return t.duration = 0, t.repeatDelay || (t.repeat = 0), new i(e, t)
                    }, i.killTweensOf = function(e, t, n) {
                        return ae.killTweensOf(e, t, n)
                    }, i
                }(_t);
            H(Pt.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), f("staggerTo,staggerFrom,staggerFromTo", function(n) {
                Pt[n] = function() {
                    var e = new St,
                        t = it(arguments);
                    return t.splice("staggerFromTo" === n ? 5 : 4, 0, 0), e[n].apply(e, t)
                }
            });

            function Ot(e, t, n) {
                return e.setAttribute(t, n)
            }

            function It(e, t, n, r) {
                r.mSet(e, t, r.m.call(r.tween, n, r.mt), r)
            }
            var Dt = function(e, t, n) {
                    return e[t] = n
                },
                Nt = function(e, t, n) {
                    return e[t](n)
                },
                kt = function(e, t, n, r) {
                    return e[t](r.fp, n)
                },
                zt = function(e, t) {
                    return p(e[t]) ? Nt : r(e[t]) && e.setAttribute ? Ot : Dt
                },
                Ft = function(e, t) {
                    return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4, t)
                },
                Bt = function(e, t) {
                    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
                },
                Ut = function(e, t) {
                    var n = t._pt,
                        r = "";
                    if (!e && t.b) r = t.b;
                    else if (1 === e && t.e) r = t.e;
                    else {
                        for (; n;) r = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + r, n = n._next;
                        r += t.c
                    }
                    t.set(t.t, t.p, r, t)
                },
                Ht = function(e, t) {
                    for (var n = t._pt; n;) n.r(e, n.d), n = n._next
                },
                Gt = function(e, t, n, r) {
                    for (var i, o = this._pt; o;) i = o._next, o.p === r && o.modifier(e, t, n), o = i
                },
                Vt = function(e) {
                    for (var t, n, r = this._pt; r;) n = r._next, r.p === e && !r.op || r.op === e ? m(this, r, "_pt") : r.dep || (t = 1), r = n;
                    return !t
                },
                Wt = function(e) {
                    for (var t, n, r, i, o = e._pt; o;) {
                        for (t = o._next, n = r; n && n.pr > o.pr;) n = n._next;
                        (o._prev = n ? n._prev : i) ? o._prev._next = o: r = o, (o._next = n) ? n._prev = o : i = o, o = t
                    }
                    e._pt = r
                },
                jt = (qt.prototype.modifier = function(e, t, n) {
                    this.mSet = this.mSet || this.set, this.set = It, this.m = e, this.mt = n, this.tween = t
                }, qt);

            function qt(e, t, n, r, i, o, a, s, l) {
                this.t = t, this.s = r, this.c = i, this.p = n, this.r = o || Ft, this.d = a || this, this.set = s || Dt, this.pr = l || 0, (this._next = e) && (e._prev = this)
            }
            f(Qe + ",parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert", function(e) {
                je[e] = 1, "on" === e.substr(0, 2) && (je[e + "Params"] = 1)
            }), Ve.TweenMax = Ve.TweenLite = Pt, Ve.TimelineLite = Ve.TimelineMax = St, ae = new St({
                sortChildren: !1,
                defaults: Le,
                autoRemoveChildren: !0,
                id: "root"
            }), Ce.stringFilter = ee;
            var Xt = {
                registerPlugin: function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    t.forEach(function(e) {
                        return function(e) {
                            var t = (e = !e.name && e.default || e).name,
                                n = p(e),
                                r = t && !n && e.init ? function() {
                                    this._props = []
                                } : e,
                                i = {
                                    init: C,
                                    render: Ht,
                                    add: Et,
                                    kill: Vt,
                                    modifier: Gt,
                                    rawVars: 0
                                },
                                o = {
                                    targetTest: 0,
                                    get: 0,
                                    getSetter: zt,
                                    aliases: {},
                                    register: 0
                                };
                            if (ht(), e !== r) {
                                if (Ye[t]) return;
                                H(r, H(G(e, i), o)), $e(r.prototype, $e(i, G(e, o))), Ye[r.prop = t] = r, e.targetTest && (Je.push(r), je[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                            }
                            a(t, r), e.register && e.register(Kt, r, jt)
                        }(e)
                    })
                },
                timeline: function(e) {
                    return new St(e)
                },
                getTweensOf: function(e, t) {
                    return ae.getTweensOf(e, t)
                },
                getProperty: function(r, e, t, n) {
                    F(r) && (r = it(r)[0]);
                    var i = k(r || {}).get,
                        o = t ? h : u;
                    return "native" === t && (t = ""), r ? e ? o((Ye[e] && Ye[e].get || i)(r, e, t, n)) : function(e, t, n) {
                        return o((Ye[e] && Ye[e].get || i)(r, e, t, n))
                    } : r
                },
                quickSetter: function(n, t, r) {
                    if (1 < (n = it(n)).length) {
                        var i = n.map(function(e) {
                                return Kt.quickSetter(e, t, r)
                            }),
                            o = i.length;
                        return function(e) {
                            for (var t = o; t--;) i[t](e)
                        }
                    }
                    n = n[0] || {};
                    var a = Ye[t],
                        s = k(n),
                        l = a ? function(e) {
                            var t = new a;
                            de._pt = 0, t.init(n, r ? e + r : e, de, 0, [n]), t.render(1, t), de._pt && Ht(1, de)
                        } : s.set(n, t);
                    return a ? l : function(e) {
                        return l(n, t, r ? e + r : e, s, 1)
                    }
                },
                isTweening: function(e) {
                    return 0 < ae.getTweensOf(e, !0).length
                },
                defaults: function(e) {
                    return e && e.ease && (e.ease = vt(e.ease, Le.ease)), d(Le, e || {})
                },
                config: function(e) {
                    return d(Ce, e || {})
                },
                registerEffect: function(e) {
                    var r = e.name,
                        n = e.effect,
                        t = e.plugins,
                        i = e.defaults,
                        o = e.extendTimeline;
                    (t || "").split(",").forEach(function(e) {
                        return e && !Ye[e] && !Ve[e] && E(r + " effect requires " + e + " plugin.")
                    }), Ze[r] = function(e, t) {
                        return n(it(e), H(t || {}, i))
                    }, o && (St.prototype[r] = function(e, t, n) {
                        return this.add(Ze[r](e, M(t) ? t : (n = t) && {}), n)
                    })
                },
                registerEase: function(e, t) {
                    dt[e] = vt(t)
                },
                parseEase: function(e, t) {
                    return arguments.length ? vt(e, t) : dt
                },
                getById: function(e) {
                    return ae.getById(e)
                },
                exportRoot: function(e, t) {
                    void 0 === e && (e = {});
                    var n, r, i = new St(e);
                    for (i.smoothChildTiming = D(e.smoothChildTiming), ae.remove(i), i._dp = 0, i._time = i._tTime = ae._time, n = ae._first; n;) r = n._next, !t && !n._dur && n instanceof Pt && n.vars.onComplete === n._targets[0] || x(i, n, n._start - n._delay), n = r;
                    return x(ae, i, 0), i
                },
                utils: {
                    wrap: function e(t, n, r) {
                        var i = n - t;
                        return ke(t) ? X(t, e(0, t.length), n) : R(r, function(e) {
                            return (i + (e - t) % i) % i + t
                        })
                    },
                    wrapYoyo: function e(t, n, r) {
                        var i = n - t,
                            o = 2 * i;
                        return ke(t) ? X(t, e(0, t.length - 1), n) : R(r, function(e) {
                            return t + (i < (e = (o + (e - t) % o) % o) ? o - e : e)
                        })
                    },
                    distribute: I,
                    random: q,
                    snap: j,
                    normalize: function(e, t, n) {
                        return ot(e, t, 0, 1, n)
                    },
                    getUnit: P,
                    clamp: function(t, n, e) {
                        return R(e, function(e) {
                            return nt(t, n, e)
                        })
                    },
                    splitColor: Q,
                    toArray: it,
                    mapRange: ot,
                    pipe: function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        return function(e) {
                            return t.reduce(function(e, t) {
                                return t(e)
                            }, e)
                        }
                    },
                    unitize: function(t, n) {
                        return function(e) {
                            return t(parseFloat(e)) + (n || P(e))
                        }
                    },
                    interpolate: function e(t, n, r, i) {
                        var o = isNaN(t + n) ? 0 : function(e) {
                            return (1 - e) * t + e * n
                        };
                        if (!o) {
                            var a, s, l, c, u, h = F(t),
                                d = {};
                            if (!0 === r && (i = 1) && (r = null), h) t = {
                                p: t
                            }, n = {
                                p: n
                            };
                            else if (ke(t) && !ke(n)) {
                                for (l = [], c = t.length, u = c - 2, s = 1; s < c; s++) l.push(e(t[s - 1], t[s]));
                                c--, o = function(e) {
                                    e *= c;
                                    var t = Math.min(u, ~~e);
                                    return l[t](e - t)
                                }, r = n
                            } else i || (t = $e(ke(t) ? [] : {}, t));
                            if (!l) {
                                for (a in n) Et.call(d, t, a, "get", n[a]);
                                o = function(e) {
                                    return Ht(e, d) || (h ? t.p : t)
                                }
                            }
                        }
                        return R(r, o)
                    }
                },
                install: i,
                effects: Ze,
                ticker: ut,
                updateRoot: St.updateRoot,
                plugins: Ye,
                globalTimeline: ae,
                core: {
                    PropTween: jt,
                    globals: a,
                    Tween: Pt,
                    Timeline: St,
                    Animation: _t,
                    getCache: k
                }
            };
            f("to,from,fromTo,delayedCall,set,killTweensOf", function(e) {
                return Xt[e] = Pt[e]
            }), ut.add(St.updateRoot), de = Xt.to({}, {
                duration: 0
            });

            function Yt(e, t) {
                for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
                return n
            }

            function Zt(e, i) {
                return {
                    name: e,
                    rawVars: 1,
                    init: function(e, r, t) {
                        t._onInit = function(e) {
                            var t, n;
                            if (F(r) && (t = {}, f(r, function(e) {
                                    return t[e] = 1
                                }), r = t), i) {
                                for (n in t = {}, r) t[n] = i(r[n]);
                                r = t
                            }! function(e, t) {
                                var n, r, i, o = e._targets;
                                for (n in t)
                                    for (r = o.length; r--;)(i = (i = e._ptLookup[r][n]) && i.d) && (i._pt && (i = Yt(i, n)), i && i.modifier && i.modifier(t[n], e, o[r], n))
                            }(e, r)
                        }
                    }
                }
            }
            var Kt = Xt.registerPlugin({
                name: "attr",
                init: function(e, t, n, r, i) {
                    for (var o in t) this.add(e, "setAttribute", (e.getAttribute(o) || 0) + "", t[o], r, i, 0, 0, o), this._props.push(o)
                }
            }, {
                name: "endArray",
                init: function(e, t) {
                    for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n])
                }
            }, Zt("roundProps", W), Zt("modifiers"), Zt("snap", j)) || Xt;
            Pt.version = St.version = Kt.version = "3.0.5", ue = 1, t() && ht();

            function Jt(e, t) {
                return t.set(t.t, t.p, ~~(1e3 * (t.s + t.c * e)) / 1e3 + t.u, t)
            }

            function Qt(e, t) {
                return t.set(t.t, t.p, 1 === e ? t.e : ~~(1e3 * (t.s + t.c * e)) / 1e3 + t.u, t)
            }

            function $t(e, t) {
                return t.set(t.t, t.p, e ? ~~(1e3 * (t.s + t.c * e)) / 1e3 + t.u : t.b, t)
            }

            function en(e, t) {
                var n = t.s + t.c * e;
                t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
            }

            function tn(e, t) {
                return t.set(t.t, t.p, e ? t.e : t.b, t)
            }

            function nn(e, t) {
                return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
            }

            function rn(e, t, n) {
                return e.style[t] = n
            }

            function on(e, t, n) {
                return e.style.setProperty(t, n)
            }

            function an(e, t, n) {
                return e._gsap[t] = n
            }

            function sn(e, t, n) {
                return e._gsap.scaleX = e._gsap.scaleY = n
            }

            function ln(e, t, n, r, i) {
                var o = e._gsap;
                o.scaleX = o.scaleY = n, o.renderTransform(i, o)
            }

            function cn(e, t, n, r, i) {
                var o = e._gsap;
                o[t] = n, o.renderTransform(i, o)
            }

            function un(e, t) {
                var n = An.createElementNS ? An.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : An.createElement(e);
                return n.style ? n : An.createElement(e)
            }

            function hn(e, t, n) {
                var r = getComputedStyle(e);
                return r[t] || r.getPropertyValue(t.replace(sr, "-$1").toLowerCase()) || r.getPropertyValue(t) || !n && hn(e, mr(t) || t, 1) || ""
            }

            function dn() {
                "undefined" != typeof window && (Ln = window, An = Ln.document, Rn = An.documentElement, On = un("div") || {
                    style: {}
                }, In = un("div"), dr = mr(dr), pr = mr(pr), On.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Nn = !!mr("perspective"), Pn = 1)
            }

            function pn(e, t) {
                for (var n = t.length; n--;)
                    if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
            }

            function fn(t) {
                var n;
                try {
                    n = t.getBBox()
                } catch (e) {
                    n = function e(t) {
                        var n, r = un("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                            i = this.parentNode,
                            o = this.nextSibling,
                            a = this.style.cssText;
                        if (Rn.appendChild(r), r.appendChild(this), this.style.display = "block", t) try {
                            n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e
                        } catch (e) {} else this._gsapBBox && (n = this._gsapBBox());
                        return o ? i.insertBefore(this, o) : i.appendChild(this), Rn.removeChild(r), this.style.cssText = a, n
                    }.call(t, !0)
                }
                return !n || n.width || n.x || n.y ? n : {
                    x: +pn(t, ["x", "cx", "x1"]) || 0,
                    y: +pn(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            }

            function mn(e) {
                return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !fn(e))
            }

            function vn(e, t) {
                if (t) {
                    var n = e.style;
                    t in rr && (t = dr), n.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), n.removeProperty(t.replace(sr, "-$1").toLowerCase())) : n.removeAttribute(t)
                }
            }

            function gn(e, t, n, r, i, o) {
                var a = new jt(e._pt, t, n, 0, 1, o ? nn : tn);
                return (e._pt = a).b = r, a.e = i, e._props.push(n), a
            }

            function yn(e, t, n, r) {
                var i, o, a, s, l = parseFloat(n) || 0,
                    c = (n + "").trim().substr((l + "").length) || "px",
                    u = On.style,
                    h = cr.test(t),
                    d = "svg" === e.tagName.toLowerCase(),
                    p = (d ? "client" : "offset") + (h ? "Width" : "Height"),
                    f = "px" === r;
                return r === c || !l || vr[r] || vr[c] ? l : (s = e.getCTM && mn(e), "%" === r && rr[t] ? U(l / (s ? e.getBBox()[h ? "width" : "height"] : e[p]) * 100) : (u[h ? "width" : "height"] = 100 + (f ? c : r), o = "em" === r && e.appendChild && !d ? e : e.parentNode, s && (o = (e.ownerSVGElement || {}).parentNode), o && o !== An && o.appendChild || (o = An.body), (a = o._gsap) && "%" === r && a.width && h && a.time === ut.time ? U(l / a.width * 100) : (o.appendChild(On), i = On[p], o.removeChild(On), h && "%" === r && ((a = k(o)).time = ut.time, a.width = o[p]), U(f ? i * l / 100 : 100 / i * l))))
            }

            function xn(e, t, n, r) {
                var i;
                return Pn || dn(), t in hr && "transform" !== t && ~(t = hr[t]).indexOf(",") && (t = t.split(",")[0]), rr[t] && "transform" !== t ? (i = _r(e, r), i = "transformOrigin" !== t ? i[t] : wr(hn(e, pr)) + i.zOrigin + "px") : (i = e.style[t]) && "auto" !== i && !r && !~(i + "").indexOf("calc(") || (i = hn(e, t) || o(e, t) || ("opacity" === t ? 1 : 0)), n ? yn(e, t, i, n) + n : i
            }

            function bn(e, t, n, r) {
                var i, o, a, s, l, c, u, h, d, p, f, m, v = new jt(this._pt, e.style, t, 0, 1, Ut),
                    g = 0,
                    y = 0;
                if (v.b = n, v.e = r, n += "", "auto" === (r += "") && (e.style[t] = r, r = hn(e, t) || r, e.style[t] = n), ee(i = [n, r]), r = i[1], !!(c = (n = i[0]).indexOf("rgba(")) != !!(u = r.indexOf("rgba(")) && (c ? n = n.substr(c) + " " + n.substr(0, c - 1) : r = r.substr(u) + " " + r.substr(0, u - 1)), a = n.match(lr) || [], (r.match(lr) || []).length) {
                    for (; o = lr.exec(r);) u = o[0], d = r.substring(g, o.index), l ? l = (l + 1) % 5 : "rgba(" === d.substr(-5) && (l = 1), u !== (c = a[y++] || "") && (s = parseFloat(c) || 0, f = c.substr((s + "").length), (m = "=" === u.charAt(1) ? +(u.charAt(0) + "1") : 0) && (u = u.substr(2)), h = parseFloat(u), p = u.substr((h + "").length), g = lr.lastIndex - p.length, p || (p = p || Ce.units[t] || f, g === r.length && (r += p, v.e += p)), f !== p && (s = yn(e, t, c, p) || 0), v._pt = {
                        _next: v._pt,
                        p: d || 1 === y ? d : ",",
                        s: s,
                        c: m ? m * h : h - s,
                        m: l && l < 4 ? Math.round : 0
                    });
                    v.c = g < r.length ? r.substring(g, r.length) : ""
                } else v.r = "display" === t && "none" === r ? nn : tn;
                return He.test(r) && (v.e = 0), this._pt = v
            }

            function _n(e, t) {
                if (t.tween && t.tween._time === t.tween._dur) {
                    var n, r, i, o = t.t,
                        a = o.style,
                        s = t.u;
                    if ("all" === s || !0 === s) a.cssText = "", r = 1;
                    else
                        for (i = (s = s.split(",")).length; - 1 < --i;) n = s[i], rr[n] && (r = 1, n = "transformOrigin" === n ? pr : dr), vn(o, n);
                    r && (vn(o, dr), (r = o._gsap) && (r.svg && o.removeAttribute("transform"), _r(o, 1)))
                }
            }

            function wn(e) {
                return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
            }

            function Sn(e) {
                var t = hn(e, dr);
                return wn(t) ? xr : t.substr(7).match(Fe).map(U)
            }

            function Mn(e, t) {
                var n, r, i, o, a = e._gsap,
                    s = e.style,
                    l = Sn(e);
                return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(i = e.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? xr : l : (l !== xr || e.offsetParent || e === Rn || a.svg || (i = s.display, s.display = "block", (n = e.parentNode) && e.offsetParent || (o = 1, r = e.nextSibling, Rn.appendChild(e)), l = Sn(e), i ? s.display = i : vn(e, "display"), o && (r ? n.insertBefore(e, r) : n ? n.appendChild(e) : Rn.removeChild(e))), t && 6 < l.length ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            }

            function Tn(e, t, n, r, i, o) {
                var a, s, l, c = e._gsap,
                    u = i || Mn(e, !0),
                    h = c.xOrigin || 0,
                    d = c.yOrigin || 0,
                    p = c.xOffset || 0,
                    f = c.yOffset || 0,
                    m = u[0],
                    v = u[1],
                    g = u[2],
                    y = u[3],
                    x = u[4],
                    b = u[5],
                    _ = t.split(" "),
                    w = parseFloat(_[0]) || 0,
                    S = parseFloat(_[1]) || 0;
                n ? u !== xr && (s = m * y - v * g) && (l = w * (-v / s) + S * (m / s) - (m * b - v * x) / s, w = w * (y / s) + S * (-g / s) + (g * b - y * x) / s, S = l) : (w = (a = fn(e)).x + (~_[0].indexOf("%") ? w / 100 * a.width : w), S = a.y + (~(_[1] || _[0]).indexOf("%") ? S / 100 * a.height : S)), r || !1 !== r && c.smooth ? (x = w - h, b = S - d, c.xOffset = p + (x * m + b * g) - x, c.yOffset = f + (x * v + b * y) - b) : c.xOffset = c.yOffset = 0, c.xOrigin = w, c.yOrigin = S, c.smooth = !!r, c.origin = t, c.originIsAbsolute = !!n, e.style[pr] = "0px 0px", o && (gn(o, c, "xOrigin", h, w), gn(o, c, "yOrigin", d, S), gn(o, c, "xOffset", p, c.xOffset), gn(o, c, "yOffset", f, c.yOffset))
            }

            function En(e, t, n) {
                var r = P(t);
                return U(parseFloat(t) + parseFloat(yn(e, "x", n + "px", r))) + r
            }

            function Cn(e, t, n) {
                var r, i, o, a, s, l, c, u = In.style,
                    h = n._gsap;
                for (i in u.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", u[dr] = t, An.body.appendChild(In), r = _r(In, 1), rr)(o = h[i]) !== (a = r[i]) && "perspective" !== i && (s = P(o) !== (c = P(a)) ? yn(n, i, o, c) : parseFloat(o), l = parseFloat(a), e._pt = new jt(e._pt, h, i, s, l - s, Jt), e._pt.u = c, e._props.push(i));
                An.body.removeChild(In)
            }
            var Ln, An, Rn, Pn, On, In, Dn, Nn, kn, zn, Fn, Bn = dt.Power0,
                Un = dt.Power1,
                Hn = dt.Power2,
                Gn = dt.Power3,
                Vn = dt.Power4,
                Wn = dt.Linear,
                jn = dt.Quad,
                qn = dt.Cubic,
                Xn = dt.Quart,
                Yn = dt.Quint,
                Zn = dt.Strong,
                Kn = dt.Elastic,
                Jn = dt.Back,
                Qn = dt.SteppedEase,
                $n = dt.Bounce,
                er = dt.Sine,
                tr = dt.Expo,
                nr = dt.Circ,
                rr = {},
                ir = 180 / Math.PI,
                or = Math.PI / 180,
                ar = Math.atan2,
                sr = /([A-Z])/g,
                lr = /[-+=\.]*\d+[\.e-]*\d*[a-z%]*/g,
                cr = /(?:left|right|width|margin|padding|x)/i,
                ur = /[\s,\(]\S/,
                hr = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                dr = "transform",
                pr = dr + "Origin",
                fr = "O,Moz,ms,Ms,Webkit".split(","),
                mr = function(e, t) {
                    var n = (t || On).style,
                        r = 5;
                    if (e in n) return e;
                    for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(fr[r] + e in n););
                    return r < 0 ? null : (3 === r ? "ms" : 0 <= r ? fr[r] : "") + e
                },
                vr = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                gr = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                yr = {
                    clearProps: function(e, t, n, r, i) {
                        if ("isFromStart" !== i.data) {
                            var o = e._pt = new jt(e._pt, t, n, 0, 0, _n);
                            return o.u = r, o.pr = -10, o.tween = i, e._props.push(n), 1
                        }
                    }
                },
                xr = [1, 0, 0, 1, 0, 0],
                br = {},
                _r = function(e, t) {
                    var n = e._gsap || new bt(e);
                    if ("x" in n && !t && !n.uncache) return n;
                    var r, i, o, a, s, l, c, u, h, d, p, f, m, v, g, y, x, b, _, w, S, M, T, E, C, L, A, R, P, O, I = e.style,
                        D = n.scaleX < 0,
                        N = n.xOrigin || 0,
                        k = n.yOrigin || 0,
                        z = hn(e, pr) || "0";
                    return r = i = o = l = c = u = h = d = p = 0, a = s = 1, n.svg = !(!e.getCTM || !mn(e)), f = Mn(e, n.svg), n.svg && Tn(e, z, n.originIsAbsolute, !1 !== n.smooth, f), f !== xr && (y = f[0], x = f[1], b = f[2], _ = f[3], r = w = f[4], i = S = f[5], 6 === f.length ? (a = Math.sqrt(y * y + x * x), s = Math.sqrt(_ * _ + b * b), l = y || x ? ar(x, y) * ir : 0, h = b || _ ? ar(b, _) * ir + l : 0, n.svg && (r -= N - (N * y + k * b), i -= k - (N * x + k * _))) : (O = f[6], R = f[7], C = f[8], L = f[9], A = f[10], P = f[11], r = f[12], i = f[13], o = f[14], c = (m = ar(O, A)) * ir, m && (M = w * (v = Math.cos(-m)) + C * (g = Math.sin(-m)), T = S * v + L * g, E = O * v + A * g, C = w * -g + C * v, L = S * -g + L * v, A = O * -g + A * v, P = R * -g + P * v, w = M, S = T, O = E), u = (m = ar(-b, A)) * ir, m && (v = Math.cos(-m), P = _ * (g = Math.sin(-m)) + P * v, y = M = y * v - C * g, x = T = x * v - L * g, b = E = b * v - A * g), l = (m = ar(x, y)) * ir, m && (M = y * (v = Math.cos(m)) + x * (g = Math.sin(m)), T = w * v + S * g, x = x * v - y * g, S = S * v - w * g, y = M, w = T), c && 359.9 < Math.abs(c) + Math.abs(l) && (c = l = 0, u = 180 - u), a = U(Math.sqrt(y * y + x * x + b * b)), s = U(Math.sqrt(S * S + O * O)), m = ar(w, S), h = 2e-4 < Math.abs(m) ? m * ir : 0, p = P ? 1 / (P < 0 ? -P : P) : 0), n.svg && (f = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !wn(hn(e, dr)), f && e.setAttribute("transform", f))), 90 < Math.abs(h) && Math.abs(h) < 270 && (D ? (a *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (s *= -1, h += h <= 0 ? 180 : -180)), n.x = ((n.xPercent = r && Math.round(e.offsetWidth / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + "px", n.y = ((n.yPercent = i && Math.round(e.offsetHeight / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + "px", n.z = o + "px", n.scaleX = U(a), n.scaleY = U(s), n.rotation = U(l) + "deg", n.rotationX = U(c) + "deg", n.rotationY = U(u) + "deg", n.skewX = h + "deg", n.skewY = d + "deg", n.transformPerspective = p + "px", (n.zOrigin = parseFloat(z.split(" ")[2]) || 0) && (I[pr] = wr(z)), n.xOffset = n.yOffset = 0, n.force3D = Ce.force3D, n.renderTransform = n.svg ? Er : Nn ? Tr : Sr, n.uncache = 0, n
                },
                wr = function(e) {
                    return (e = e.split(" "))[0] + " " + e[1]
                },
                Sr = function(e, t) {
                    t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Tr(e, t)
                },
                Mr = "0deg",
                Tr = function(e, t) {
                    var n = t || this,
                        r = n.xPercent,
                        i = n.yPercent,
                        o = n.x,
                        a = n.y,
                        s = n.z,
                        l = n.rotation,
                        c = n.rotationY,
                        u = n.rotationX,
                        h = n.skewX,
                        d = n.skewY,
                        p = n.scaleX,
                        f = n.scaleY,
                        m = n.transformPerspective,
                        v = n.force3D,
                        g = n.target,
                        y = n.zOrigin,
                        x = "",
                        b = "auto" === v && e && 1 !== e || !0 === v;
                    if (y && (u !== Mr || c !== Mr)) {
                        var _, w = parseFloat(c) * or,
                            S = Math.sin(w),
                            M = Math.cos(w);
                        w = parseFloat(u) * or, _ = Math.cos(w), o = En(g, o, S * _ * -y), a = En(g, a, -Math.sin(w) * -y), s = En(g, s, M * _ * -y + y)
                    }(r || i) && (x = "translate(" + r + "%, " + i + "%) "), !b && "0px" === o && "0px" === a && "0px" === s || (x += "0px" !== s || b ? "translate3d(" + o + ", " + a + ", " + s + ") " : "translate(" + o + ", " + a + ") "), "0px" !== m && (x += "perspective(" + m + ") "), l !== Mr && (x += "rotate(" + l + ") "), c !== Mr && (x += "rotateY(" + c + ") "), u !== Mr && (x += "rotateX(" + u + ") "), h === Mr && d === Mr || (x += "skew(" + h + ", " + d + ") "), 1 === p && 1 === f || (x += "scale(" + p + ", " + f + ") "), g.style[dr] = x || "translate(0, 0)"
                },
                Er = function(e, t) {
                    var n, r, i, o, a, s = t || this,
                        l = s.xPercent,
                        c = s.yPercent,
                        u = s.x,
                        h = s.y,
                        d = s.rotation,
                        p = s.skewX,
                        f = s.skewY,
                        m = s.scaleX,
                        v = s.scaleY,
                        g = s.target,
                        y = s.xOrigin,
                        x = s.yOrigin,
                        b = s.xOffset,
                        _ = s.yOffset,
                        w = s.forceCSS,
                        S = parseFloat(u),
                        M = parseFloat(h);
                    d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= or, p *= or, n = Math.cos(d) * m, r = Math.sin(d) * m, i = Math.sin(d - p) * -v, o = Math.cos(d - p) * v, p && (f *= or, a = Math.tan(p - f), i *= a = Math.sqrt(1 + a * a), o *= a, f && (a = Math.tan(f), n *= a = Math.sqrt(1 + a * a), r *= a)), n = U(n), r = U(r), i = U(i), o = U(o)) : (n = m, o = v, r = i = 0), (S && !~(u + "").indexOf("px") || M && !~(h + "").indexOf("px")) && (S = yn(g, "x", u, "px"), M = yn(g, "y", h, "px")), (y || x || b || _) && (S = U(S + y - (y * n + x * i) + b), M = U(M + x - (y * r + x * o) + _)), (l || c) && (a = g.getBBox(), S = U(S + l / 100 * a.width), M = U(M + c / 100 * a.height)), a = "matrix(" + n + "," + r + "," + i + "," + o + "," + S + "," + M + ")", g.setAttribute("transform", a), w && (g.style[dr] = a)
                },
                Cr = {
                    name: "css",
                    register: dn,
                    targetTest: function(e) {
                        return e.style && e.nodeType
                    },
                    init: function(e, t, n, r, i) {
                        var o, a, s, l, c, u, h, d, p, f, m, v, g, y, x, b, _, w, S, M, T, E, C, L, A, R, P, O, I, D, N, k = this._props,
                            z = e.style;
                        for (h in Pn || dn(), t)
                            if ("autoRound" !== h && (a = t[h], !Ye[h] || !Mt(h, t, n, r, e, i)))
                                if (u = yr[h], "function" === (c = typeof a) && (c = typeof(a = a.call(n, r, e, i))), "string" === c && ~a.indexOf("random(") && (a = Y(a)), u) u(this, e, h, a, n) && (x = 1);
                                else if ("--" === h.substr(0, 2)) this.add(z, "setProperty", getComputedStyle(e).getPropertyValue(h) + "", a + "", r, i, 0, 0, h);
                        else {
                            if (o = xn(e, h), l = parseFloat(o), (f = "string" === c && "=" === a.charAt(1) ? +(a.charAt(0) + "1") : 0) && (a = a.substr(2)), s = parseFloat(a), h in hr && ("autoAlpha" === h && (1 === l && "hidden" === xn(e, "visibility") && s && (l = 0), gn(this, z, "visibility", l ? "inherit" : "hidden", s ? "inherit" : "hidden", !s)), "scale" !== h && "transform" !== h && ~(h = hr[h]).indexOf(",") && (h = h.split(",")[0])), m = h in rr)
                                if (v || (g = e._gsap, y = !1 !== t.smoothOrigin && g.smooth, (v = this._pt = new jt(this._pt, z, dr, 0, 1, g.renderTransform, g, 0, -1)).dep = 1), "scale" === h) this._pt = new jt(this._pt, g, "scaleY", g.scaleY, f ? f * s : s - g.scaleY), k.push("scaleY", h), h += "X";
                                else {
                                    if ("transformOrigin" === h) {
                                        N = D = I = void 0, I = (O = a).split(" "), D = I[0], N = I[1] || "50%", "top" !== D && "bottom" !== D && "left" !== N && "right" !== N || (O = D, D = N, N = O), I[0] = gr[D] || D, I[1] = gr[N] || N, a = I.join(" "), g.svg ? Tn(e, a, 0, y, 0, this) : ((p = parseFloat(a.split(" ")[2])) !== g.zOrigin && gn(this, g, "zOrigin", g.zOrigin, p), gn(this, z, h, wr(o), wr(a)));
                                        continue
                                    }
                                    if ("svgOrigin" === h) {
                                        Tn(e, a, 1, y, 0, this);
                                        continue
                                    }
                                    if (h in br) {
                                        b = this, _ = g, w = h, S = l, T = f, R = C = E = void 0, L = F(M = a), A = parseFloat(M) * (L && ~M.indexOf("rad") ? ir : 1), P = S + (R = T ? A * T : A - S) + "deg", L && ("short" === (E = M.split("_")[1]) && (R %= 360) != R % 180 && (R += R < 0 ? 360 : -360), "cw" === E && R < 0 ? R = (R + 36e9) % 360 - 360 * ~~(R / 360) : "ccw" === E && 0 < R && (R = (R - 36e9) % 360 - 360 * ~~(R / 360))), b._pt = C = new jt(b._pt, _, w, S, R, Qt), C.e = P, C.u = "deg", b._props.push(w);
                                        continue
                                    }
                                    if ("smoothOrigin" === h) {
                                        gn(this, g, "smooth", g.smooth, a);
                                        continue
                                    }
                                    if ("force3D" === h) {
                                        g[h] = a;
                                        continue
                                    }
                                    if ("transform" === h) {
                                        Cn(this, a, e);
                                        continue
                                    }
                                } else h in z || (h = mr(h) || h);
                            if (m || (s || 0 === s) && (l || 0 === l) && !ur.test(a) && h in z)(d = (o + "").substr((l + "").length)) !== (p = (a + "").substr((s + "").length) || (h in Ce.units ? Ce.units[h] : d)) && (l = yn(e, h, o, p)), this._pt = new jt(this._pt, m ? g : z, h, l, f ? f * s : s - l, "px" !== p || !1 === t.autoRound || m ? Jt : en), this._pt.u = p || 0, d !== p && (this._pt.b = o, this._pt.r = $t);
                            else if (h in z) bn.call(this, e, h, o, a);
                            else {
                                if (!(h in e)) {
                                    B(h, a);
                                    continue
                                }
                                this.add(e, h, e[h], a, r, i)
                            }
                            k.push(h)
                        }
                        x && Wt(this)
                    },
                    get: xn,
                    aliases: hr,
                    getSetter: function(e, t, n) {
                        return t in rr && t !== pr && (e._gsap.x || xn(e, "x")) ? n && Dn === n ? "scale" === t ? sn : an : (Dn = n || {}) && ("scale" === t ? ln : cn) : e.style && !r(e.style[t]) ? rn : ~t.indexOf("-") ? on : zt(e, t)
                    }
                };
            Kt.utils.checkPrefix = mr, Fn = f((kn = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (zn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function(e) {
                rr[e] = 1
            }), f(zn, function(e) {
                Ce.units[e] = "deg", br[e] = 1
            }), hr[Fn[13]] = kn + "," + zn, f("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,9:rotateX,10:rotateY", function(e) {
                var t = e.split(":");
                hr[t[1]] = Fn[t[0]]
            }), f("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(e) {
                Ce.units[e] = "px"
            }), Kt.registerPlugin(Cr);
            var Lr = Kt.registerPlugin(Cr) || Kt;
            e.Back = Jn, e.Bounce = $n, e.CSSPlugin = Cr, e.Circ = nr, e.Cubic = qn, e.Elastic = Kn, e.Expo = tr, e.Linear = Wn, e.Power0 = Bn, e.Power1 = Un, e.Power2 = Hn, e.Power3 = Gn, e.Power4 = Vn, e.Quad = jn, e.Quart = Xn, e.Quint = Yn, e.Sine = er, e.SteppedEase = Qn, e.Strong = Zn, e.TimelineLite = St, e.TimelineMax = St, e.TweenLite = Pt, e.TweenMax = Pt, e.default = Lr, e.gsap = Lr, "undefined" == typeof window || window !== e ? Object.defineProperty(e, "__esModule", {
                value: !0
            }) : delete window.default
        }, "object" == typeof n && void 0 !== t ? i(n) : "function" == typeof define && define.amd ? define(["exports"], i) : i((r = r || self).window = r.window || {})
    }, {}],
    10: [function(e, n, t) {
        ! function() {
            function e() {
                this._listeners = [], this.dispatchCount = 0
            }
            var t = e.prototype;
            t.add = o, t.addOnce = function(e, t, n, r) {
                if (!e) throw c;
                var i = this;
                1 === (r = u.call(arguments, 0)).length && r.push(void 0);
                r.splice(2, 0, function() {
                    return i.remove.call(i, e, t), e.apply(t, u.call(arguments, 0))
                }), o.apply(i, r)
            }, t.remove = function(e, t) {
                if (!e) return !(this._listeners.length = 0);
                var n, r = this._listeners,
                    i = r.length;
                for (; i--;)
                    if ((n = r[i]).f === e && (!t || n.c === t)) return n.j = 0, r.splice(i, 1), !0;
                return !1
            }, t.dispatch = function(e) {
                e = u.call(arguments, 0), this.dispatchCount++;
                var t, n, r = this.dispatchCount,
                    i = this._listeners,
                    o = i.length;
                for (; o--;)
                    if ((t = i[o]) && t.j < r && (t.j = r, !1 === t.r.apply(t.c, t.a.concat(e)))) {
                        n = t;
                        break
                    }
                i = this._listeners, o = i.length;
                for (; o--;) i[o].j = 0;
                return n
            };
            var c = "Callback function is missing!",
                u = Array.prototype.slice;

            function o(e, t, n, r) {
                if (!e) throw c;
                n = n || 0;
                for (var i, o, a, s = this._listeners, l = s.length; l--;)
                    if ((i = s[l]).f === e && i.c === t) return !1;
                    "function" == typeof n && (o = n, n = r, a = 4), s.unshift({
                        f: e,
                        c: t,
                        p: n,
                        r: o || e,
                        a: u.call(arguments, a || 3),
                        j: 0
                    }),
                    function(e) {
                        e.sort(function(e, t) {
                            return e = e.p, (t = t.p) < e ? 1 : t < e ? -1 : 0
                        })
                    }(s)
            }
            void 0 !== n && (n.exports = e)
        }()
    }, {}],
    11: [function(e, t, n) {
        t.exports = function(e, t, n) {
            if (null != e)
                for (var r = -1, i = e.length; ++r < i && !1 !== t.call(n, e[r], r, e););
        }
    }, {}],
    12: [function(e, t, n) {
        var o = e("../random/randInt");
        t.exports = function(e) {
            var t, n = [];
            if (null == e) return n;
            for (var r = -1, i = e.length; ++r < i;) r ? (t = o(0, r), n[r] = n[t], n[t] = e[r]) : n[0] = e[0];
            return n
        }
    }, {
        "../random/randInt": 38
    }],
    13: [function(e, t, n) {
        var r = e("./kindOf"),
            i = e("./isPlainObject"),
            o = e("../object/mixIn");
        t.exports = function(e) {
            switch (r(e)) {
                case "Object":
                    return function(e) {
                        return i(e) ? o({}, e) : e
                    }(e);
                case "Array":
                    return function(e) {
                        return e.slice()
                    }(e);
                case "RegExp":
                    return function(e) {
                        var t = "";
                        return t += e.multiline ? "m" : "", t += e.global ? "g" : "", t += e.ignoreCase ? "i" : "", new RegExp(e.source, t)
                    }(e);
                case "Date":
                    return function(e) {
                        return new Date(+e)
                    }(e);
                default:
                    return e
            }
        }
    }, {
        "../object/mixIn": 32,
        "./isPlainObject": 21,
        "./kindOf": 23
    }],
    14: [function(e, t, n) {
        var r = e("./clone"),
            i = e("../object/forOwn"),
            o = e("./kindOf"),
            a = e("./isPlainObject");

        function s(e, t) {
            switch (o(e)) {
                case "Object":
                    return function(e, n) {
                        {
                            if (a(e)) {
                                var t = {};
                                return i(e, function(e, t) {
                                    this[t] = s(e, n)
                                }, t), t
                            }
                            return n ? n(e) : e
                        }
                    }(e, t);
                case "Array":
                    return function(e, t) {
                        var n = [],
                            r = -1,
                            i = e.length;
                        for (; ++r < i;) n[r] = s(e[r], t);
                        return n
                    }(e, t);
                default:
                    return r(e)
            }
        }
        t.exports = s
    }, {
        "../object/forOwn": 28,
        "./clone": 13,
        "./isPlainObject": 21,
        "./kindOf": 23
    }],
    15: [function(e, t, n) {
        var r = e("./isKind"),
            i = Array.isArray || function(e) {
                return r(e, "Array")
            };
        t.exports = i
    }, {
        "./isKind": 18
    }],
    16: [function(e, t, n) {
        var r = e("./isKind");
        t.exports = function(e) {
            return r(e, "Boolean")
        }
    }, {
        "./isKind": 18
    }],
    17: [function(e, t, n) {
        var r = e("./isNumber");
        t.exports = function(e) {
            return r(e) && e % 1 == 0
        }
    }, {
        "./isNumber": 19
    }],
    18: [function(e, t, n) {
        var r = e("./kindOf");
        t.exports = function(e, t) {
            return r(e) === t
        }
    }, {
        "./kindOf": 23
    }],
    19: [function(e, t, n) {
        var r = e("./isKind");
        t.exports = function(e) {
            return r(e, "Number")
        }
    }, {
        "./isKind": 18
    }],
    20: [function(e, t, n) {
        var r = e("./isKind");
        t.exports = function(e) {
            return r(e, "Object")
        }
    }, {
        "./isKind": 18
    }],
    21: [function(e, t, n) {
        t.exports = function(e) {
            return !!e && "object" == typeof e && e.constructor === Object
        }
    }, {}],
    22: [function(e, t, n) {
        t.exports = function(e) {
            switch (typeof e) {
                case "string":
                case "number":
                case "boolean":
                    return !0
            }
            return null == e
        }
    }, {}],
    23: [function(e, t, n) {
        t.exports = function(e) {
            return Object.prototype.toString.call(e).slice(8, -1)
        }
    }, {}],
    24: [function(e, t, n) {
        t.exports = function(e) {
            return null == e ? "" : e.toString()
        }
    }, {}],
    25: [function(e, t, n) {
        t.exports = 2147483647
    }, {}],
    26: [function(e, t, n) {
        t.exports = -2147483648
    }, {}],
    27: [function(e, t, n) {
        var s, l, c = e("./hasOwn");

        function u(e, t, n, r) {
            return e.call(r, t[n], n, t)
        }
        t.exports = function(e, t, n) {
            var r, i = 0;
            for (r in null == s && function() {
                    for (var e in l = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], s = !0, {
                            toString: null
                        }) s = !1
                }(), e)
                if (!1 === u(t, e, r, n)) break;
            if (s)
                for (var o = e.constructor, a = !!o && e === o.prototype;
                    (r = l[i++]) && ("constructor" === r && (a || !c(e, r)) || e[r] === Object.prototype[r] || !1 !== u(t, e, r, n)););
        }
    }, {
        "./hasOwn": 30
    }],
    28: [function(e, t, n) {
        var o = e("./hasOwn"),
            a = e("./forIn");
        t.exports = function(n, r, i) {
            a(n, function(e, t) {
                if (o(n, t)) return r.call(i, n[t], t, n)
            })
        }
    }, {
        "./forIn": 27,
        "./hasOwn": 30
    }],
    29: [function(e, t, n) {
        e("../lang/isPrimitive");
        t.exports = function(e, t) {
            for (var n = t.split("."), r = n.pop(); t = n.shift();)
                if (null == (e = e[t])) return;
            return e[r]
        }
    }, {
        "../lang/isPrimitive": 22
    }],
    30: [function(e, t, n) {
        t.exports = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }
    }, {}],
    31: [function(e, t, n) {
        var a = e("./hasOwn"),
            s = e("../lang/deepClone"),
            l = e("../lang/isObject");
        t.exports = function e() {
            var t, n, r, i, o = 1;
            for (i = s(arguments[0]); r = arguments[o++];)
                for (t in r) a(r, t) && (n = r[t], l(n) && l(i[t]) ? i[t] = e(i[t], n) : i[t] = s(n));
            return i
        }
    }, {
        "../lang/deepClone": 14,
        "../lang/isObject": 20,
        "./hasOwn": 30
    }],
    32: [function(e, t, n) {
        var o = e("./forOwn");

        function a(e, t) {
            this[t] = e
        }
        t.exports = function(e, t) {
            for (var n, r = 0, i = arguments.length; ++r < i;) null != (n = arguments[r]) && o(n, a, e);
            return e
        }
    }, {
        "./forOwn": 28
    }],
    33: [function(e, t, n) {
        var c = e("../string/typecast"),
            u = e("../lang/isArray"),
            h = e("../object/hasOwn");
        t.exports = function(e, t) {
            for (var n, r, i, o, a = (e || "").replace("?", "").split("&"), s = -1, l = {}; r = a[++s];) n = r.indexOf("="), o = r.substring(0, n), i = decodeURIComponent(r.substring(n + 1)), !1 !== t && (i = c(i)), h(l, o) ? u(l[o]) ? l[o].push(i) : l[o] = [l[o], i] : l[o] = i;
            return l
        }
    }, {
        "../lang/isArray": 15,
        "../object/hasOwn": 30,
        "../string/typecast": 44
    }],
    34: [function(e, t, n) {
        var o = e("../object/forOwn"),
            a = e("../lang/isArray"),
            s = e("../array/forEach");
        t.exports = function(e) {
            var n, r, i = [];
            return o(e, function(e, t) {
                a(e) ? (n = t + "=", r = new RegExp("&" + t + "+=$"), s(e, function(e) {
                    n += encodeURIComponent(e) + "&" + t + "="
                }), i.push(n.replace(r, ""))) : i.push(t + "=" + encodeURIComponent(e))
            }), i.length ? "?" + i.join("&") : ""
        }
    }, {
        "../array/forEach": 11,
        "../lang/isArray": 15,
        "../object/forOwn": 28
    }],
    35: [function(e, t, n) {
        t.exports = function(e) {
            var t = /\?[a-zA-Z0-9\=\&\%\$\-\_\.\+\!\*\'\(\)\,]+/.exec(e);
            return t ? decodeURIComponent(t[0].replace(/\+/g, " ")) : ""
        }
    }, {}],
    36: [function(e, t, n) {
        var r = e("./decode"),
            i = e("./getQuery");
        t.exports = function(e, t) {
            return r(i(e), t)
        }
    }, {
        "./decode": 33,
        "./getQuery": 35
    }],
    37: [function(e, t, n) {
        var r = e("./random"),
            i = e("../number/MIN_INT"),
            o = e("../number/MAX_INT");
        t.exports = function(e, t) {
            return (e = null == e ? i : e) + ((t = null == t ? o : t) - e) * r()
        }
    }, {
        "../number/MAX_INT": 25,
        "../number/MIN_INT": 26,
        "./random": 39
    }],
    38: [function(e, t, n) {
        var r = e("../number/MIN_INT"),
            i = e("../number/MAX_INT"),
            o = e("./rand");
        t.exports = function(e, t) {
            return e = null == e ? r : ~~e, t = null == t ? i : ~~t, Math.round(o(e - .5, t + .499999999999))
        }
    }, {
        "../number/MAX_INT": 25,
        "../number/MIN_INT": 26,
        "./rand": 37
    }],
    39: [function(e, t, n) {
        function r() {
            return r.get()
        }
        r.get = Math.random, t.exports = r
    }, {}],
    40: [function(e, t, n) {
        t.exports = [" ", "\n", "\r", "\t", "\f", "\v", "Â ", "áš€", "á Ž", "â€€", "â€", "â€‚", "â€ƒ", "â€„", "â€…", "â€†", "â€‡", "â€ˆ", "â€‰", "â€Š", "\u2028", "\u2029", "â€¯", "âŸ", "ã€€"]
    }, {}],
    41: [function(e, t, n) {
        var l = e("../lang/toString"),
            c = e("./WHITE_SPACES");
        t.exports = function(e, t) {
            e = l(e), t = t || c;
            for (var n, r, i = 0, o = e.length, a = t.length, s = !0; s && i < o;)
                for (s = !1, n = -1, r = e.charAt(i); ++n < a;)
                    if (r === t[n]) {
                        s = !0, i++;
                        break
                    }
            return o <= i ? "" : e.substr(i, o)
        }
    }, {
        "../lang/toString": 24,
        "./WHITE_SPACES": 40
    }],
    42: [function(e, t, n) {
        var s = e("../lang/toString"),
            l = e("./WHITE_SPACES");
        t.exports = function(e, t) {
            e = s(e), t = t || l;
            for (var n, r, i = e.length - 1, o = t.length, a = !0; a && 0 <= i;)
                for (a = !1, n = -1, r = e.charAt(i); ++n < o;)
                    if (r === t[n]) {
                        a = !0, i--;
                        break
                    }
            return 0 <= i ? e.substring(0, i + 1) : ""
        }
    }, {
        "../lang/toString": 24,
        "./WHITE_SPACES": 40
    }],
    43: [function(e, t, n) {
        var r = e("../lang/toString"),
            i = e("./WHITE_SPACES"),
            o = e("./ltrim"),
            a = e("./rtrim");
        t.exports = function(e, t) {
            return e = r(e), o(a(e, t = t || i), t)
        }
    }, {
        "../lang/toString": 24,
        "./WHITE_SPACES": 40,
        "./ltrim": 41,
        "./rtrim": 42
    }],
    44: [function(e, t, n) {
        t.exports = function(e) {
            return null === e || "null" === e ? null : "true" === e || "false" !== e && (void 0 === e || "undefined" === e ? void 0 : "" === e || isNaN(e) ? e : parseFloat(e))
        }
    }, {}],
    45: [function(e, t, n) {
        t.exports = e("./src/quickLoader"), e("./src/types/JSONPItem"), e("./src/types/JSONItem"), e("./src/types/TextItem"), e("./src/types/AudioItem"), e("./src/types/VideoItem"), e("./src/types/AnyItem"), e("./src/types/ImageItem"), e("./src/types/XHRItem")
    }, {
        "./src/quickLoader": 46,
        "./src/types/AnyItem": 48,
        "./src/types/AudioItem": 49,
        "./src/types/ImageItem": 50,
        "./src/types/JSONItem": 51,
        "./src/types/JSONPItem": 52,
        "./src/types/TextItem": 53,
        "./src/types/VideoItem": 54,
        "./src/types/XHRItem": 55
    }],
    46: [function(e, t, n) {
        var s, a = e("min-signal");

        function r() {
            this.isLoading = !1, this.totalWeight = 0, this.loadedWeight = 0, this.itemUrls = {}, this.itemList = [], this.loadingSignal = new a, this.crossOriginMap = {}, this.queue = [], this.activeItems = [], this.maxActiveItems = 4
        }
        var i = r.prototype;
        i.addChunk = function(e, t) {
            var n, r, i, o, a, s = g(e, t);
            for (n = 0, i = s.length; n < i; n++)
                for (a = s[n], r = 0, o = a.items.length; r < o; r++) this.add(a.items[r], {
                    type: a.type
                });
            return s
        }, i.setCrossOrigin = function(e, t) {
            this.crossOriginMap[e] = t
        }, i.add = function(e, t) {
            var n = l[e];
            n = n || this._createItem(e, t && t.type ? t.type : y(e).type, t);
            t && t.onLoad && n.onLoaded.addOnce(t.onLoad);
            this.itemUrls[e] || (this.itemUrls[e] = n, this.itemList.push(n), this.totalWeight += n.weight);
            return n
        }, i.load = d, i.start = function(e) {
            e && this.loadingSignal.add(e);
            this.isLoading = !0;
            var t = this.itemList.length;
            if (t) {
                for (var n, r = this.itemList.splice(0, this.itemList.length), i = 0; i < t; i++) {
                    n = r[i];
                    var o = !!c[n.url];
                    n.onLoaded.addOnce(m, this, -1024, n, r, o), n.hasLoading && n.loadingSignal.add(p, this, -1024, n, r, s), o ? n.dispatch(m) : n.isStartLoaded || this.queue.push(n)
                }
                this.queue.length && this.loadNext()
            } else m.call(this, s, this.itemList)
        }, i.loadNext = function() {
            if (this.queue.length && this.activeItems.length < this.maxActiveItems) {
                var e = this.queue.shift();
                this.activeItems.push(e), this.loadNext(), e.load()
            }
        }, i._createItem = function(e, t, n) {
            if (!(n = n || {}).crossOrigin)
                for (var r in this.crossOriginMap)
                    if (0 === e.indexOf(r)) {
                        n.crossOrigin = this.crossOriginMap[r];
                        break
                    }
            return new h[t](e, n)
        }, i._onLoading = p;
        var o = t.exports = b();
        o.version = "0.1.9", o.register = function(e) {
            h[e.type] || (u.push(e), h[e.type] = e)
        }, o.retrieveAll = g, o.retrieve = y, o.testExtensions = x, o.create = b, o.load = d, o.check = function() {
            var e = [],
                t = [];
            for (var n in l) e.push(n), c[n] || t.push(l[n]);
            console.log({
                added: e,
                notLoaded: t
            })
        };
        var l = o.addedItems = {},
            c = o.loadedItems = {},
            u = o.ITEM_CLASS_LIST = [],
            h = o.ITEM_CLASSES = {};

        function d(e, t) {
            var n = l[e];
            return n = n || this._createItem(e, t && t.type ? t.type : y(e).type, t), t && t.onLoad && n.onLoaded.addOnce(t.onLoad), c[e] ? n.dispatch() : n.isStartLoaded || n.load(), n
        }

        function p(e, t, n, r, i) {
            e && !e.isLoaded && 1 === r || (i === s && (this.loadedWeight = f(t), i = this.loadedWeight / this.totalWeight), (n = n || this.loadingSignal).dispatch(i, e))
        }

        function f(e) {
            for (var t = 0, n = 0, r = e.length; n < r; n++) t += e[n].loadedWeight;
            return t
        }

        function m(e, t, n) {
            if (this.loadedWeight = f(t), !n)
                for (var r = this.activeItems, i = r.length; i--;)
                    if (r[i] === e) {
                        r.splice(i, 1);
                        break
                    }
            var o = this.loadingSignal;
            this.loadedWeight === this.totalWeight ? (this.isLoading = !1, this.loadedWeight = 0, this.totalWeight = 0, this.loadingSignal = new a, this._onLoading(e, t, o, 1, 1), e && e.noCache && v(e)) : (this._onLoading(e, t, o, 1, this.loadedWeight / this.totalWeight), e && e.noCache && v(e), n || this.loadNext())
        }

        function v(e) {
            var t = e.url;
            e.content = s, l[t] = s, c[t] = s
        }

        function g(e, t) {
            var n, r, i = e.length,
                o = [];
            if (i && "string" != typeof e)
                for (n = 0; n < i; n++)(r = y(e[n], t)) && (o = o.concat(r));
            else(r = y(e, t)) && (o = o.concat(r));
            return o
        }

        function y(e, t) {
            var n, r, i, o, a;
            if (t) i = (o = h[t]).retrieve(e);
            else
                for (n = 0, r = u.length; n < r; n++) {
                    if (a = (o = u[n]).type, "string" == typeof e) {
                        if (x(e, o)) {
                            i = [e];
                            break
                        }
                    } else if ((i = o.retrieve(e)) && i.length && "string" == typeof i[0] && x(i[0], o)) break;
                    a = i = s
                }
            if (i) return {
                type: t || a,
                items: i
            }
        }

        function x(e, t) {
            if (e) {
                for (var n = function(e) {
                        return e.split(".").pop().split(/#|\?/)[0]
                    }(e), r = t.extensions, i = r.length; i--;)
                    if (n === r[i]) return !0;
                return !1
            }
        }

        function b() {
            return new r
        }
    }, {
        "min-signal": 10
    }],
    47: [function(e, t, n) {
        var i = e("min-signal"),
            o = e("../quickLoader");

        function r(e, t) {
            if (e) {
                for (var n in this.url = e, this.loadedWeight = 0, this.weight = 1, t) this[n] = t[n];
                this.type || (this.type = this.constructor.type), this.hasLoading && (this.loadingSignal = new i, this.loadingSignal.add(s, this), this.onLoading && this.loadingSignal.add(this.onLoading));
                var r = this;
                this.boundOnLoad = function() {
                    r._onLoad()
                }, this.onLoaded = new i, o.addedItems[e] = this
            }
        }
        var a = (t.exports = r).prototype;

        function s(e) {
            this.loadedWeight = this.weight * e
        }
        a.load = function() {
            this.isStartLoaded = !0
        }, a._onLoad = function() {
            this.isLoaded = !0, this.loadedWeight = this.weight, (o.loadedItems[this.url] = this).onLoaded.dispatch(this.content)
        }, a._onLoading = s, a.dispatch = function() {
            this.hasLoading && this.loadingSignal.remove();
            this.onLoaded.dispatch(this.content)
        }, r.extensions = [], r.retrieve = function() {
            return !1
        }
    }, {
        "../quickLoader": 46,
        "min-signal": 10
    }],
    48: [function(e, t, n) {
        var r = e("./AbstractItem"),
            i = e("../quickLoader");

        function o(e, t) {
            e && (a.constructor.call(this, e, t), !this.loadFunc && console && console[console.error || console.log]("require loadFunc in the config object."))
        }(t.exports = o).type = "any", o.extensions = [], i.register(o), o.retrieve = function() {
            return !1
        };
        var a = r.prototype,
            s = o.prototype = new r;
        s.constructor = o, s.load = function() {
            var t = this;
            this.loadFunc(this.url, function(e) {
                t.content = e, a._onLoad.call(t)
            }, this.loadingSignal)
        }
    }, {
        "../quickLoader": 46,
        "./AbstractItem": 47
    }],
    49: [function(e, t, n) {
        var r = e("./AbstractItem"),
            i = e("../quickLoader");

        function o(e, t) {
            if (e) {
                this.loadThrough = !t || void 0 === t.loadThrough || t.loadThrough, a.constructor.apply(this, arguments);
                try {
                    this.content = new Audio
                } catch (e) {
                    this.content = document.createElement("audio")
                }
                this.crossOrigin && (this.content.crossOrigin = this.crossOrigin)
            }
        }(t.exports = o).type = "audio", o.extensions = ["mp3", "ogg"], i.register(o), o.retrieve = function(e) {
            return !1
        };
        var a = r.prototype,
            s = o.prototype = new r;
        s.constructor = o, s.load = function() {
            a.load.apply(this, arguments);
            var e = this.content;
            e.src = this.url, this.loadThrough ? e.addEventListener("canplaythrough", this.boundOnLoad, !1) : e.addEventListener("canplay", this.boundOnLoad, !1);
            e.load()
        }, s._onLoad = function() {
            if (this.content.removeEventListener("canplaythrough", this.boundOnLoad, !1), this.content.removeEventListener("canplay", this.boundOnLoad, !1), this.isLoaded) return;
            a._onLoad.call(this)
        }
    }, {
        "../quickLoader": 46,
        "./AbstractItem": 47
    }],
    50: [function(e, t, n) {
        var r = e("./AbstractItem"),
            i = e("computed-style"),
            o = e("../quickLoader");

        function a(e, t) {
            e && (s.constructor.apply(this, arguments), this.content = new Image, this.crossOrigin && (this.content.crossOrigin = this.crossOrigin))
        }
        t.exports = a;
        var s = r.prototype,
            l = a.prototype = new r;
        l.constructor = a, l.load = function() {
            s.load.apply(this, arguments);
            var e = this.content;
            e.onload = this.boundOnLoad, e.src = this.url
        }, l._onLoad = function() {
            delete this.content.onload, this.width = this.content.width, this.height = this.content.height, s._onLoad.call(this)
        }, a.retrieve = function(e) {
            if (e.nodeType && e.style) {
                var n = [];
                "img" === e.nodeName.toLowerCase() && e.src.indexOf(";") < 0 && n.push(e.src), i(e, "background-image").replace(/s?url\(\s*?['"]?([^;]*?)['"]?\s*?\)/g, function(e, t) {
                    n.push(t)
                });
                for (var t = n.length; t--;) 0 === n[t].indexOf("data:") && n.splice(t, 1);
                return !!n.length && n
            }
            return "string" == typeof e && [e]
        }, a.type = "image", a.extensions = ["jpg", "gif", "png"], o.register(a)
    }, {
        "../quickLoader": 46,
        "./AbstractItem": 47,
        "computed-style": 7
    }],
    51: [function(require, module, exports) {
        var TextItem = require("./TextItem"),
            quickLoader = require("../quickLoader");

        function JSONItem(e) {
            e && _super.constructor.apply(this, arguments)
        }
        module.exports = JSONItem, JSONItem.type = "json", JSONItem.extensions = ["json"], quickLoader.register(JSONItem), JSONItem.retrieve = function() {
            return !1
        };
        var _super = TextItem.prototype,
            _p = JSONItem.prototype = new TextItem;

        function _onLoad() {
            this.content || (this.content = window.JSON && window.JSON.parse ? JSON.parse(this.xmlhttp.responseText.toString()) : eval(this.xmlhttp.responseText.toString())), _super._onLoad.call(this)
        }
        _p.constructor = JSONItem, _p._onLoad = _onLoad
    }, {
        "../quickLoader": 46,
        "./TextItem": 53
    }],
    52: [function(e, t, n) {
        var r = e("./AbstractItem"),
            i = e("../quickLoader");

        function o(e) {
            e && a.constructor.apply(this, arguments)
        }(t.exports = o).type = "jsonp", o.extensions = [], i.register(o), o.retrieve = function(e) {
            return "string" == typeof e && -1 < e.indexOf("=") && [e]
        };
        var a = r.prototype,
            s = o.prototype = new r;
        s.constructor = o, s.load = function(e) {
            a.load.apply(this, arguments);
            var t = this,
                n = this.url.lastIndexOf("=") + 1,
                r = this.url.substr(0, n),
                i = this.url.substr(n);
            0 === i.length ? (i = "_jsonp" + (new Date).getTime() + ~~(1e8 * Math.random()), this.jsonpCallback = e) : this.jsonpCallback = this.jsonpCallback || window[i];
            window[i] = function(e) {
                o.parentNode && o.parentNode.removeChild(o), t.content = e, t._onLoad()
            };
            var o = document.createElement("script");
            o.type = "text/javascript", o.src = r + i, document.getElementsByTagName("head")[0].appendChild(o)
        }
    }, {
        "../quickLoader": 46,
        "./AbstractItem": 47
    }],
    53: [function(e, t, n) {
        var r = e("./XHRItem"),
            i = e("../quickLoader");

        function o(e, t) {
            e && (t.responseType = "text", a.constructor.apply(this, arguments))
        }(t.exports = o).type = "text", o.extensions = ["html", "txt", "svg"], i.register(o), o.retrieve = function() {
            return !1
        };
        var a = r.prototype,
            s = o.prototype = new r;
        s.constructor = o, s._onLoad = function() {
            this.content || (this.content = this.xmlhttp.responseText);
            a._onLoad.apply(this, arguments)
        }
    }, {
        "../quickLoader": 46,
        "./XHRItem": 55
    }],
    54: [function(e, t, n) {
        var r = e("./AbstractItem"),
            i = e("../quickLoader");

        function o(e, t) {
            if (e) {
                this.loadThrough = !t || void 0 === t.loadThrough || t.loadThrough, a.constructor.apply(this, arguments);
                try {
                    this.content = new Video
                } catch (e) {
                    this.content = document.createElement("video")
                }
                this.crossOrigin && (this.content.crossOrigin = this.crossOrigin)
            }
        }(t.exports = o).type = "video", o.extensions = ["mp4", "webm", "ogv"], i.register(o), o.retrieve = function(e) {
            return !1
        };
        var a = r.prototype,
            s = o.prototype = new r;
        s.constructor = o, s.load = function() {
            a.load.apply(this, arguments);
            var e = this.content;
            e.preload = "auto", e.src = this.url, this.loadThrough ? e.addEventListener("canplaythrough", this.boundOnLoad, !1) : e.addEventListener("canplay", this.boundOnLoad, !1);
            e.load()
        }, s._onLoad = function() {
            if (this.content.removeEventListener("canplaythrough", this.boundOnLoad), this.content.removeEventListener("canplay", this.boundOnLoad), this.isLoaded) return;
            a._onLoad.call(this)
        }
    }, {
        "../quickLoader": 46,
        "./AbstractItem": 47
    }],
    55: [function(e, t, n) {
        var r = e("./AbstractItem"),
            i = e("../quickLoader"),
            o = !!window.XMLHttpRequest;

        function a(e) {
            e && (s.constructor.apply(this, arguments), this.responseType = this.responseType || "", this.method = this.method || "GET")
        }(t.exports = a).type = "xhr", a.extensions = [], i.register(a), a.retrieve = function() {
            return !1
        };
        var s = r.prototype,
            l = a.prototype = new r;
        l.constructor = a, l.load = function() {
            s.load.apply(this, arguments);
            var e, t = this;
            e = this.xmlhttp = o ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP");
            this.hasLoading && (e.onprogress = function(e) {
                t._onXmlHttpProgress(e)
            });
            e.onreadystatechange = function() {
                t._onXmlHttpChange()
            }, e.open(this.method, this.url, !0), this.xmlhttp.responseType = this.responseType, o ? e.send(null) : e.send()
        }, l._onXmlHttpChange = function() {
            4 === this.xmlhttp.readyState && 200 === this.xmlhttp.status && this._onLoad(this.xmlhttp)
        }, l._onXmlHttpProgress = function(e) {
            this.loadingSignal.dispatch(e.loaded / e.total)
        }, l._onLoad = function() {
            this.content || (this.content = this.xmlhttp.response);
            this.xmlhttp = void 0, s._onLoad.call(this)
        }
    }, {
        "../quickLoader": 46,
        "./AbstractItem": 47
    }],
    56: [function(e, d, t) {
        (function(e) {
            "use strict";
            var i = [],
                o = void 0 === e ? window : e,
                a = Math.pow(256, 6),
                s = Math.pow(2, 52),
                l = 2 * s,
                t = Math.random;

            function c(e) {
                var t, n = e.length,
                    a = this,
                    r = 0,
                    i = a.i = a.j = 0,
                    o = a.S = [];
                for (n || (e = [n++]); r < 256;) o[r] = r++;
                for (r = 0; r < 256; r++) o[r] = o[i = 255 & i + e[r % n] + (t = o[r])], o[i] = t;
                (a.g = function(e) {
                    for (var t, n = 0, r = a.i, i = a.j, o = a.S; e--;) t = o[r = 255 & r + 1], n = 256 * n + o[255 & (o[r] = o[i = 255 & i + t]) + (o[i] = t)];
                    return a.i = r, a.j = i, n
                })(256)
            }

            function u(e, t) {
                for (var n, r = e + "", i = 0; i < r.length;) t[255 & i] = 255 & (n ^= 19 * t[255 & i]) + r.charCodeAt(i++);
                return h(t)
            }

            function h(e) {
                return String.fromCharCode.apply(0, e)
            }
            d.exports = function(e, t) {
                if (t && !0 === t.global) return t.global = !1, Math.random = d.exports(e, t), t.global = !0, Math.random;
                var n = [],
                    r = (u(function e(t, n) {
                        var r, i = [],
                            o = (typeof t)[0];
                        if (n && "o" == o)
                            for (r in t) try {
                                i.push(e(t[r], n - 1))
                            } catch (e) {}
                        return i.length ? i : "s" == o ? t : t + "\0"
                    }(t && t.entropy || !1 ? [e, h(i)] : 0 in arguments ? e : function(e) {
                        try {
                            return o.crypto.getRandomValues(e = new Uint8Array(256)), h(e)
                        } catch (e) {
                            return [+new Date, o, o.navigator && o.navigator.plugins, o.screen, h(i)]
                        }
                    }(), 3), n), new c(n));
                return u(h(r.S), i),
                    function() {
                        for (var e = r.g(6), t = a, n = 0; e < s;) e = 256 * (e + n), t *= 256, n = r.g(1);
                        for (; l <= e;) e /= 2, t /= 2, n >>>= 1;
                        return (e + n) / t
                    }
            }, d.exports.resetGlobal = function() {
                Math.random = t
            }, u(Math.random(), i)
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    57: [function(e, t, n) {
        var r, i;
        r = this, i = function(e) {
            "use strict";
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
                return "number" == typeof e && isFinite(e) && Math.floor(e) === e
            }), void 0 === Math.sign && (Math.sign = function(e) {
                return e < 0 ? -1 : 0 < e ? 1 : +e
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(e) {
                if (null == e) throw new TypeError("Cannot convert undefined or null to object");
                for (var t = Object(e), n = 1; n < arguments.length; n++) {
                    var r = arguments[n];
                    if (null != r)
                        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
                }
                return t
            });
            var Y = 0,
                Z = 1,
                K = 2,
                N = 1,
                k = 2,
                z = 3,
                P = 0,
                Me = 1,
                J = 2,
                a = 0,
                g = 2,
                Q = 0,
                $ = 1,
                ee = 2,
                te = 3,
                ne = 4,
                re = 5,
                ie = 100,
                oe = 101,
                ae = 102,
                se = 103,
                le = 104,
                ce = 200,
                ue = 201,
                he = 202,
                de = 203,
                pe = 204,
                fe = 205,
                me = 206,
                ve = 207,
                ge = 208,
                ye = 209,
                xe = 210,
                be = 0,
                _e = 1,
                we = 2,
                Se = 3,
                Te = 4,
                Ee = 5,
                Ce = 6,
                Le = 7,
                F = 0,
                B = 1,
                U = 2,
                H = 0,
                Ae = 1,
                G = 2,
                V = 3,
                W = 4,
                j = 5,
                q = 301,
                X = 302,
                Re = 303,
                Pe = 304,
                Oe = 305,
                Ie = 306,
                De = 307,
                Ne = 1e3,
                ke = 1001,
                ze = 1002,
                Fe = 1003,
                Be = 1004,
                Ue = 1005,
                He = 1006,
                Ge = 1007,
                Ve = 1008,
                We = 1009,
                i = 1010,
                o = 1011,
                je = 1012,
                s = 1013,
                qe = 1014,
                Xe = 1015,
                Ye = 1016,
                l = 1017,
                c = 1018,
                u = 1019,
                Ze = 1020,
                h = 1021,
                Ke = 1022,
                Je = 1023,
                d = 1024,
                p = 1025,
                r = Je,
                Qe = 1026,
                $e = 1027,
                f = 1028,
                m = 1029,
                v = 1030,
                y = 1031,
                x = 1032,
                b = 1033,
                _ = 33776,
                w = 33777,
                S = 33778,
                M = 33779,
                T = 35840,
                E = 35841,
                C = 35842,
                L = 35843,
                A = 36196,
                R = 37808,
                O = 37809,
                I = 37810,
                D = 37811,
                et = 37812,
                tt = 37813,
                nt = 37814,
                rt = 37815,
                it = 37816,
                ot = 37817,
                at = 37818,
                st = 37819,
                lt = 37820,
                ct = 37821,
                ut = 3e3,
                t = 3001,
                n = 3007,
                ht = 3002,
                dt = 3003,
                pt = 3004,
                ft = 3005,
                mt = 3006,
                vt = 3200,
                gt = 3201,
                yt = 0,
                xt = 1,
                bt = 7680,
                _t = 519,
                wt = 35044,
                St = 35048;

            function Mt() {}
            Object.assign(Mt.prototype, {
                addEventListener: function(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                },
                hasEventListener: function(e, t) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                },
                removeEventListener: function(e, t) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners[e];
                        if (void 0 !== n) {
                            var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
                        }
                    }
                },
                dispatchEvent: function(e) {
                    if (void 0 !== this._listeners) {
                        var t = this._listeners[e.type];
                        if (void 0 !== t) {
                            e.target = this;
                            for (var n = t.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, e)
                        }
                    }
                }
            });
            for (var Tt = [], Et = 0; Et < 256; Et++) Tt[Et] = (Et < 16 ? "0" : "") + Et.toString(16);
            var Ct = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    var e = 4294967295 * Math.random() | 0,
                        t = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        r = 4294967295 * Math.random() | 0;
                    return (Tt[255 & e] + Tt[e >> 8 & 255] + Tt[e >> 16 & 255] + Tt[e >> 24 & 255] + "-" + Tt[255 & t] + Tt[t >> 8 & 255] + "-" + Tt[t >> 16 & 15 | 64] + Tt[t >> 24 & 255] + "-" + Tt[63 & n | 128] + Tt[n >> 8 & 255] + "-" + Tt[n >> 16 & 255] + Tt[n >> 24 & 255] + Tt[255 & r] + Tt[r >> 8 & 255] + Tt[r >> 16 & 255] + Tt[r >> 24 & 255]).toUpperCase()
                },
                clamp: function(e, t, n) {
                    return Math.max(t, Math.min(n, e))
                },
                euclideanModulo: function(e, t) {
                    return (e % t + t) % t
                },
                mapLinear: function(e, t, n, r, i) {
                    return r + (e - t) * (i - r) / (n - t)
                },
                lerp: function(e, t, n) {
                    return (1 - n) * e + n * t
                },
                smoothstep: function(e, t, n) {
                    return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, n) {
                    return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                degToRad: function(e) {
                    return e * Ct.DEG2RAD
                },
                radToDeg: function(e) {
                    return e * Ct.RAD2DEG
                },
                isPowerOfTwo: function(e) {
                    return 0 == (e & e - 1) && 0 !== e
                },
                ceilPowerOfTwo: function(e) {
                    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                },
                floorPowerOfTwo: function(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                }
            };

            function Lt(e, t) {
                this.x = e || 0, this.y = t || 0
            }

            function At(e, t, n, r) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
            }
            Object.defineProperties(Lt.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(e) {
                        this.x = e
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(e) {
                        this.y = e
                    }
                }
            }), Object.assign(Lt.prototype, {
                isVector2: !0,
                set: function(e, t) {
                    return this.x = e, this.y = t, this
                },
                setScalar: function(e) {
                    return this.x = e, this.y = e, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                },
                addScaledVector: function(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                },
                multiply: function(e) {
                    return this.x *= e.x, this.y *= e.y, this
                },
                multiplyScalar: function(e) {
                    return this.x *= e, this.y *= e, this
                },
                divide: function(e) {
                    return this.x /= e.x, this.y /= e.y, this
                },
                divideScalar: function(e) {
                    return this.multiplyScalar(1 / e)
                },
                applyMatrix3: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
                },
                min: function(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                },
                max: function(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                },
                clamp: function(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                },
                clampScalar: function(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                },
                clampLength: function(e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y
                },
                cross: function(e) {
                    return this.x * e.y - this.y * e.x
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var e = Math.atan2(this.y, this.x);
                    return e < 0 && (e += 2 * Math.PI), e
                },
                distanceTo: function(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function(e) {
                    var t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                },
                manhattanDistanceTo: function(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                },
                setLength: function(e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                },
                lerpVectors: function(e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
                },
                fromBufferAttribute: function(e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
                },
                rotateAround: function(e, t) {
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = this.x - e.x,
                        o = this.y - e.y;
                    return this.x = i * n - o * r + e.x, this.y = i * r + o * n + e.y, this
                }
            }), Object.assign(At, {
                slerp: function(e, t, n, r) {
                    return n.copy(e).slerp(t, r)
                },
                slerpFlat: function(e, t, n, r, i, o, a) {
                    var s = n[r + 0],
                        l = n[r + 1],
                        c = n[r + 2],
                        u = n[r + 3],
                        h = i[o + 0],
                        d = i[o + 1],
                        p = i[o + 2],
                        f = i[o + 3];
                    if (u !== f || s !== h || l !== d || c !== p) {
                        var m = 1 - a,
                            v = s * h + l * d + c * p + u * f,
                            g = 0 <= v ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var x = Math.sqrt(y),
                                b = Math.atan2(x, v * g);
                            m = Math.sin(m * b) / x, a = Math.sin(a * b) / x
                        }
                        var _ = a * g;
                        if (s = s * m + h * _, l = l * m + d * _, c = c * m + p * _, u = u * m + f * _, m === 1 - a) {
                            var w = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                            s *= w, l *= w, c *= w, u *= w
                        }
                    }
                    e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
                }
            }), Object.defineProperties(At.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(e) {
                        this._x = e, this._onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(e) {
                        this._y = e, this._onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(e) {
                        this._z = e, this._onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(e) {
                        this._w = e, this._onChangeCallback()
                    }
                }
            }), Object.assign(At.prototype, {
                isQuaternion: !0,
                set: function(e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                },
                setFromEuler: function(e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = e._x,
                        r = e._y,
                        i = e._z,
                        o = e.order,
                        a = Math.cos,
                        s = Math.sin,
                        l = a(n / 2),
                        c = a(r / 2),
                        u = a(i / 2),
                        h = s(n / 2),
                        d = s(r / 2),
                        p = s(i / 2);
                    return "XYZ" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "YXZ" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "ZXY" === o ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "ZYX" === o ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "YZX" === o ? (this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p) : "XZY" === o && (this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p), !1 !== t && this._onChangeCallback(), this
                },
                setFromAxisAngle: function(e, t) {
                    var n = t / 2,
                        r = Math.sin(n);
                    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                },
                setFromRotationMatrix: function(e) {
                    var t, n = e.elements,
                        r = n[0],
                        i = n[4],
                        o = n[8],
                        a = n[1],
                        s = n[5],
                        l = n[9],
                        c = n[2],
                        u = n[6],
                        h = n[10],
                        d = r + s + h;
                    return 0 < d ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (u - l) * t, this._y = (o - c) * t, this._z = (a - i) * t) : s < r && h < r ? (t = 2 * Math.sqrt(1 + r - s - h), this._w = (u - l) / t, this._x = .25 * t, this._y = (i + a) / t, this._z = (o + c) / t) : h < s ? (t = 2 * Math.sqrt(1 + s - r - h), this._w = (o - c) / t, this._x = (i + a) / t, this._y = .25 * t, this._z = (l + u) / t) : (t = 2 * Math.sqrt(1 + h - r - s), this._w = (a - i) / t, this._x = (o + c) / t, this._y = (l + u) / t, this._z = .25 * t), this._onChangeCallback(), this
                },
                setFromUnitVectors: function(e, t) {
                    var n = e.dot(t) + 1;
                    return n < 1e-6 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = n, this.normalize()
                },
                angleTo: function(e) {
                    return 2 * Math.acos(Math.abs(Ct.clamp(this.dot(e), -1, 1)))
                },
                rotateTowards: function(e, t) {
                    var n = this.angleTo(e);
                    if (0 === n) return this;
                    var r = Math.min(1, t / n);
                    return this.slerp(e, r), this
                },
                inverse: function() {
                    return this.conjugate()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                },
                dot: function(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                },
                multiply: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                },
                premultiply: function(e) {
                    return this.multiplyQuaternions(e, this)
                },
                multiplyQuaternions: function(e, t) {
                    var n = e._x,
                        r = e._y,
                        i = e._z,
                        o = e._w,
                        a = t._x,
                        s = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = n * c + o * a + r * l - i * s, this._y = r * c + o * s + i * a - n * l, this._z = i * c + o * l + n * s - r * a, this._w = o * c - n * a - r * s - i * l, this._onChangeCallback(), this
                },
                slerp: function(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                        r = this._y,
                        i = this._z,
                        o = this._w,
                        a = o * e._w + n * e._x + r * e._y + i * e._z;
                    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), 1 <= a) return this._w = o, this._x = n, this._y = r, this._z = i, this;
                    var s = 1 - a * a;
                    if (s <= Number.EPSILON) {
                        var l = 1 - t;
                        return this._w = l * o + t * this._w, this._x = l * n + t * this._x, this._y = l * r + t * this._y, this._z = l * i + t * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    var c = Math.sqrt(s),
                        u = Math.atan2(c, a),
                        h = Math.sin((1 - t) * u) / c,
                        d = Math.sin(t * u) / c;
                    return this._w = o * h + this._w * d, this._x = n * h + this._x * d, this._y = r * h + this._y * d, this._z = i * h + this._z * d, this._onChangeCallback(), this
                },
                equals: function(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                },
                _onChange: function(e) {
                    return this._onChangeCallback = e, this
                },
                _onChangeCallback: function() {}
            });
            var Rt = new Ot,
                Pt = new At;

            function Ot(e, t, n) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0
            }
            Object.assign(Ot.prototype, {
                isVector3: !0,
                set: function(e, t, n) {
                    return this.x = e, this.y = t, this.z = n, this
                },
                setScalar: function(e) {
                    return this.x = e, this.y = e, this.z = e, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setZ: function(e) {
                    return this.z = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this.z += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                },
                addScaledVector: function(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                },
                multiply: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                },
                multiplyScalar: function(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                },
                multiplyVectors: function(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                },
                applyEuler: function(e) {
                    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Pt.setFromEuler(e))
                },
                applyAxisAngle: function(e, t) {
                    return this.applyQuaternion(Pt.setFromAxisAngle(e, t))
                },
                applyMatrix3: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
                },
                applyNormalMatrix: function(e) {
                    return this.applyMatrix3(e).normalize()
                },
                applyMatrix4: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements,
                        o = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * o, this
                },
                applyQuaternion: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.x,
                        o = e.y,
                        a = e.z,
                        s = e.w,
                        l = s * t + o * r - a * n,
                        c = s * n + a * t - i * r,
                        u = s * r + i * n - o * t,
                        h = -i * t - o * n - a * r;
                    return this.x = l * s + h * -i + c * -a - u * -o, this.y = c * s + h * -o + u * -i - l * -a, this.z = u * s + h * -a + l * -o - c * -i, this
                },
                project: function(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                },
                unproject: function(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                },
                transformDirection: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
                },
                divide: function(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                },
                divideScalar: function(e) {
                    return this.multiplyScalar(1 / e)
                },
                min: function(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                },
                max: function(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                },
                clamp: function(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                },
                clampScalar: function(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                },
                clampLength: function(e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                },
                lerpVectors: function(e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                cross: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
                },
                crossVectors: function(e, t) {
                    var n = e.x,
                        r = e.y,
                        i = e.z,
                        o = t.x,
                        a = t.y,
                        s = t.z;
                    return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
                },
                projectOnVector: function(e) {
                    var t = e.dot(this) / e.lengthSq();
                    return this.copy(e).multiplyScalar(t)
                },
                projectOnPlane: function(e) {
                    return Rt.copy(this).projectOnVector(e), this.sub(Rt)
                },
                reflect: function(e) {
                    return this.sub(Rt.copy(e).multiplyScalar(2 * this.dot(e)))
                },
                angleTo: function(e) {
                    var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    0 === t && console.error("THREE.Vector3: angleTo() can't handle zero length vectors.");
                    var n = this.dot(e) / t;
                    return Math.acos(Ct.clamp(n, -1, 1))
                },
                distanceTo: function(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function(e) {
                    var t = this.x - e.x,
                        n = this.y - e.y,
                        r = this.z - e.z;
                    return t * t + n * n + r * r
                },
                manhattanDistanceTo: function(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                },
                setFromSpherical: function(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                },
                setFromSphericalCoords: function(e, t, n) {
                    var r = Math.sin(t) * e;
                    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
                },
                setFromCylindrical: function(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                },
                setFromCylindricalCoords: function(e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                },
                setFromMatrixPosition: function(e) {
                    var t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                },
                setFromMatrixScale: function(e) {
                    var t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        r = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = r, this
                },
                setFromMatrixColumn: function(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                },
                fromBufferAttribute: function(e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
            });
            var It, Dt = new Ot;

            function Nt() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.assign(Nt.prototype, {
                isMatrix3: !0,
                set: function(e, t, n, r, i, o, a, s, l) {
                    var c = this.elements;
                    return c[0] = e, c[1] = r, c[2] = a, c[3] = t, c[4] = i, c[5] = s, c[6] = n, c[7] = o, c[8] = l, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                },
                setFromMatrix4: function(e) {
                    var t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                },
                applyToBufferAttribute: function(e) {
                    for (var t = 0, n = e.count; t < n; t++) Dt.x = e.getX(t), Dt.y = e.getY(t), Dt.z = e.getZ(t), Dt.applyMatrix3(this), e.setXYZ(t, Dt.x, Dt.y, Dt.z);
                    return e
                },
                multiply: function(e) {
                    return this.multiplyMatrices(this, e)
                },
                premultiply: function(e) {
                    return this.multiplyMatrices(e, this)
                },
                multiplyMatrices: function(e, t) {
                    var n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[3],
                        s = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = r[0],
                        m = r[3],
                        v = r[6],
                        g = r[1],
                        y = r[4],
                        x = r[7],
                        b = r[2],
                        _ = r[5],
                        w = r[8];
                    return i[0] = o * f + a * g + s * b, i[3] = o * m + a * y + s * _, i[6] = o * v + a * x + s * w, i[1] = l * f + c * g + u * b, i[4] = l * m + c * y + u * _, i[7] = l * v + c * x + u * w, i[2] = h * f + d * g + p * b, i[5] = h * m + d * y + p * _, i[8] = h * v + d * x + p * w, this
                },
                multiplyScalar: function(e) {
                    var t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                },
                determinant: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        o = e[4],
                        a = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8];
                    return t * o * c - t * a * l - n * i * c + n * a * s + r * i * l - r * o * s
                },
                getInverse: function(e, t) {
                    e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = e.elements,
                        r = this.elements,
                        i = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        l = n[4],
                        c = n[5],
                        u = n[6],
                        h = n[7],
                        d = n[8],
                        p = d * l - c * h,
                        f = c * u - d * s,
                        m = h * s - l * u,
                        v = i * p + o * f + a * m;
                    if (0 == v) {
                        var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === t) throw new Error(g);
                        return console.warn(g), this.identity()
                    }
                    var y = 1 / v;
                    return r[0] = p * y, r[1] = (a * h - d * o) * y, r[2] = (c * o - a * l) * y, r[3] = f * y, r[4] = (d * i - a * u) * y, r[5] = (a * s - c * i) * y, r[6] = m * y, r[7] = (o * u - h * i) * y, r[8] = (l * i - o * s) * y, this
                },
                transpose: function() {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                },
                getNormalMatrix: function(e) {
                    return this.setFromMatrix4(e).getInverse(this).transpose()
                },
                transposeIntoArray: function(e) {
                    var t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                },
                setUvTransform: function(e, t, n, r, i, o, a) {
                    var s = Math.cos(i),
                        l = Math.sin(i);
                    this.set(n * s, n * l, -n * (s * o + l * a) + o + e, -r * l, r * s, -r * (-l * o + s * a) + a + t, 0, 0, 1)
                },
                scale: function(e, t) {
                    var n = this.elements;
                    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                },
                rotate: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e),
                        r = this.elements,
                        i = r[0],
                        o = r[3],
                        a = r[6],
                        s = r[1],
                        l = r[4],
                        c = r[7];
                    return r[0] = t * i + n * s, r[3] = t * o + n * l, r[6] = t * a + n * c, r[1] = -n * i + t * s, r[4] = -n * o + t * l, r[7] = -n * a + t * c, this
                },
                translate: function(e, t) {
                    var n = this.elements;
                    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                },
                equals: function(e) {
                    for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                },
                fromArray: function(e, t) {
                    void 0 === t && (t = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                },
                toArray: function(e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
            });
            var kt = {
                    getDataURL: function(e) {
                        var t;
                        if ("undefined" == typeof HTMLCanvasElement) return e.src;
                        if (e instanceof HTMLCanvasElement) t = e;
                        else {
                            void 0 === It && (It = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), It.width = e.width, It.height = e.height;
                            var n = It.getContext("2d");
                            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = It
                        }
                        return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                    }
                },
                zt = 0;

            function Ft(e, t, n, r, i, o, a, s, l, c) {
                Object.defineProperty(this, "id", {
                    value: zt++
                }), this.uuid = Ct.generateUUID(), this.name = "", this.image = void 0 !== e ? e : Ft.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : Ft.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : ke, this.wrapT = void 0 !== r ? r : ke, this.magFilter = void 0 !== i ? i : He, this.minFilter = void 0 !== o ? o : Ve, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== a ? a : Je, this.internalFormat = null, this.type = void 0 !== s ? s : We, this.offset = new Lt(0, 0), this.repeat = new Lt(1, 1), this.center = new Lt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Nt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== c ? c : ut, this.version = 0, this.onUpdate = null
            }

            function Bt(e, t, n, r) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
            }

            function Ut(e, t, n) {
                this.width = e, this.height = t, this.scissor = new Bt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Bt(0, 0, e, t), n = n || {}, this.texture = new Ft(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : He, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function Ht(e, t, n) {
                Ut.call(this, e, t, n), this.samples = 4
            }
            Ft.DEFAULT_IMAGE = void 0, Ft.DEFAULT_MAPPING = 300, Ft.prototype = Object.assign(Object.create(Mt.prototype), {
                constructor: Ft,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
                },
                toJSON: function(e) {
                    var t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        var r = this.image;
                        if (void 0 === r.uuid && (r.uuid = Ct.generateUUID()), !t && void 0 === e.images[r.uuid]) {
                            var i;
                            if (Array.isArray(r)) {
                                i = [];
                                for (var o = 0, a = r.length; o < a; o++) i.push(kt.getDataURL(r[o]))
                            } else i = kt.getDataURL(r);
                            e.images[r.uuid] = {
                                uuid: r.uuid,
                                url: i
                            }
                        }
                        n.image = r.uuid
                    }
                    return t || (e.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(e) {
                    if (300 !== this.mapping) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) {
                        case Ne:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case ke:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case ze:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || 1 < e.y) switch (this.wrapT) {
                        case Ne:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case ke:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case ze:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
            }), Object.defineProperty(Ft.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            }), Object.defineProperties(Bt.prototype, {
                width: {
                    get: function() {
                        return this.z
                    },
                    set: function(e) {
                        this.z = e
                    }
                },
                height: {
                    get: function() {
                        return this.w
                    },
                    set: function(e) {
                        this.w = e
                    }
                }
            }), Object.assign(Bt.prototype, {
                isVector4: !0,
                set: function(e, t, n, r) {
                    return this.x = e, this.y = t, this.z = n, this.w = r, this
                },
                setScalar: function(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setZ: function(e) {
                    return this.z = e, this
                },
                setW: function(e) {
                    return this.w = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                },
                addScaledVector: function(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                },
                multiplyScalar: function(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                },
                applyMatrix4: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = this.w,
                        o = e.elements;
                    return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i, this
                },
                divideScalar: function(e) {
                    return this.multiplyScalar(1 / e)
                },
                setAxisAngleFromQuaternion: function(e) {
                    this.w = 2 * Math.acos(e.w);
                    var t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                },
                setAxisAngleFromRotationMatrix: function(e) {
                    var t, n, r, i, o = e.elements,
                        a = o[0],
                        s = o[4],
                        l = o[8],
                        c = o[1],
                        u = o[5],
                        h = o[9],
                        d = o[2],
                        p = o[6],
                        f = o[10];
                    if (Math.abs(s - c) < .01 && Math.abs(l - d) < .01 && Math.abs(h - p) < .01) {
                        if (Math.abs(s + c) < .1 && Math.abs(l + d) < .1 && Math.abs(h + p) < .1 && Math.abs(a + u + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        var m = (a + 1) / 2,
                            v = (u + 1) / 2,
                            g = (f + 1) / 2,
                            y = (s + c) / 4,
                            x = (l + d) / 4,
                            b = (h + p) / 4;
                        return v < m && g < m ? i = m < .01 ? (n = 0, r = .707106781) : (r = y / (n = Math.sqrt(m)), x / n) : g < v ? i = v < .01 ? (r = 0, n = .707106781) : (n = y / (r = Math.sqrt(v)), b / r) : g < .01 ? (r = n = .707106781, i = 0) : (n = x / (i = Math.sqrt(g)), r = b / i), this.set(n, r, i, t), this
                    }
                    var _ = Math.sqrt((p - h) * (p - h) + (l - d) * (l - d) + (c - s) * (c - s));
                    return Math.abs(_) < .001 && (_ = 1), this.x = (p - h) / _, this.y = (l - d) / _, this.z = (c - s) / _, this.w = Math.acos((a + u + f - 1) / 2), this
                },
                min: function(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                },
                max: function(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                },
                clamp: function(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                },
                clampScalar: function(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                },
                clampLength: function(e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                },
                lerpVectors: function(e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                },
                fromBufferAttribute: function(e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
            }), Ut.prototype = Object.assign(Object.create(Mt.prototype), {
                constructor: Ut,
                isWebGLRenderTarget: !0,
                setSize: function(e, t) {
                    this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Ht.prototype = Object.assign(Object.create(Ut.prototype), {
                constructor: Ht,
                isWebGLMultisampleRenderTarget: !0,
                copy: function(e) {
                    return Ut.prototype.copy.call(this, e), this.samples = e.samples, this
                }
            });
            var Gt = new Ot,
                Vt = new Zt,
                Wt = new Ot(0, 0, 0),
                jt = new Ot(1, 1, 1),
                qt = new Ot,
                Xt = new Ot,
                Yt = new Ot;

            function Zt() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.assign(Zt.prototype, {
                isMatrix4: !0,
                set: function(e, t, n, r, i, o, a, s, l, c, u, h, d, p, f, m) {
                    var v = this.elements;
                    return v[0] = e, v[4] = t, v[8] = n, v[12] = r, v[1] = i, v[5] = o, v[9] = a, v[13] = s, v[2] = l, v[6] = c, v[10] = u, v[14] = h, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new Zt).fromArray(this.elements)
                },
                copy: function(e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                },
                copyPosition: function(e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                },
                extractBasis: function(e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function(e) {
                    var t = this.elements,
                        n = e.elements,
                        r = 1 / Gt.setFromMatrixColumn(e, 0).length(),
                        i = 1 / Gt.setFromMatrixColumn(e, 1).length(),
                        o = 1 / Gt.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                makeRotationFromEuler: function(e) {
                    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z,
                        o = Math.cos(n),
                        a = Math.sin(n),
                        s = Math.cos(r),
                        l = Math.sin(r),
                        c = Math.cos(i),
                        u = Math.sin(i);
                    if ("XYZ" === e.order) {
                        var h = o * c,
                            d = o * u,
                            p = a * c,
                            f = a * u;
                        t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = d + p * l, t[5] = h - f * l, t[9] = -a * s, t[2] = f - h * l, t[6] = p + d * l, t[10] = o * s
                    } else if ("YXZ" === e.order) {
                        var m = s * c,
                            v = s * u,
                            g = l * c,
                            y = l * u;
                        t[0] = m + y * a, t[4] = g * a - v, t[8] = o * l, t[1] = o * u, t[5] = o * c, t[9] = -a, t[2] = v * a - g, t[6] = y + m * a, t[10] = o * s
                    } else if ("ZXY" === e.order) {
                        m = s * c, v = s * u, g = l * c, y = l * u;
                        t[0] = m - y * a, t[4] = -o * u, t[8] = g + v * a, t[1] = v + g * a, t[5] = o * c, t[9] = y - m * a, t[2] = -o * l, t[6] = a, t[10] = o * s
                    } else if ("ZYX" === e.order) {
                        h = o * c, d = o * u, p = a * c, f = a * u;
                        t[0] = s * c, t[4] = p * l - d, t[8] = h * l + f, t[1] = s * u, t[5] = f * l + h, t[9] = d * l - p, t[2] = -l, t[6] = a * s, t[10] = o * s
                    } else if ("YZX" === e.order) {
                        var x = o * s,
                            b = o * l,
                            _ = a * s,
                            w = a * l;
                        t[0] = s * c, t[4] = w - x * u, t[8] = _ * u + b, t[1] = u, t[5] = o * c, t[9] = -a * c, t[2] = -l * c, t[6] = b * u + _, t[10] = x - w * u
                    } else if ("XZY" === e.order) {
                        x = o * s, b = o * l, _ = a * s, w = a * l;
                        t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = x * u + w, t[5] = o * c, t[9] = b * u - _, t[2] = _ * u - b, t[6] = a * c, t[10] = w * u + x
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                makeRotationFromQuaternion: function(e) {
                    return this.compose(Wt, e, jt)
                },
                lookAt: function(e, t, n) {
                    var r = this.elements;
                    return Yt.subVectors(e, t), 0 === Yt.lengthSq() && (Yt.z = 1), Yt.normalize(), qt.crossVectors(n, Yt), 0 === qt.lengthSq() && (1 === Math.abs(n.z) ? Yt.x += 1e-4 : Yt.z += 1e-4, Yt.normalize(), qt.crossVectors(n, Yt)), qt.normalize(), Xt.crossVectors(Yt, qt), r[0] = qt.x, r[4] = Xt.x, r[8] = Yt.x, r[1] = qt.y, r[5] = Xt.y, r[9] = Yt.y, r[2] = qt.z, r[6] = Xt.z, r[10] = Yt.z, this
                },
                multiply: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                },
                premultiply: function(e) {
                    return this.multiplyMatrices(e, this)
                },
                multiplyMatrices: function(e, t) {
                    var n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[4],
                        s = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        _ = r[0],
                        w = r[4],
                        S = r[8],
                        M = r[12],
                        T = r[1],
                        E = r[5],
                        C = r[9],
                        L = r[13],
                        A = r[2],
                        R = r[6],
                        P = r[10],
                        O = r[14],
                        I = r[3],
                        D = r[7],
                        N = r[11],
                        k = r[15];
                    return i[0] = o * _ + a * T + s * A + l * I, i[4] = o * w + a * E + s * R + l * D, i[8] = o * S + a * C + s * P + l * N, i[12] = o * M + a * L + s * O + l * k, i[1] = c * _ + u * T + h * A + d * I, i[5] = c * w + u * E + h * R + d * D, i[9] = c * S + u * C + h * P + d * N, i[13] = c * M + u * L + h * O + d * k, i[2] = p * _ + f * T + m * A + v * I, i[6] = p * w + f * E + m * R + v * D, i[10] = p * S + f * C + m * P + v * N, i[14] = p * M + f * L + m * O + v * k, i[3] = g * _ + y * T + x * A + b * I, i[7] = g * w + y * E + x * R + b * D, i[11] = g * S + y * C + x * P + b * N, i[15] = g * M + y * L + x * O + b * k, this
                },
                multiplyScalar: function(e) {
                    var t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                },
                applyToBufferAttribute: function(e) {
                    for (var t = 0, n = e.count; t < n; t++) Gt.x = e.getX(t), Gt.y = e.getY(t), Gt.z = e.getZ(t), Gt.applyMatrix4(this), e.setXYZ(t, Gt.x, Gt.y, Gt.z);
                    return e
                },
                determinant: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[4],
                        r = e[8],
                        i = e[12],
                        o = e[1],
                        a = e[5],
                        s = e[9],
                        l = e[13],
                        c = e[2],
                        u = e[6],
                        h = e[10],
                        d = e[14];
                    return e[3] * (+i * s * u - r * l * u - i * a * h + n * l * h + r * a * d - n * s * d) + e[7] * (+t * s * d - t * l * h + i * o * h - r * o * d + r * l * c - i * s * c) + e[11] * (+t * l * u - t * a * d - i * o * u + n * o * d + i * a * c - n * l * c) + e[15] * (-r * a * c - t * s * u + t * a * h + r * o * u - n * o * h + n * s * c)
                },
                transpose: function() {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                },
                setPosition: function(e, t, n) {
                    var r = this.elements;
                    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
                },
                getInverse: function(e, t) {
                    var n = this.elements,
                        r = e.elements,
                        i = r[0],
                        o = r[1],
                        a = r[2],
                        s = r[3],
                        l = r[4],
                        c = r[5],
                        u = r[6],
                        h = r[7],
                        d = r[8],
                        p = r[9],
                        f = r[10],
                        m = r[11],
                        v = r[12],
                        g = r[13],
                        y = r[14],
                        x = r[15],
                        b = p * y * h - g * f * h + g * u * m - c * y * m - p * u * x + c * f * x,
                        _ = v * f * h - d * y * h - v * u * m + l * y * m + d * u * x - l * f * x,
                        w = d * g * h - v * p * h + v * c * m - l * g * m - d * c * x + l * p * x,
                        S = v * p * u - d * g * u - v * c * f + l * g * f + d * c * y - l * p * y,
                        M = i * b + o * _ + a * w + s * S;
                    if (0 == M) {
                        var T = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === t) throw new Error(T);
                        return console.warn(T), this.identity()
                    }
                    var E = 1 / M;
                    return n[0] = b * E, n[1] = (g * f * s - p * y * s - g * a * m + o * y * m + p * a * x - o * f * x) * E, n[2] = (c * y * s - g * u * s + g * a * h - o * y * h - c * a * x + o * u * x) * E, n[3] = (p * u * s - c * f * s - p * a * h + o * f * h + c * a * m - o * u * m) * E, n[4] = _ * E, n[5] = (d * y * s - v * f * s + v * a * m - i * y * m - d * a * x + i * f * x) * E, n[6] = (v * u * s - l * y * s - v * a * h + i * y * h + l * a * x - i * u * x) * E, n[7] = (l * f * s - d * u * s + d * a * h - i * f * h - l * a * m + i * u * m) * E, n[8] = w * E, n[9] = (v * p * s - d * g * s - v * o * m + i * g * m + d * o * x - i * p * x) * E, n[10] = (l * g * s - v * c * s + v * o * h - i * g * h - l * o * x + i * c * x) * E, n[11] = (d * c * s - l * p * s - d * o * h + i * p * h + l * o * m - i * c * m) * E, n[12] = S * E, n[13] = (d * g * a - v * p * a + v * o * f - i * g * f - d * o * y + i * p * y) * E, n[14] = (v * c * a - l * g * a - v * o * u + i * g * u + l * o * y - i * c * y) * E, n[15] = (l * p * a - d * c * a + d * o * u - i * p * u - l * o * f + i * c * f) * E, this
                },
                scale: function(e) {
                    var t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z;
                    return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
                },
                getMaxScaleOnAxis: function() {
                    var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, r))
                },
                makeTranslation: function(e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(e, t) {
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = 1 - n,
                        o = e.x,
                        a = e.y,
                        s = e.z,
                        l = i * o,
                        c = i * a;
                    return this.set(l * o + n, l * a - r * s, l * s + r * a, 0, l * a + r * s, c * a + n, c * s - r * o, 0, l * s - r * a, c * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function(e, t, n) {
                    return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(e, t, n) {
                    var r = this.elements,
                        i = t._x,
                        o = t._y,
                        a = t._z,
                        s = t._w,
                        l = i + i,
                        c = o + o,
                        u = a + a,
                        h = i * l,
                        d = i * c,
                        p = i * u,
                        f = o * c,
                        m = o * u,
                        v = a * u,
                        g = s * l,
                        y = s * c,
                        x = s * u,
                        b = n.x,
                        _ = n.y,
                        w = n.z;
                    return r[0] = (1 - (f + v)) * b, r[1] = (d + x) * b, r[2] = (p - y) * b, r[3] = 0, r[4] = (d - x) * _, r[5] = (1 - (h + v)) * _, r[6] = (m + g) * _, r[7] = 0, r[8] = (p + y) * w, r[9] = (m - g) * w, r[10] = (1 - (h + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
                },
                decompose: function(e, t, n) {
                    var r = this.elements,
                        i = Gt.set(r[0], r[1], r[2]).length(),
                        o = Gt.set(r[4], r[5], r[6]).length(),
                        a = Gt.set(r[8], r[9], r[10]).length();
                    this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], Vt.copy(this);
                    var s = 1 / i,
                        l = 1 / o,
                        c = 1 / a;
                    return Vt.elements[0] *= s, Vt.elements[1] *= s, Vt.elements[2] *= s, Vt.elements[4] *= l, Vt.elements[5] *= l, Vt.elements[6] *= l, Vt.elements[8] *= c, Vt.elements[9] *= c, Vt.elements[10] *= c, t.setFromRotationMatrix(Vt), n.x = i, n.y = o, n.z = a, this
                },
                makePerspective: function(e, t, n, r, i, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var a = this.elements,
                        s = 2 * i / (t - e),
                        l = 2 * i / (n - r),
                        c = (t + e) / (t - e),
                        u = (n + r) / (n - r),
                        h = -(o + i) / (o - i),
                        d = -2 * o * i / (o - i);
                    return a[0] = s, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makeOrthographic: function(e, t, n, r, i, o) {
                    var a = this.elements,
                        s = 1 / (t - e),
                        l = 1 / (n - r),
                        c = 1 / (o - i),
                        u = (t + e) * s,
                        h = (n + r) * l,
                        d = (o + i) * c;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function(e) {
                    for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                },
                fromArray: function(e, t) {
                    void 0 === t && (t = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                },
                toArray: function(e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            });
            var Kt = new Zt,
                Jt = new At;

            function Qt(e, t, n, r) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || Qt.DefaultOrder
            }

            function $t() {
                this.mask = 1
            }
            Qt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Qt.DefaultOrder = "XYZ", Object.defineProperties(Qt.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(e) {
                        this._x = e, this._onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(e) {
                        this._y = e, this._onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(e) {
                        this._z = e, this._onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(e) {
                        this._order = e, this._onChangeCallback()
                    }
                }
            }), Object.assign(Qt.prototype, {
                isEuler: !0,
                set: function(e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                },
                setFromRotationMatrix: function(e, t, n) {
                    var r = Ct.clamp,
                        i = e.elements,
                        o = i[0],
                        a = i[4],
                        s = i[8],
                        l = i[1],
                        c = i[5],
                        u = i[9],
                        h = i[2],
                        d = i[6],
                        p = i[10];
                    return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, c), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, o), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, o))) : "ZYX" === t ? (this._y = Math.asin(-r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-a, c))) : "YZX" === t ? (this._z = Math.asin(r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === t ? (this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this._onChangeCallback(), this
                },
                setFromQuaternion: function(e, t, n) {
                    return Kt.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Kt, t, n)
                },
                setFromVector3: function(e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order)
                },
                reorder: function(e) {
                    return Jt.setFromEuler(this), this.setFromQuaternion(Jt, e)
                },
                equals: function(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                },
                fromArray: function(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                },
                toVector3: function(e) {
                    return e ? e.set(this._x, this._y, this._z) : new Ot(this._x, this._y, this._z)
                },
                _onChange: function(e) {
                    return this._onChangeCallback = e, this
                },
                _onChangeCallback: function() {}
            }), Object.assign($t.prototype, {
                set: function(e) {
                    this.mask = 1 << e | 0
                },
                enable: function(e) {
                    this.mask |= 1 << e | 0
                },
                enableAll: function() {
                    this.mask = -1
                },
                toggle: function(e) {
                    this.mask ^= 1 << e | 0
                },
                disable: function(e) {
                    this.mask &= ~(1 << e | 0)
                },
                disableAll: function() {
                    this.mask = 0
                },
                test: function(e) {
                    return 0 != (this.mask & e.mask)
                }
            });
            var en = 0,
                tn = new Ot,
                nn = new At,
                rn = new Zt,
                on = new Ot,
                an = new Ot,
                sn = new Ot,
                ln = new At,
                cn = new Ot(1, 0, 0),
                un = new Ot(0, 1, 0),
                hn = new Ot(0, 0, 1),
                dn = {
                    type: "added"
                },
                pn = {
                    type: "removed"
                };

            function fn() {
                Object.defineProperty(this, "id", {
                    value: en++
                }), this.uuid = Ct.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = fn.DefaultUp.clone();
                var e = new Ot,
                    t = new Qt,
                    n = new At,
                    r = new Ot(1, 1, 1);
                t._onChange(function() {
                    n.setFromEuler(t, !1)
                }), n._onChange(function() {
                    t.setFromQuaternion(n, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new Zt
                    },
                    normalMatrix: {
                        value: new Nt
                    }
                }), this.matrix = new Zt, this.matrixWorld = new Zt, this.matrixAutoUpdate = fn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new $t, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }

            function mn() {
                fn.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            fn.DefaultUp = new Ot(0, 1, 0), fn.DefaultMatrixAutoUpdate = !0, fn.prototype = Object.assign(Object.create(Mt.prototype), {
                constructor: fn,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(e) {
                    return this.quaternion.premultiply(e), this
                },
                setRotationFromAxisAngle: function(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                },
                setRotationFromEuler: function(e) {
                    this.quaternion.setFromEuler(e, !0)
                },
                setRotationFromMatrix: function(e) {
                    this.quaternion.setFromRotationMatrix(e)
                },
                setRotationFromQuaternion: function(e) {
                    this.quaternion.copy(e)
                },
                rotateOnAxis: function(e, t) {
                    return nn.setFromAxisAngle(e, t), this.quaternion.multiply(nn), this
                },
                rotateOnWorldAxis: function(e, t) {
                    return nn.setFromAxisAngle(e, t), this.quaternion.premultiply(nn), this
                },
                rotateX: function(e) {
                    return this.rotateOnAxis(cn, e)
                },
                rotateY: function(e) {
                    return this.rotateOnAxis(un, e)
                },
                rotateZ: function(e) {
                    return this.rotateOnAxis(hn, e)
                },
                translateOnAxis: function(e, t) {
                    return tn.copy(e).applyQuaternion(this.quaternion), this.position.add(tn.multiplyScalar(t)), this
                },
                translateX: function(e) {
                    return this.translateOnAxis(cn, e)
                },
                translateY: function(e) {
                    return this.translateOnAxis(un, e)
                },
                translateZ: function(e) {
                    return this.translateOnAxis(hn, e)
                },
                localToWorld: function(e) {
                    return e.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function(e) {
                    return e.applyMatrix4(rn.getInverse(this.matrixWorld))
                },
                lookAt: function(e, t, n) {
                    e.isVector3 ? on.copy(e) : on.set(e, t, n);
                    var r = this.parent;
                    this.updateWorldMatrix(!0, !1), an.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? rn.lookAt(an, on, this.up) : rn.lookAt(on, an, this.up), this.quaternion.setFromRotationMatrix(rn), r && (rn.extractRotation(r.matrixWorld), nn.setFromRotationMatrix(rn), this.quaternion.premultiply(nn.inverse()))
                },
                add: function(e) {
                    if (1 < arguments.length) {
                        for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), (e.parent = this).children.push(e), e.dispatchEvent(dn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this
                },
                remove: function(e) {
                    if (1 < arguments.length) {
                        for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    var n = this.children.indexOf(e);
                    return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(pn)), this
                },
                attach: function(e) {
                    return this.updateWorldMatrix(!0, !1), rn.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), rn.multiply(e.parent.matrixWorld)), e.applyMatrix(rn), e.updateWorldMatrix(!1, !1), this.add(e), this
                },
                getObjectById: function(e) {
                    return this.getObjectByProperty("id", e)
                },
                getObjectByName: function(e) {
                    return this.getObjectByProperty("name", e)
                },
                getObjectByProperty: function(e, t) {
                    if (this[e] === t) return this;
                    for (var n = 0, r = this.children.length; n < r; n++) {
                        var i = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== i) return i
                    }
                },
                getWorldPosition: function(e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Ot), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function(e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new At), this.updateMatrixWorld(!0), this.matrixWorld.decompose(an, e, sn), e
                },
                getWorldScale: function(e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new Ot), this.updateMatrixWorld(!0), this.matrixWorld.decompose(an, ln, e), e
                },
                getWorldDirection: function(e) {
                    void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Ot), this.updateMatrixWorld(!0);
                    var t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                },
                raycast: function() {},
                traverse: function(e) {
                    e(this);
                    for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
                },
                traverseVisible: function(e) {
                    if (!1 !== this.visible) {
                        e(this);
                        for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
                    }
                },
                traverseAncestors: function(e) {
                    var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e = !(this.matrixWorldNeedsUpdate = !1));
                    for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
                },
                updateWorldMatrix: function(e, t) {
                    var n = this.parent;
                    if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                        for (var r = this.children, i = 0, o = r.length; i < o; i++) r[i].updateWorldMatrix(!1, !0)
                },
                toJSON: function(n) {
                    var e = void 0 === n || "string" == typeof n,
                        t = {};
                    e && (n = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, t.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var r = {};

                    function i(e, t) {
                        return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(n)), t.uuid
                    }
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                        r.geometry = i(n.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, l = a.length; s < l; s++) {
                                    var c = a[s];
                                    i(n.shapes, c)
                                } else i(n.shapes, a)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var u = [];
                            for (s = 0, l = this.material.length; s < l; s++) u.push(i(n.materials, this.material[s]));
                            r.material = u
                        } else r.material = i(n.materials, this.material);
                    if (0 < this.children.length) {
                        r.children = [];
                        for (s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(n).object)
                    }
                    if (e) {
                        var h = m(n.geometries),
                            d = m(n.materials),
                            p = m(n.textures),
                            f = m(n.images);
                        a = m(n.shapes);
                        0 < h.length && (t.geometries = h), 0 < d.length && (t.materials = d), 0 < p.length && (t.textures = p), 0 < f.length && (t.images = f), 0 < a.length && (t.shapes = a)
                    }
                    return t.object = r, t;

                    function m(e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                },
                clone: function(e) {
                    return (new this.constructor).copy(this, e)
                },
                copy: function(e, t) {
                    if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (var n = 0; n < e.children.length; n++) {
                            var r = e.children[n];
                            this.add(r.clone())
                        }
                    return this
                }
            }), mn.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: mn,
                isScene: !0,
                copy: function(e, t) {
                    return fn.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                },
                toJSON: function(e) {
                    var t = fn.prototype.toJSON.call(this, e);
                    return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var vn = [new Ot, new Ot, new Ot, new Ot, new Ot, new Ot, new Ot, new Ot],
                gn = new Ot,
                yn = new An,
                xn = new Ot,
                bn = new Ot,
                _n = new Ot,
                wn = new Ot,
                Sn = new Ot,
                Mn = new Ot,
                Tn = new Ot,
                En = new Ot,
                Cn = new Ot,
                Ln = new Ot;

            function An(e, t) {
                this.min = void 0 !== e ? e : new Ot(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Ot(-1 / 0, -1 / 0, -1 / 0)
            }

            function Rn(e, t, n, r, i) {
                var o, a;
                for (o = 0, a = e.length - 3; o <= a; o += 3) {
                    Ln.fromArray(e, o);
                    var s = i.x * Math.abs(Ln.x) + i.y * Math.abs(Ln.y) + i.z * Math.abs(Ln.z),
                        l = t.dot(Ln),
                        c = n.dot(Ln),
                        u = r.dot(Ln);
                    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > s) return !1
                }
                return !0
            }
            Object.assign(An.prototype, {
                isBox3: !0,
                set: function(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromArray: function(e) {
                    for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                        var c = e[s],
                            u = e[s + 1],
                            h = e[s + 2];
                        c < t && (t = c), u < n && (n = u), h < r && (r = h), i < c && (i = c), o < u && (o = u), a < h && (a = h)
                    }
                    return this.min.set(t, n, r), this.max.set(i, o, a), this
                },
                setFromBufferAttribute: function(e) {
                    for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = e.count; s < l; s++) {
                        var c = e.getX(s),
                            u = e.getY(s),
                            h = e.getZ(s);
                        c < t && (t = c), u < n && (n = u), h < r && (r = h), i < c && (i = c), o < u && (o = u), a < h && (a = h)
                    }
                    return this.min.set(t, n, r), this.max.set(i, o, a), this
                },
                setFromPoints: function(e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function(e, t) {
                    var n = gn.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                },
                setFromObject: function(e) {
                    return this.makeEmpty(), this.expandByObject(e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Ot), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Ot), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function(e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function(e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                expandByObject: function(e) {
                    e.updateWorldMatrix(!1, !1);
                    var t = e.geometry;
                    void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), yn.copy(t.boundingBox), yn.applyMatrix4(e.matrixWorld), this.expandByPoint(yn.min), this.expandByPoint(yn.max));
                    for (var n = e.children, r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
                    return this
                },
                containsPoint: function(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                },
                containsBox: function(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                },
                getParameter: function(e, t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Ot), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                },
                intersectsSphere: function(e) {
                    return this.clampPoint(e.center, gn), gn.distanceToSquared(e.center) <= e.radius * e.radius
                },
                intersectsPlane: function(e) {
                    var t, n;
                    return n = 0 < e.normal.x ? (t = e.normal.x * this.min.x, e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                },
                intersectsTriangle: function(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Tn), En.subVectors(this.max, Tn), xn.subVectors(e.a, Tn), bn.subVectors(e.b, Tn), _n.subVectors(e.c, Tn), wn.subVectors(bn, xn), Sn.subVectors(_n, bn), Mn.subVectors(xn, _n);
                    var t = [0, -wn.z, wn.y, 0, -Sn.z, Sn.y, 0, -Mn.z, Mn.y, wn.z, 0, -wn.x, Sn.z, 0, -Sn.x, Mn.z, 0, -Mn.x, -wn.y, wn.x, 0, -Sn.y, Sn.x, 0, -Mn.y, Mn.x, 0];
                    return !!Rn(t, xn, bn, _n, En) && (!!Rn(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], xn, bn, _n, En) && (Cn.crossVectors(wn, Sn), Rn(t = [Cn.x, Cn.y, Cn.z], xn, bn, _n, En)))
                },
                clampPoint: function(e, t) {
                    return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Ot), t.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function(e) {
                    return gn.copy(e).clamp(this.min, this.max).sub(e).length()
                },
                getBoundingSphere: function(e) {
                    return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(gn).length(), e
                },
                intersect: function(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                applyMatrix4: function(e) {
                    return this.isEmpty() || (vn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), vn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), vn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), vn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), vn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), vn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), vn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), vn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(vn)), this
                },
                translate: function(e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            });
            var Pn = new An;

            function On(e, t) {
                this.center = void 0 !== e ? e : new Ot, this.radius = void 0 !== t ? t : 0
            }
            Object.assign(On.prototype, {
                set: function(e, t) {
                    return this.center.copy(e), this.radius = t, this
                },
                setFromPoints: function(e, t) {
                    var n = this.center;
                    void 0 !== t ? n.copy(t) : Pn.setFromPoints(e).getCenter(n);
                    for (var r = 0, i = 0, o = e.length; i < o; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                    return this.radius = Math.sqrt(r), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(e) {
                    return e.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(e) {
                    var t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                },
                intersectsBox: function(e) {
                    return e.intersectsSphere(this)
                },
                intersectsPlane: function(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(e, t) {
                    var n = this.center.distanceToSquared(e);
                    return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Ot), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                },
                getBoundingBox: function(e) {
                    return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new An), e.set(this.center, this.center), e.expandByScalar(this.radius), e
                },
                applyMatrix4: function(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                },
                translate: function(e) {
                    return this.center.add(e), this
                },
                equals: function(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
            });
            var In = new Ot,
                Dn = new Ot,
                Nn = new Ot,
                kn = new Ot,
                zn = new Ot,
                Fn = new Ot,
                Bn = new Ot;

            function Un(e, t) {
                this.origin = void 0 !== e ? e : new Ot, this.direction = void 0 !== t ? t : new Ot(0, 0, -1)
            }
            Object.assign(Un.prototype, {
                set: function(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                },
                at: function(e, t) {
                    return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new Ot), t.copy(this.direction).multiplyScalar(e).add(this.origin)
                },
                lookAt: function(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                },
                recast: function(e) {
                    return this.origin.copy(this.at(e, In)), this
                },
                closestPointToPoint: function(e, t) {
                    void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Ot), t.subVectors(e, this.origin);
                    var n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                },
                distanceSqToPoint: function(e) {
                    var t = In.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (In.copy(this.direction).multiplyScalar(t).add(this.origin), In.distanceToSquared(e))
                },
                distanceSqToSegment: function(e, t, n, r) {
                    Dn.copy(e).add(t).multiplyScalar(.5), Nn.copy(t).sub(e).normalize(), kn.copy(this.origin).sub(Dn);
                    var i, o, a, s, l = .5 * e.distanceTo(t),
                        c = -this.direction.dot(Nn),
                        u = kn.dot(this.direction),
                        h = -kn.dot(Nn),
                        d = kn.lengthSq(),
                        p = Math.abs(1 - c * c);
                    if (0 < p)
                        if (o = c * u - h, s = l * p, 0 <= (i = c * h - u))
                            if (-s <= o)
                                if (o <= s) {
                                    var f = 1 / p;
                                    a = (i *= f) * (i + c * (o *= f) + 2 * u) + o * (c * i + o + 2 * h) + d
                                } else o = l, a = -(i = Math.max(0, -(c * o + u))) * i + o * (o + 2 * h) + d;
                    else o = -l, a = -(i = Math.max(0, -(c * o + u))) * i + o * (o + 2 * h) + d;
                    else a = o <= -s ? -(i = Math.max(0, -(-c * l + u))) * i + (o = 0 < i ? -l : Math.min(Math.max(-l, -h), l)) * (o + 2 * h) + d : o <= s ? (i = 0, (o = Math.min(Math.max(-l, -h), l)) * (o + 2 * h) + d) : -(i = Math.max(0, -(c * l + u))) * i + (o = 0 < i ? l : Math.min(Math.max(-l, -h), l)) * (o + 2 * h) + d;
                    else o = 0 < c ? -l : l, a = -(i = Math.max(0, -(c * o + u))) * i + o * (o + 2 * h) + d;
                    return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(Nn).multiplyScalar(o).add(Dn), a
                },
                intersectSphere: function(e, t) {
                    In.subVectors(e.center, this.origin);
                    var n = In.dot(this.direction),
                        r = In.dot(In) - n * n,
                        i = e.radius * e.radius;
                    if (i < r) return null;
                    var o = Math.sqrt(i - r),
                        a = n - o,
                        s = n + o;
                    return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t)
                },
                intersectsSphere: function(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                },
                distanceToPlane: function(e) {
                    var t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return 0 <= n ? n : null
                },
                intersectPlane: function(e, t) {
                    var n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                },
                intersectsPlane: function(e) {
                    var t = e.distanceToPoint(this.origin);
                    return 0 === t || e.normal.dot(this.direction) * t < 0
                },
                intersectBox: function(e, t) {
                    var n, r, i, o, a, s, l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return r = 0 <= l ? (n = (e.min.x - h.x) * l, (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, (e.min.x - h.x) * l), (o = 0 <= c ? (i = (e.min.y - h.y) * c, (e.max.y - h.y) * c) : (i = (e.max.y - h.y) * c, (e.min.y - h.y) * c)) < n || r < i ? null : ((n < i || n != n) && (n = i), (o < r || r != r) && (r = o), (s = 0 <= u ? (a = (e.min.z - h.z) * u, (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u, (e.min.z - h.z) * u)) < n || r < a ? null : ((n < a || n != n) && (n = a), (s < r || r != r) && (r = s), r < 0 ? null : this.at(0 <= n ? n : r, t)))
                },
                intersectsBox: function(e) {
                    return null !== this.intersectBox(e, In)
                },
                intersectTriangle: function(e, t, n, r, i) {
                    zn.subVectors(t, e), Fn.subVectors(n, e), Bn.crossVectors(zn, Fn);
                    var o, a = this.direction.dot(Bn);
                    if (0 < a) {
                        if (r) return null;
                        o = 1
                    } else {
                        if (!(a < 0)) return null;
                        o = -1, a = -a
                    }
                    kn.subVectors(this.origin, e);
                    var s = o * this.direction.dot(Fn.crossVectors(kn, Fn));
                    if (s < 0) return null;
                    var l = o * this.direction.dot(zn.cross(kn));
                    if (l < 0) return null;
                    if (a < s + l) return null;
                    var c = -o * kn.dot(Bn);
                    return c < 0 ? null : this.at(c / a, i)
                },
                applyMatrix4: function(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                },
                equals: function(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
            });
            var Hn = new Ot,
                Gn = new Ot,
                Vn = new Nt;

            function Wn(e, t) {
                this.normal = void 0 !== e ? e : new Ot(1, 0, 0), this.constant = void 0 !== t ? t : 0
            }
            Object.assign(Wn.prototype, {
                isPlane: !0,
                set: function(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                },
                setComponents: function(e, t, n, r) {
                    return this.normal.set(e, t, n), this.constant = r, this
                },
                setFromNormalAndCoplanarPoint: function(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                },
                setFromCoplanarPoints: function(e, t, n) {
                    var r = Hn.subVectors(n, t).cross(Gn.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(r, e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                },
                normalize: function() {
                    var e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(e) {
                    return this.normal.dot(e) + this.constant
                },
                distanceToSphere: function(e) {
                    return this.distanceToPoint(e.center) - e.radius
                },
                projectPoint: function(e, t) {
                    return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Ot), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                },
                intersectLine: function(e, t) {
                    void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new Ot);
                    var n = e.delta(Hn),
                        r = this.normal.dot(n);
                    if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
                    var i = -(e.start.dot(this.normal) + this.constant) / r;
                    return i < 0 || 1 < i ? void 0 : t.copy(n).multiplyScalar(i).add(e.start)
                },
                intersectsLine: function(e) {
                    var t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && 0 < n || n < 0 && 0 < t
                },
                intersectsBox: function(e) {
                    return e.intersectsPlane(this)
                },
                intersectsSphere: function(e) {
                    return e.intersectsPlane(this)
                },
                coplanarPoint: function(e) {
                    return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Ot), e.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function(e, t) {
                    var n = t || Vn.getNormalMatrix(e),
                        r = this.coplanarPoint(Hn).applyMatrix4(e),
                        i = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -r.dot(i), this
                },
                translate: function(e) {
                    return this.constant -= e.dot(this.normal), this
                },
                equals: function(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
            });
            var jn = new Ot,
                qn = new Ot,
                Xn = new Ot,
                Yn = new Ot,
                Zn = new Ot,
                Kn = new Ot,
                Jn = new Ot,
                Qn = new Ot,
                $n = new Ot,
                er = new Ot;

            function tr(e, t, n) {
                this.a = void 0 !== e ? e : new Ot, this.b = void 0 !== t ? t : new Ot, this.c = void 0 !== n ? n : new Ot
            }
            Object.assign(tr, {
                getNormal: function(e, t, n, r) {
                    void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new Ot), r.subVectors(n, t), jn.subVectors(e, t), r.cross(jn);
                    var i = r.lengthSq();
                    return 0 < i ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                },
                getBarycoord: function(e, t, n, r, i) {
                    jn.subVectors(r, t), qn.subVectors(n, t), Xn.subVectors(e, t);
                    var o = jn.dot(jn),
                        a = jn.dot(qn),
                        s = jn.dot(Xn),
                        l = qn.dot(qn),
                        c = qn.dot(Xn),
                        u = o * l - a * a;
                    if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new Ot), 0 == u) return i.set(-2, -1, -1);
                    var h = 1 / u,
                        d = (l * s - a * c) * h,
                        p = (o * c - a * s) * h;
                    return i.set(1 - d - p, p, d)
                },
                containsPoint: function(e, t, n, r) {
                    return tr.getBarycoord(e, t, n, r, Yn), 0 <= Yn.x && 0 <= Yn.y && Yn.x + Yn.y <= 1
                },
                getUV: function(e, t, n, r, i, o, a, s) {
                    return this.getBarycoord(e, t, n, r, Yn), s.set(0, 0), s.addScaledVector(i, Yn.x), s.addScaledVector(o, Yn.y), s.addScaledVector(a, Yn.z), s
                },
                isFrontFacing: function(e, t, n, r) {
                    return jn.subVectors(n, t), qn.subVectors(e, t), jn.cross(qn).dot(r) < 0
                }
            }), Object.assign(tr.prototype, {
                set: function(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                },
                setFromPointsAndIndices: function(e, t, n, r) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                },
                getArea: function() {
                    return jn.subVectors(this.c, this.b), qn.subVectors(this.a, this.b), .5 * jn.cross(qn).length()
                },
                getMidpoint: function(e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Ot), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function(e) {
                    return tr.getNormal(this.a, this.b, this.c, e)
                },
                getPlane: function(e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new Wn), e.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function(e, t) {
                    return tr.getBarycoord(e, this.a, this.b, this.c, t)
                },
                getUV: function(e, t, n, r, i) {
                    return tr.getUV(e, this.a, this.b, this.c, t, n, r, i)
                },
                containsPoint: function(e) {
                    return tr.containsPoint(e, this.a, this.b, this.c)
                },
                isFrontFacing: function(e) {
                    return tr.isFrontFacing(this.a, this.b, this.c, e)
                },
                intersectsBox: function(e) {
                    return e.intersectsTriangle(this)
                },
                closestPointToPoint: function(e, t) {
                    void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Ot);
                    var n, r, i = this.a,
                        o = this.b,
                        a = this.c;
                    Zn.subVectors(o, i), Kn.subVectors(a, i), Qn.subVectors(e, i);
                    var s = Zn.dot(Qn),
                        l = Kn.dot(Qn);
                    if (s <= 0 && l <= 0) return t.copy(i);
                    $n.subVectors(e, o);
                    var c = Zn.dot($n),
                        u = Kn.dot($n);
                    if (0 <= c && u <= c) return t.copy(o);
                    var h = s * u - c * l;
                    if (h <= 0 && 0 <= s && c <= 0) return n = s / (s - c), t.copy(i).addScaledVector(Zn, n);
                    er.subVectors(e, a);
                    var d = Zn.dot(er),
                        p = Kn.dot(er);
                    if (0 <= p && d <= p) return t.copy(a);
                    var f = d * l - s * p;
                    if (f <= 0 && 0 <= l && p <= 0) return r = l / (l - p), t.copy(i).addScaledVector(Kn, r);
                    var m = c * p - d * u;
                    if (m <= 0 && 0 <= u - c && 0 <= d - p) return Jn.subVectors(a, o), r = (u - c) / (u - c + (d - p)), t.copy(o).addScaledVector(Jn, r);
                    var v = 1 / (m + f + h);
                    return n = f * v, r = h * v, t.copy(i).addScaledVector(Zn, n).addScaledVector(Kn, r)
                },
                equals: function(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            });
            var nr = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                rr = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                ir = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function or(e, t, n) {
                return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
            }

            function ar(e, t, n) {
                return n < 0 && (n += 1), 1 < n && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }

            function sr(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function lr(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }

            function cr(e, t, n, r, i, o) {
                this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new Ot, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new or, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0
            }
            Object.assign(or.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                },
                setScalar: function(e) {
                    return this.r = e, this.g = e, this.b = e, this
                },
                setHex: function(e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                },
                setRGB: function(e, t, n) {
                    return this.r = e, this.g = t, this.b = n, this
                },
                setHSL: function(e, t, n) {
                    if (e = Ct.euclideanModulo(e, 1), t = Ct.clamp(t, 0, 1), n = Ct.clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                    else {
                        var r = n <= .5 ? n * (1 + t) : n + t - n * t,
                            i = 2 * n - r;
                        this.r = ar(i, r, e + 1 / 3), this.g = ar(i, r, e), this.b = ar(i, r, e - 1 / 3)
                    }
                    return this
                },
                setStyle: function(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var r, i = n[1],
                            o = n[2];
                        switch (i) {
                            case "rgb":
                            case "rgba":
                                if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, e(r[5]), this;
                                if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, e(r[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var a = parseFloat(r[1]) / 360,
                                        s = parseInt(r[2], 10) / 100,
                                        l = parseInt(r[3], 10) / 100;
                                    return e(r[5]), this.setHSL(a, s, l)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var c = n[1],
                            u = c.length;
                        if (3 === u) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                        if (6 === u) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
                    }
                    return t && 0 < t.length ? this.setColorName(t) : this
                },
                setColorName: function(e) {
                    var t = nr[e];
                    return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                },
                copyGammaToLinear: function(e, t) {
                    return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
                },
                copyLinearToGamma: function(e, t) {
                    void 0 === t && (t = 2);
                    var n = 0 < t ? 1 / t : 1;
                    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
                },
                convertGammaToLinear: function(e) {
                    return this.copyGammaToLinear(this, e), this
                },
                convertLinearToGamma: function(e) {
                    return this.copyLinearToGamma(this, e), this
                },
                copySRGBToLinear: function(e) {
                    return this.r = sr(e.r), this.g = sr(e.g), this.b = sr(e.b), this
                },
                copyLinearToSRGB: function(e) {
                    return this.r = lr(e.r), this.g = lr(e.g), this.b = lr(e.b), this
                },
                convertSRGBToLinear: function() {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function() {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(e) {
                    void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var t, n, r = this.r,
                        i = this.g,
                        o = this.b,
                        a = Math.max(r, i, o),
                        s = Math.min(r, i, o),
                        l = (s + a) / 2;
                    if (s === a) n = t = 0;
                    else {
                        var c = a - s;
                        switch (n = l <= .5 ? c / (a + s) : c / (2 - a - s), a) {
                            case r:
                                t = (i - o) / c + (i < o ? 6 : 0);
                                break;
                            case i:
                                t = (o - r) / c + 2;
                                break;
                            case o:
                                t = (r - i) / c + 4
                        }
                        t /= 6
                    }
                    return e.h = t, e.s = n, e.l = l, e
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function(e, t, n) {
                    return this.getHSL(rr), rr.h += e, rr.s += t, rr.l += n, this.setHSL(rr.h, rr.s, rr.l), this
                },
                add: function(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                },
                addColors: function(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                },
                addScalar: function(e) {
                    return this.r += e, this.g += e, this.b += e, this
                },
                sub: function(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                },
                multiply: function(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                },
                multiplyScalar: function(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                },
                lerp: function(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                },
                lerpHSL: function(e, t) {
                    this.getHSL(rr), e.getHSL(ir);
                    var n = Ct.lerp(rr.h, ir.h, t),
                        r = Ct.lerp(rr.s, ir.s, t),
                        i = Ct.lerp(rr.l, ir.l, t);
                    return this.setHSL(n, r, i), this
                },
                equals: function(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                },
                toJSON: function() {
                    return this.getHex()
                }
            }), or.NAMES = nr, Object.assign(cr.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                    for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                    for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                    return this
                }
            });
            var ur = 0;

            function hr() {
                Object.defineProperty(this, "id", {
                    value: ur++
                }), this.uuid = Ct.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = $, this.side = P, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = a, this.opacity = 1, this.transparent = !1, this.blendSrc = pe, this.blendDst = fe, this.blendEquation = ie, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Se, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = _t, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = bt, this.stencilZFail = bt, this.stencilZPass = bt, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
            }

            function dr(e) {
                hr.call(this), this.type = "MeshBasicMaterial", this.color = new or(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = F, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e)
            }
            hr.prototype = Object.assign(Object.create(Mt.prototype), {
                constructor: hr,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(e) {
                    if (void 0 !== e)
                        for (var t in e) {
                            var n = e[t];
                            if (void 0 !== n)
                                if ("shading" !== t) {
                                    var r = this[t];
                                    void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                        }
                },
                toJSON: function(e) {
                    var t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function r(e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== $ && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== P && (n.side = this.side), this.vertexColors !== a && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                        var i = r(e.textures),
                            o = r(e.images);
                        0 < i.length && (n.textures = i), 0 < o.length && (n.images = o)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexTangents = e.vertexTangents, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    var t = e.clippingPlanes,
                        n = null;
                    if (null !== t) {
                        var r = t.length;
                        n = new Array(r);
                        for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(hr.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            }), ((dr.prototype = Object.create(hr.prototype)).constructor = dr).prototype.isMeshBasicMaterial = !0, dr.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
            };
            var pr = new Ot;

            function fr(e, t, n) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = wt, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function mr(e, t, n) {
                fr.call(this, new Int8Array(e), t, n)
            }

            function vr(e, t, n) {
                fr.call(this, new Uint8Array(e), t, n)
            }

            function gr(e, t, n) {
                fr.call(this, new Uint8ClampedArray(e), t, n)
            }

            function yr(e, t, n) {
                fr.call(this, new Int16Array(e), t, n)
            }

            function xr(e, t, n) {
                fr.call(this, new Uint16Array(e), t, n)
            }

            function br(e, t, n) {
                fr.call(this, new Int32Array(e), t, n)
            }

            function _r(e, t, n) {
                fr.call(this, new Uint32Array(e), t, n)
            }

            function wr(e, t, n) {
                fr.call(this, new Float32Array(e), t, n)
            }

            function Sr(e, t, n) {
                fr.call(this, new Float64Array(e), t, n)
            }

            function Mr() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Tr(e) {
                if (0 === e.length) return -1 / 0;
                for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
                return t
            }
            Object.defineProperty(fr.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            }), Object.assign(fr.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setUsage: function(e) {
                    return this.usage = e, this
                },
                copy: function(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
                },
                copyAt: function(e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                },
                copyArray: function(e) {
                    return this.array.set(e), this
                },
                copyColorsArray: function(e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new or), t[n++] = o.r, t[n++] = o.g, t[n++] = o.b
                    }
                    return this
                },
                copyVector2sArray: function(e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new Lt), t[n++] = o.x, t[n++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function(e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new Ot), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function(e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new Bt), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w
                    }
                    return this
                },
                applyMatrix3: function(e) {
                    for (var t = 0, n = this.count; t < n; t++) pr.x = this.getX(t), pr.y = this.getY(t), pr.z = this.getZ(t), pr.applyMatrix3(e), this.setXYZ(t, pr.x, pr.y, pr.z);
                    return this
                },
                applyMatrix4: function(e) {
                    for (var t = 0, n = this.count; t < n; t++) pr.x = this.getX(t), pr.y = this.getY(t), pr.z = this.getZ(t), pr.applyMatrix4(e), this.setXYZ(t, pr.x, pr.y, pr.z);
                    return this
                },
                applyNormalMatrix: function(e) {
                    for (var t = 0, n = this.count; t < n; t++) pr.x = this.getX(t), pr.y = this.getY(t), pr.z = this.getZ(t), pr.applyNormalMatrix(e), this.setXYZ(t, pr.x, pr.y, pr.z);
                    return this
                },
                transformDirection: function(e) {
                    for (var t = 0, n = this.count; t < n; t++) pr.x = this.getX(t), pr.y = this.getY(t), pr.z = this.getZ(t), pr.transformDirection(e), this.setXYZ(t, pr.x, pr.y, pr.z);
                    return this
                },
                set: function(e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                getX: function(e) {
                    return this.array[e * this.itemSize]
                },
                setX: function(e, t) {
                    return this.array[e * this.itemSize] = t, this
                },
                getY: function(e) {
                    return this.array[e * this.itemSize + 1]
                },
                setY: function(e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                },
                getZ: function(e) {
                    return this.array[e * this.itemSize + 2]
                },
                setZ: function(e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                },
                getW: function(e) {
                    return this.array[e * this.itemSize + 3]
                },
                setW: function(e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                },
                setXY: function(e, t, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
                },
                setXYZ: function(e, t, n, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
                },
                setXYZW: function(e, t, n, r, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
                },
                onUpload: function(e) {
                    return this.onUploadCallback = e, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                },
                toJSON: function() {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    }
                }
            }), (mr.prototype = Object.create(fr.prototype)).constructor = mr, (vr.prototype = Object.create(fr.prototype)).constructor = vr, (gr.prototype = Object.create(fr.prototype)).constructor = gr, (yr.prototype = Object.create(fr.prototype)).constructor = yr, (xr.prototype = Object.create(fr.prototype)).constructor = xr, (br.prototype = Object.create(fr.prototype)).constructor = br, (_r.prototype = Object.create(fr.prototype)).constructor = _r, (wr.prototype = Object.create(fr.prototype)).constructor = wr, (Sr.prototype = Object.create(fr.prototype)).constructor = Sr, Object.assign(Mr.prototype, {
                computeGroups: function(e) {
                    for (var t, n = [], r = void 0, i = e.faces, o = 0; o < i.length; o++) {
                        var a = i[o];
                        a.materialIndex !== r && (r = a.materialIndex, void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), t = {
                            start: 3 * o,
                            materialIndex: r
                        })
                    }
                    void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), this.groups = n
                },
                fromGeometry: function(e) {
                    var t, n = e.faces,
                        r = e.vertices,
                        i = e.faceVertexUvs,
                        o = i[0] && 0 < i[0].length,
                        a = i[1] && 0 < i[1].length,
                        s = e.morphTargets,
                        l = s.length;
                    if (0 < l) {
                        t = [];
                        for (var c = 0; c < l; c++) t[c] = {
                            name: s[c].name,
                            data: []
                        };
                        this.morphTargets.position = t
                    }
                    var u, h = e.morphNormals,
                        d = h.length;
                    if (0 < d) {
                        u = [];
                        for (c = 0; c < d; c++) u[c] = {
                            name: h[c].name,
                            data: []
                        };
                        this.morphTargets.normal = u
                    }
                    var p = e.skinIndices,
                        f = e.skinWeights,
                        m = p.length === r.length,
                        v = f.length === r.length;
                    0 < r.length && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (c = 0; c < n.length; c++) {
                        var g = n[c];
                        this.vertices.push(r[g.a], r[g.b], r[g.c]);
                        var y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var x = g.normal;
                            this.normals.push(x, x, x)
                        }
                        var b, _ = g.vertexColors;
                        if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
                        else {
                            var w = g.color;
                            this.colors.push(w, w, w)
                        }
                        if (!0 === o) void 0 !== (b = i[0][c]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", c), this.uvs.push(new Lt, new Lt, new Lt));
                        if (!0 === a) void 0 !== (b = i[1][c]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", c), this.uvs2.push(new Lt, new Lt, new Lt));
                        for (var S = 0; S < l; S++) {
                            var M = s[S].vertices;
                            t[S].data.push(M[g.a], M[g.b], M[g.c])
                        }
                        for (S = 0; S < d; S++) {
                            var T = h[S].vertexNormals[c];
                            u[S].data.push(T.a, T.b, T.c)
                        }
                        m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
                    }
                    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                }
            });
            var Er = 1,
                Cr = new Zt,
                Lr = new fn,
                Ar = new Ot,
                Rr = new An,
                Pr = new An,
                Or = new Ot;

            function Ir() {
                Object.defineProperty(this, "id", {
                    value: Er += 2
                }), this.uuid = Ct.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            Ir.prototype = Object.assign(Object.create(Mt.prototype), {
                constructor: Ir,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(e) {
                    Array.isArray(e) ? this.index = new(65535 < Tr(e) ? _r : xr)(e, 1) : this.index = e
                },
                getAttribute: function(e) {
                    return this.attributes[e]
                },
                setAttribute: function(e, t) {
                    return this.attributes[e] = t, this
                },
                deleteAttribute: function(e) {
                    return delete this.attributes[e], this
                },
                addGroup: function(e, t, n) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                },
                applyMatrix: function(e) {
                    var t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                    var n = this.attributes.normal;
                    if (void 0 !== n) {
                        var r = (new Nt).getNormalMatrix(e);
                        n.applyNormalMatrix(r), n.needsUpdate = !0
                    }
                    var i = this.attributes.tangent;
                    return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function(e) {
                    return Cr.makeRotationX(e), this.applyMatrix(Cr), this
                },
                rotateY: function(e) {
                    return Cr.makeRotationY(e), this.applyMatrix(Cr), this
                },
                rotateZ: function(e) {
                    return Cr.makeRotationZ(e), this.applyMatrix(Cr), this
                },
                translate: function(e, t, n) {
                    return Cr.makeTranslation(e, t, n), this.applyMatrix(Cr), this
                },
                scale: function(e, t, n) {
                    return Cr.makeScale(e, t, n), this.applyMatrix(Cr), this
                },
                lookAt: function(e) {
                    return Lr.lookAt(e), Lr.updateMatrix(), this.applyMatrix(Lr.matrix), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Ar).negate(), this.translate(Ar.x, Ar.y, Ar.z), this
                },
                setFromObject: function(e) {
                    var t = e.geometry;
                    if (e.isPoints || e.isLine) {
                        var n = new wr(3 * t.vertices.length, 3),
                            r = new wr(3 * t.colors.length, 3);
                        if (this.setAttribute("position", n.copyVector3sArray(t.vertices)), this.setAttribute("color", r.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                            var i = new wr(t.lineDistances.length, 1);
                            this.setAttribute("lineDistance", i.copyArray(t.lineDistances))
                        }
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                    return this
                },
                setFromPoints: function(e) {
                    for (var t = [], n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.push(i.x, i.y, i.z || 0)
                    }
                    return this.setAttribute("position", new wr(t, 3)), this
                },
                updateFromObject: function(e) {
                    var t, n = e.geometry;
                    if (e.isMesh) {
                        var r = n.__directGeometry;
                        if (!0 === n.elementsNeedUpdate && (r = void 0, n.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(n);
                        r.verticesNeedUpdate = n.verticesNeedUpdate, r.normalsNeedUpdate = n.normalsNeedUpdate, r.colorsNeedUpdate = n.colorsNeedUpdate, r.uvsNeedUpdate = n.uvsNeedUpdate, r.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = r
                    }
                    return !0 === n.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(n.vertices), t.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(n.normals), t.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(n.colors), t.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(n.uvs), t.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(n.lineDistances), t.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(e.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(e) {
                    return e.__directGeometry = (new Mr).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
                },
                fromDirectGeometry: function(e) {
                    var t = new Float32Array(3 * e.vertices.length);
                    if (this.setAttribute("position", new fr(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length) {
                        var n = new Float32Array(3 * e.normals.length);
                        this.setAttribute("normal", new fr(n, 3).copyVector3sArray(e.normals))
                    }
                    if (0 < e.colors.length) {
                        var r = new Float32Array(3 * e.colors.length);
                        this.setAttribute("color", new fr(r, 3).copyColorsArray(e.colors))
                    }
                    if (0 < e.uvs.length) {
                        var i = new Float32Array(2 * e.uvs.length);
                        this.setAttribute("uv", new fr(i, 2).copyVector2sArray(e.uvs))
                    }
                    if (0 < e.uvs2.length) {
                        var o = new Float32Array(2 * e.uvs2.length);
                        this.setAttribute("uv2", new fr(o, 2).copyVector2sArray(e.uvs2))
                    }
                    for (var a in this.groups = e.groups, e.morphTargets) {
                        for (var s = [], l = e.morphTargets[a], c = 0, u = l.length; c < u; c++) {
                            var h = l[c],
                                d = new wr(3 * h.data.length, 3);
                            d.name = h.name, s.push(d.copyVector3sArray(h.data))
                        }
                        this.morphAttributes[a] = s
                    }
                    if (0 < e.skinIndices.length) {
                        var p = new wr(4 * e.skinIndices.length, 4);
                        this.setAttribute("skinIndex", p.copyVector4sArray(e.skinIndices))
                    }
                    if (0 < e.skinWeights.length) {
                        var f = new wr(4 * e.skinWeights.length, 4);
                        this.setAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
                    }
                    return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new An);
                    var e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e), t)
                            for (var n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                Rr.setFromBufferAttribute(i), this.morphTargetsRelative ? (Or.addVectors(this.boundingBox.min, Rr.min), this.boundingBox.expandByPoint(Or), Or.addVectors(this.boundingBox.max, Rr.max), this.boundingBox.expandByPoint(Or)) : (this.boundingBox.expandByPoint(Rr.min), this.boundingBox.expandByPoint(Rr.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new On);
                    var e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e) {
                        var n = this.boundingSphere.center;
                        if (Rr.setFromBufferAttribute(e), t)
                            for (var r = 0, i = t.length; r < i; r++) {
                                var o = t[r];
                                Pr.setFromBufferAttribute(o), this.morphTargetsRelative ? (Or.addVectors(Rr.min, Pr.min), Rr.expandByPoint(Or), Or.addVectors(Rr.max, Pr.max), Rr.expandByPoint(Or)) : (Rr.expandByPoint(Pr.min), Rr.expandByPoint(Pr.max))
                            }
                        Rr.getCenter(n);
                        var a = 0;
                        for (r = 0, i = e.count; r < i; r++) Or.fromBufferAttribute(e, r), a = Math.max(a, n.distanceToSquared(Or));
                        if (t)
                            for (r = 0, i = t.length; r < i; r++) {
                                o = t[r];
                                for (var s = this.morphTargetsRelative, l = 0, c = o.count; l < c; l++) Or.fromBufferAttribute(o, l), s && (Ar.fromBufferAttribute(e, l), Or.add(Ar)), a = Math.max(a, n.distanceToSquared(Or))
                            }
                        this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                },
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var e = this.index,
                        t = this.attributes;
                    if (t.position) {
                        var n = t.position.array;
                        if (void 0 === t.normal) this.setAttribute("normal", new fr(new Float32Array(n.length), 3));
                        else
                            for (var r = t.normal.array, i = 0, o = r.length; i < o; i++) r[i] = 0;
                        var a, s, l, c = t.normal.array,
                            u = new Ot,
                            h = new Ot,
                            d = new Ot,
                            p = new Ot,
                            f = new Ot;
                        if (e) {
                            var m = e.array;
                            for (i = 0, o = e.count; i < o; i += 3) a = 3 * m[i + 0], s = 3 * m[i + 1], l = 3 * m[i + 2], u.fromArray(n, a), h.fromArray(n, s), d.fromArray(n, l), p.subVectors(d, h), f.subVectors(u, h), p.cross(f), c[a] += p.x, c[1 + a] += p.y, c[2 + a] += p.z, c[s] += p.x, c[1 + s] += p.y, c[2 + s] += p.z, c[l] += p.x, c[1 + l] += p.y, c[2 + l] += p.z
                        } else
                            for (i = 0, o = n.length; i < o; i += 9) u.fromArray(n, i), h.fromArray(n, i + 3), d.fromArray(n, i + 6), p.subVectors(d, h), f.subVectors(u, h), p.cross(f), c[i] = p.x, c[i + 1] = p.y, c[i + 2] = p.z, c[i + 3] = p.x, c[i + 4] = p.y, c[i + 5] = p.z, c[i + 6] = p.x, c[i + 7] = p.y, c[i + 8] = p.z;
                        this.normalizeNormals(), t.normal.needsUpdate = !0
                    }
                },
                merge: function(e, t) {
                    if (e && e.isBufferGeometry) {
                        void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var n = this.attributes;
                        for (var r in n)
                            if (void 0 !== e.attributes[r])
                                for (var i = n[r].array, o = e.attributes[r], a = o.array, s = o.itemSize * t, l = Math.min(a.length, i.length - s), c = 0, u = s; c < l; c++, u++) i[u] = a[c];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
                },
                normalizeNormals: function() {
                    for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) Or.x = e.getX(t), Or.y = e.getY(t), Or.z = e.getZ(t), Or.normalize(), e.setXYZ(t, Or.x, Or.y, Or.z)
                },
                toNonIndexed: function() {
                    function e(e, t) {
                        for (var n = e.array, r = e.itemSize, i = new n.constructor(t.length * r), o = 0, a = 0, s = 0, l = t.length; s < l; s++) {
                            o = t[s] * r;
                            for (var c = 0; c < r; c++) i[a++] = n[o++]
                        }
                        return new fr(i, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var t = new Ir,
                        n = this.index.array,
                        r = this.attributes;
                    for (var i in r) {
                        var o = e(r[i], n);
                        t.setAttribute(i, o)
                    }
                    var a = this.morphAttributes;
                    for (i in a) {
                        for (var s = [], l = a[i], c = 0, u = l.length; c < u; c++) {
                            o = e(l[c], n);
                            s.push(o)
                        }
                        t.morphAttributes[i] = s
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    for (var h = this.groups, d = (c = 0, h.length); c < d; c++) {
                        var p = h[c];
                        t.addGroup(p.start, p.count, p.materialIndex)
                    }
                    return t
                },
                toJSON: function() {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
                        var t = this.parameters;
                        for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    var r = this.index;
                    null !== r && (e.data.index = {
                        type: r.array.constructor.name,
                        array: Array.prototype.slice.call(r.array)
                    });
                    var i = this.attributes;
                    for (var n in i) {
                        var o = (d = i[n]).toJSON();
                        "" !== d.name && (o.name = d.name), e.data.attributes[n] = o
                    }
                    var a = {},
                        s = !1;
                    for (var n in this.morphAttributes) {
                        for (var l = this.morphAttributes[n], c = [], u = 0, h = l.length; u < h; u++) {
                            var d;
                            o = (d = l[u]).toJSON();
                            "" !== d.name && (o.name = d.name), c.push(o)
                        }
                        0 < c.length && (a[n] = c, s = !0)
                    }
                    s && (e.data.morphAttributes = a, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    var p = this.groups;
                    0 < p.length && (e.data.groups = JSON.parse(JSON.stringify(p)));
                    var f = this.boundingSphere;
                    return null !== f && (e.data.boundingSphere = {
                        center: f.center.toArray(),
                        radius: f.radius
                    }), e
                },
                clone: function() {
                    return (new Ir).copy(this)
                },
                copy: function(e) {
                    var t, n, r;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var i = e.index;
                    null !== i && this.setIndex(i.clone());
                    var o = e.attributes;
                    for (t in o) {
                        var a = o[t];
                        this.setAttribute(t, a.clone())
                    }
                    var s = e.morphAttributes;
                    for (t in s) {
                        var l = [],
                            c = s[t];
                        for (n = 0, r = c.length; n < r; n++) l.push(c[n].clone());
                        this.morphAttributes[t] = l
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    var u = e.groups;
                    for (n = 0, r = u.length; n < r; n++) {
                        var h = u[n];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    var d = e.boundingBox;
                    null !== d && (this.boundingBox = d.clone());
                    var p = e.boundingSphere;
                    return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var Dr = new Zt,
                Nr = new Un,
                kr = new On,
                zr = new Ot,
                Fr = new Ot,
                Br = new Ot,
                Ur = new Ot,
                Hr = new Ot,
                Gr = new Ot,
                Vr = new Ot,
                Wr = new Ot,
                jr = new Ot,
                qr = new Lt,
                Xr = new Lt,
                Yr = new Lt,
                Zr = new Ot,
                Kr = new Ot;

            function Jr(e, t) {
                fn.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Ir, this.material = void 0 !== t ? t : new dr({
                    color: 16777215 * Math.random()
                }), this.updateMorphTargets()
            }

            function Qr(e, t, n, r, i, o, a, s) {
                if (null === (t.side === Me ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, t.side !== J, s))) return null;
                Kr.copy(s), Kr.applyMatrix4(e.matrixWorld);
                var l = n.ray.origin.distanceTo(Kr);
                return l < n.near || l > n.far ? null : {
                    distance: l,
                    point: Kr.clone(),
                    object: e
                }
            }

            function $r(e, t, n, r, i, o, a, s, l, c, u, h) {
                zr.fromBufferAttribute(i, c), Fr.fromBufferAttribute(i, u), Br.fromBufferAttribute(i, h);
                var d = e.morphTargetInfluences;
                if (t.morphTargets && o && d) {
                    Vr.set(0, 0, 0), Wr.set(0, 0, 0), jr.set(0, 0, 0);
                    for (var p = 0, f = o.length; p < f; p++) {
                        var m = d[p],
                            v = o[p];
                        0 !== m && (Ur.fromBufferAttribute(v, c), Hr.fromBufferAttribute(v, u), Gr.fromBufferAttribute(v, h), a ? (Vr.addScaledVector(Ur, m), Wr.addScaledVector(Hr, m), jr.addScaledVector(Gr, m)) : (Vr.addScaledVector(Ur.sub(zr), m), Wr.addScaledVector(Hr.sub(Fr), m), jr.addScaledVector(Gr.sub(Br), m)))
                    }
                    zr.add(Vr), Fr.add(Wr), Br.add(jr)
                }
                var g = Qr(e, t, n, r, zr, Fr, Br, Zr);
                if (g) {
                    s && (qr.fromBufferAttribute(s, c), Xr.fromBufferAttribute(s, u), Yr.fromBufferAttribute(s, h), g.uv = tr.getUV(Zr, zr, Fr, Br, qr, Xr, Yr, new Lt)), l && (qr.fromBufferAttribute(l, c), Xr.fromBufferAttribute(l, u), Yr.fromBufferAttribute(l, h), g.uv2 = tr.getUV(Zr, zr, Fr, Br, qr, Xr, Yr, new Lt));
                    var y = new cr(c, u, h);
                    tr.getNormal(zr, Fr, Br, y.normal), g.face = y
                }
                return g
            }
            Jr.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: Jr,
                isMesh: !0,
                copy: function(e) {
                    return fn.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
                },
                updateMorphTargets: function() {
                    var e, t, n, r = this.geometry;
                    if (r.isBufferGeometry) {
                        var i = r.morphAttributes,
                            o = Object.keys(i);
                        if (0 < o.length) {
                            var a = i[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    } else {
                        var s = r.morphTargets;
                        void 0 !== s && 0 < s.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                raycast: function(e, t) {
                    var n, r = this.geometry,
                        i = this.material,
                        o = this.matrixWorld;
                    if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), kr.copy(r.boundingSphere), kr.applyMatrix4(o), !1 !== e.ray.intersectsSphere(kr) && (Dr.getInverse(o), Nr.copy(e.ray).applyMatrix4(Dr), null === r.boundingBox || !1 !== Nr.intersectsBox(r.boundingBox))))
                        if (r.isBufferGeometry) {
                            var a, s, l, c, u, h, d, p, f, m = r.index,
                                v = r.attributes.position,
                                g = r.morphAttributes.position,
                                y = r.morphTargetsRelative,
                                x = r.attributes.uv,
                                b = r.attributes.uv2,
                                _ = r.groups,
                                w = r.drawRange;
                            if (null !== m)
                                if (Array.isArray(i))
                                    for (c = 0, h = _.length; c < h; c++)
                                        for (f = i[(p = _[c]).materialIndex], u = Math.max(p.start, w.start), d = Math.min(p.start + p.count, w.start + w.count); u < d; u += 3) a = m.getX(u), s = m.getX(u + 1), l = m.getX(u + 2), (n = $r(this, f, e, Nr, v, g, y, x, b, a, s, l)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = p.materialIndex, t.push(n));
                                else
                                    for (c = Math.max(0, w.start), h = Math.min(m.count, w.start + w.count); c < h; c += 3) a = m.getX(c), s = m.getX(c + 1), l = m.getX(c + 2), (n = $r(this, i, e, Nr, v, g, y, x, b, a, s, l)) && (n.faceIndex = Math.floor(c / 3), t.push(n));
                            else if (void 0 !== v)
                                if (Array.isArray(i))
                                    for (c = 0, h = _.length; c < h; c++)
                                        for (f = i[(p = _[c]).materialIndex], u = Math.max(p.start, w.start), d = Math.min(p.start + p.count, w.start + w.count); u < d; u += 3)(n = $r(this, f, e, Nr, v, g, y, x, b, a = u, s = u + 1, l = u + 2)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = p.materialIndex, t.push(n));
                                else
                                    for (c = Math.max(0, w.start), h = Math.min(v.count, w.start + w.count); c < h; c += 3)(n = $r(this, i, e, Nr, v, g, y, x, b, a = c, s = c + 1, l = c + 2)) && (n.faceIndex = Math.floor(c / 3), t.push(n))
                        } else if (r.isGeometry) {
                        var S, M, T, E, C = Array.isArray(i),
                            L = r.vertices,
                            A = r.faces,
                            R = r.faceVertexUvs[0];
                        0 < R.length && (E = R);
                        for (var P = 0, O = A.length; P < O; P++) {
                            var I = A[P],
                                D = C ? i[I.materialIndex] : i;
                            if (void 0 !== D && (S = L[I.a], M = L[I.b], T = L[I.c], n = Qr(this, D, e, Nr, S, M, T, Zr))) {
                                if (E && E[P]) {
                                    var N = E[P];
                                    qr.copy(N[0]), Xr.copy(N[1]), Yr.copy(N[2]), n.uv = tr.getUV(Zr, S, M, T, qr, Xr, Yr, new Lt)
                                }
                                n.face = I, n.faceIndex = P, t.push(n)
                            }
                        }
                    }
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });
            var ei = 0,
                ti = new Zt,
                ni = new fn,
                ri = new Ot;

            function ii() {
                Object.defineProperty(this, "id", {
                    value: ei += 2
                }), this.uuid = Ct.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
            ii.prototype = Object.assign(Object.create(Mt.prototype), {
                constructor: ii,
                isGeometry: !0,
                applyMatrix: function(e) {
                    for (var t = (new Nt).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) {
                        this.vertices[n].applyMatrix4(e)
                    }
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        var i = this.faces[n];
                        i.normal.applyMatrix3(t).normalize();
                        for (var o = 0, a = i.vertexNormals.length; o < a; o++) i.vertexNormals[o].applyMatrix3(t).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function(e) {
                    return ti.makeRotationX(e), this.applyMatrix(ti), this
                },
                rotateY: function(e) {
                    return ti.makeRotationY(e), this.applyMatrix(ti), this
                },
                rotateZ: function(e) {
                    return ti.makeRotationZ(e), this.applyMatrix(ti), this
                },
                translate: function(e, t, n) {
                    return ti.makeTranslation(e, t, n), this.applyMatrix(ti), this
                },
                scale: function(e, t, n) {
                    return ti.makeScale(e, t, n), this.applyMatrix(ti), this
                },
                lookAt: function(e) {
                    return ni.lookAt(e), ni.updateMatrix(), this.applyMatrix(ni.matrix), this
                },
                fromBufferGeometry: function(e) {
                    var a = this,
                        t = null !== e.index ? e.index.array : void 0,
                        n = e.attributes;
                    if (void 0 === n.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                    var r = n.position.array,
                        s = void 0 !== n.normal ? n.normal.array : void 0,
                        l = void 0 !== n.color ? n.color.array : void 0,
                        c = void 0 !== n.uv ? n.uv.array : void 0,
                        u = void 0 !== n.uv2 ? n.uv2.array : void 0;
                    void 0 !== u && (this.faceVertexUvs[1] = []);
                    for (var i = 0; i < r.length; i += 3) a.vertices.push((new Ot).fromArray(r, i)), void 0 !== l && a.colors.push((new or).fromArray(l, i));

                    function o(e, t, n, r) {
                        var i = void 0 === l ? [] : [a.colors[e].clone(), a.colors[t].clone(), a.colors[n].clone()],
                            o = new cr(e, t, n, void 0 === s ? [] : [(new Ot).fromArray(s, 3 * e), (new Ot).fromArray(s, 3 * t), (new Ot).fromArray(s, 3 * n)], i, r);
                        a.faces.push(o), void 0 !== c && a.faceVertexUvs[0].push([(new Lt).fromArray(c, 2 * e), (new Lt).fromArray(c, 2 * t), (new Lt).fromArray(c, 2 * n)]), void 0 !== u && a.faceVertexUvs[1].push([(new Lt).fromArray(u, 2 * e), (new Lt).fromArray(u, 2 * t), (new Lt).fromArray(u, 2 * n)])
                    }
                    var h = e.groups;
                    if (0 < h.length)
                        for (i = 0; i < h.length; i++)
                            for (var d = h[i], p = d.start, f = p, m = p + d.count; f < m; f += 3) void 0 !== t ? o(t[f], t[f + 1], t[f + 2], d.materialIndex) : o(f, f + 1, f + 2, d.materialIndex);
                    else if (void 0 !== t)
                        for (i = 0; i < t.length; i += 3) o(t[i], t[i + 1], t[i + 2]);
                    else
                        for (i = 0; i < r.length / 3; i += 3) o(i, i + 1, i + 2);
                    return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(ri).negate(), this.translate(ri.x, ri.y, ri.z), this
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    var e = this.boundingSphere.center,
                        t = this.boundingSphere.radius,
                        n = 0 === t ? 1 : 1 / t,
                        r = new Zt;
                    return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(r), this
                },
                computeFaceNormals: function() {
                    for (var e = new Ot, t = new Ot, n = 0, r = this.faces.length; n < r; n++) {
                        var i = this.faces[n],
                            o = this.vertices[i.a],
                            a = this.vertices[i.b],
                            s = this.vertices[i.c];
                        e.subVectors(s, a), t.subVectors(o, a), e.cross(t), e.normalize(), i.normal.copy(e)
                    }
                },
                computeVertexNormals: function(e) {
                    var t, n, r, i, o, a;
                    for (void 0 === e && (e = !0), a = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) a[t] = new Ot;
                    if (e) {
                        var s, l, c, u = new Ot,
                            h = new Ot;
                        for (r = 0, i = this.faces.length; r < i; r++) o = this.faces[r], s = this.vertices[o.a], l = this.vertices[o.b], c = this.vertices[o.c], u.subVectors(c, l), h.subVectors(s, l), u.cross(h), a[o.a].add(u), a[o.b].add(u), a[o.c].add(u)
                    } else
                        for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) a[(o = this.faces[r]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                    for (t = 0, n = this.vertices.length; t < n; t++) a[t].normalize();
                    for (r = 0, i = this.faces.length; r < i; r++) {
                        var d = (o = this.faces[r]).vertexNormals;
                        3 === d.length ? (d[0].copy(a[o.a]), d[1].copy(a[o.b]), d[2].copy(a[o.c])) : (d[0] = a[o.a].clone(), d[1] = a[o.b].clone(), d[2] = a[o.c].clone())
                    }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var e, t, n;
                    for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                        var r = (n = this.faces[e]).vertexNormals;
                        3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
                    }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var e, t, n, r, i;
                    for (n = 0, r = this.faces.length; n < r; n++)
                        for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
                    var o = new ii;
                    for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            var a = this.morphNormals[e].faceNormals,
                                s = this.morphNormals[e].vertexNormals;
                            for (n = 0, r = this.faces.length; n < r; n++) l = new Ot, c = {
                                a: new Ot,
                                b: new Ot,
                                c: new Ot
                            }, a.push(l), s.push(c)
                        }
                        var l, c, u = this.morphNormals[e];
                        for (o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], l = u.faceNormals[n], c = u.vertexNormals[n], l.copy(i.normal), c.a.copy(i.vertexNormals[0]), c.b.copy(i.vertexNormals[1]), c.c.copy(i.vertexNormals[2])
                    }
                    for (n = 0, r = this.faces.length; n < r; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new An), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new On), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(e, t, n) {
                    if (e && e.isGeometry) {
                        var r, i = this.vertices.length,
                            o = this.vertices,
                            a = e.vertices,
                            s = this.faces,
                            l = e.faces,
                            c = this.colors,
                            u = e.colors;
                        void 0 === n && (n = 0), void 0 !== t && (r = (new Nt).getNormalMatrix(t));
                        for (var h = 0, d = a.length; h < d; h++) {
                            var p = a[h].clone();
                            void 0 !== t && p.applyMatrix4(t), o.push(p)
                        }
                        for (h = 0, d = u.length; h < d; h++) c.push(u[h].clone());
                        for (h = 0, d = l.length; h < d; h++) {
                            var f, m, v, g = l[h],
                                y = g.vertexNormals,
                                x = g.vertexColors;
                            (f = new cr(g.a + i, g.b + i, g.c + i)).normal.copy(g.normal), void 0 !== r && f.normal.applyMatrix3(r).normalize();
                            for (var b = 0, _ = y.length; b < _; b++) m = y[b].clone(), void 0 !== r && m.applyMatrix3(r).normalize(), f.vertexNormals.push(m);
                            f.color.copy(g.color);
                            for (b = 0, _ = x.length; b < _; b++) v = x[b], f.vertexColors.push(v.clone());
                            f.materialIndex = g.materialIndex + n, s.push(f)
                        }
                        for (h = 0, d = e.faceVertexUvs.length; h < d; h++) {
                            var w = e.faceVertexUvs[h];
                            void 0 === this.faceVertexUvs[h] && (this.faceVertexUvs[h] = []);
                            for (b = 0, _ = w.length; b < _; b++) {
                                for (var S = w[b], M = [], T = 0, E = S.length; T < E; T++) M.push(S[T].clone());
                                this.faceVertexUvs[h].push(M)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
                },
                mergeMesh: function(e) {
                    e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
                },
                mergeVertices: function() {
                    var e, t, n, r, i, o, a, s, l = {},
                        c = [],
                        u = [],
                        h = Math.pow(10, 4);
                    for (n = 0, r = this.vertices.length; n < r; n++) e = this.vertices[n], void 0 === l[t = Math.round(e.x * h) + "_" + Math.round(e.y * h) + "_" + Math.round(e.z * h)] ? (l[t] = n, c.push(this.vertices[n]), u[n] = c.length - 1) : u[n] = u[l[t]];
                    var d = [];
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        (i = this.faces[n]).a = u[i.a], i.b = u[i.b], i.c = u[i.c], o = [i.a, i.b, i.c];
                        for (var p = 0; p < 3; p++)
                            if (o[p] === o[(p + 1) % 3]) {
                                d.push(n);
                                break
                            }
                    }
                    for (n = d.length - 1; 0 <= n; n--) {
                        var f = d[n];
                        for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                    }
                    var m = this.vertices.length - c.length;
                    return this.vertices = c, m
                },
                setFromPoints: function(e) {
                    this.vertices = [];
                    for (var t = 0, n = e.length; t < n; t++) {
                        var r = e[t];
                        this.vertices.push(new Ot(r.x, r.y, r.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
                    e.sort(function(e, t) {
                        return e.materialIndex - t.materialIndex
                    });
                    var r, i, o = this.faceVertexUvs[0],
                        a = this.faceVertexUvs[1];
                    o && o.length === t && (r = []), a && a.length === t && (i = []);
                    for (n = 0; n < t; n++) {
                        var s = e[n]._id;
                        r && r.push(o[s]), i && i.push(a[s])
                    }
                    r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
                },
                toJSON: function() {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                        var t = this.parameters;
                        for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    for (var r = [], i = 0; i < this.vertices.length; i++) {
                        var o = this.vertices[i];
                        r.push(o.x, o.y, o.z)
                    }
                    var a = [],
                        s = [],
                        l = {},
                        c = [],
                        u = {},
                        h = [],
                        d = {};
                    for (i = 0; i < this.faces.length; i++) {
                        var p = this.faces[i],
                            f = void 0 !== this.faceVertexUvs[0][i],
                            m = 0 < p.normal.length(),
                            v = 0 < p.vertexNormals.length,
                            g = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                            y = 0 < p.vertexColors.length,
                            x = 0;
                        if (x = S(x = S(x = S(x = S(x = S(x = S(x = S(x = S(x, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, v), 6, g), 7, y), a.push(x), a.push(p.a, p.b, p.c), a.push(p.materialIndex), f) {
                            var b = this.faceVertexUvs[0][i];
                            a.push(E(b[0]), E(b[1]), E(b[2]))
                        }
                        if (m && a.push(M(p.normal)), v) {
                            var _ = p.vertexNormals;
                            a.push(M(_[0]), M(_[1]), M(_[2]))
                        }
                        if (g && a.push(T(p.color)), y) {
                            var w = p.vertexColors;
                            a.push(T(w[0]), T(w[1]), T(w[2]))
                        }
                    }

                    function S(e, t, n) {
                        return n ? e | 1 << t : e & ~(1 << t)
                    }

                    function M(e) {
                        var t = e.x.toString() + e.y.toString() + e.z.toString();
                        return void 0 !== l[t] || (l[t] = s.length / 3, s.push(e.x, e.y, e.z)), l[t]
                    }

                    function T(e) {
                        var t = e.r.toString() + e.g.toString() + e.b.toString();
                        return void 0 !== u[t] || (u[t] = c.length, c.push(e.getHex())), u[t]
                    }

                    function E(e) {
                        var t = e.x.toString() + e.y.toString();
                        return void 0 !== d[t] || (d[t] = h.length / 2, h.push(e.x, e.y)), d[t]
                    }
                    return e.data = {}, e.data.vertices = r, e.data.normals = s, 0 < c.length && (e.data.colors = c), 0 < h.length && (e.data.uvs = [h]), e.data.faces = a, e
                },
                clone: function() {
                    return (new ii).copy(this)
                },
                copy: function(e) {
                    var t, n, r, i, o, a;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var s = e.vertices;
                    for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
                    var l = e.colors;
                    for (t = 0, n = l.length; t < n; t++) this.colors.push(l[t].clone());
                    var c = e.faces;
                    for (t = 0, n = c.length; t < n; t++) this.faces.push(c[t].clone());
                    for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                        var u = e.faceVertexUvs[t];
                        for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), r = 0, i = u.length; r < i; r++) {
                            var h = u[r],
                                d = [];
                            for (o = 0, a = h.length; o < a; o++) {
                                var p = h[o];
                                d.push(p.clone())
                            }
                            this.faceVertexUvs[t].push(d)
                        }
                    }
                    var f = e.morphTargets;
                    for (t = 0, n = f.length; t < n; t++) {
                        var m = {};
                        if (m.name = f[t].name, void 0 !== f[t].vertices)
                            for (m.vertices = [], r = 0, i = f[t].vertices.length; r < i; r++) m.vertices.push(f[t].vertices[r].clone());
                        if (void 0 !== f[t].normals)
                            for (m.normals = [], r = 0, i = f[t].normals.length; r < i; r++) m.normals.push(f[t].normals[r].clone());
                        this.morphTargets.push(m)
                    }
                    var v = e.morphNormals;
                    for (t = 0, n = v.length; t < n; t++) {
                        var g = {};
                        if (void 0 !== v[t].vertexNormals)
                            for (g.vertexNormals = [], r = 0, i = v[t].vertexNormals.length; r < i; r++) {
                                var y = v[t].vertexNormals[r],
                                    x = {};
                                x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x)
                            }
                        if (void 0 !== v[t].faceNormals)
                            for (g.faceNormals = [], r = 0, i = v[t].faceNormals.length; r < i; r++) g.faceNormals.push(v[t].faceNormals[r].clone());
                        this.morphNormals.push(g)
                    }
                    var b = e.skinWeights;
                    for (t = 0, n = b.length; t < n; t++) this.skinWeights.push(b[t].clone());
                    var _ = e.skinIndices;
                    for (t = 0, n = _.length; t < n; t++) this.skinIndices.push(_[t].clone());
                    var w = e.lineDistances;
                    for (t = 0, n = w.length; t < n; t++) this.lineDistances.push(w[t]);
                    var S = e.boundingBox;
                    null !== S && (this.boundingBox = S.clone());
                    var M = e.boundingSphere;
                    return null !== M && (this.boundingSphere = M.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var oi = function(a) {
                    function e(e, t, n, r, i, o) {
                        a.call(this), this.type = "BoxGeometry", this.parameters = {
                            width: e,
                            height: t,
                            depth: n,
                            widthSegments: r,
                            heightSegments: i,
                            depthSegments: o
                        }, this.fromBufferGeometry(new ai(e, t, n, r, i, o)), this.mergeVertices()
                    }
                    return a && (e.__proto__ = a), (e.prototype = Object.create(a && a.prototype)).constructor = e
                }(ii),
                ai = function(s) {
                    function e(e, t, n, r, i, o) {
                        s.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                            width: e,
                            height: t,
                            depth: n,
                            widthSegments: r,
                            heightSegments: i,
                            depthSegments: o
                        };
                        var A = this;
                        e = e || 1, t = t || 1, n = n || 1, r = Math.floor(r) || 1, i = Math.floor(i) || 1, o = Math.floor(o) || 1;
                        var R = [],
                            P = [],
                            O = [],
                            I = [],
                            D = 0,
                            N = 0;

                        function a(e, t, n, r, i, o, a, s, l, c, u) {
                            var h, d, p = o / l,
                                f = a / c,
                                m = o / 2,
                                v = a / 2,
                                g = s / 2,
                                y = l + 1,
                                x = c + 1,
                                b = 0,
                                _ = 0,
                                w = new Ot;
                            for (d = 0; d < x; d++) {
                                var S = d * f - v;
                                for (h = 0; h < y; h++) {
                                    var M = h * p - m;
                                    w[e] = M * r, w[t] = S * i, w[n] = g, P.push(w.x, w.y, w.z), w[e] = 0, w[t] = 0, w[n] = 0 < s ? 1 : -1, O.push(w.x, w.y, w.z), I.push(h / l), I.push(1 - d / c), b += 1
                                }
                            }
                            for (d = 0; d < c; d++)
                                for (h = 0; h < l; h++) {
                                    var T = D + h + y * d,
                                        E = D + h + y * (d + 1),
                                        C = D + (h + 1) + y * (d + 1),
                                        L = D + (h + 1) + y * d;
                                    R.push(T, E, L), R.push(E, C, L), _ += 6
                                }
                            A.addGroup(N, _, u), N += _, D += b
                        }
                        a("z", "y", "x", -1, -1, n, t, e, o, i, 0), a("z", "y", "x", 1, -1, n, t, -e, o, i, 1), a("x", "z", "y", 1, 1, e, n, t, r, o, 2), a("x", "z", "y", 1, -1, e, n, -t, r, o, 3), a("x", "y", "z", 1, -1, e, t, n, r, i, 4), a("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(R), this.setAttribute("position", new wr(P, 3)), this.setAttribute("normal", new wr(O, 3)), this.setAttribute("uv", new wr(I, 2))
                    }
                    return s && (e.__proto__ = s), (e.prototype = Object.create(s && s.prototype)).constructor = e
                }(Ir);

            function si(e) {
                var t = {};
                for (var n in e)
                    for (var r in t[n] = {}, e[n]) {
                        var i = e[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                    }
                return t
            }

            function li(e) {
                for (var t = {}, n = 0; n < e.length; n++) {
                    var r = si(e[n]);
                    for (var i in r) t[i] = r[i]
                }
                return t
            }
            var ci = {
                    clone: si,
                    merge: li
                },
                ui = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                hi = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

            function di(e) {
                hr.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = ui, this.fragmentShader = hi, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
            }

            function pi() {
                fn.call(this), this.type = "Camera", this.matrixWorldInverse = new Zt, this.projectionMatrix = new Zt, this.projectionMatrixInverse = new Zt
            }

            function fi(e, t, n, r) {
                pi.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }((di.prototype = Object.create(hr.prototype)).constructor = di).prototype.isShaderMaterial = !0, di.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = si(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
            }, di.prototype.toJSON = function(e) {
                var t = hr.prototype.toJSON.call(this, e);
                for (var n in t.uniforms = {}, this.uniforms) {
                    var r = this.uniforms[n].value;
                    r && r.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(e).uuid
                    } : r && r.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? t.uniforms[n] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : t.uniforms[n] = {
                        value: r
                    }
                }
                0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                var i = {};
                for (var o in this.extensions) !0 === this.extensions[o] && (i[o] = !0);
                return 0 < Object.keys(i).length && (t.extensions = i), t
            }, pi.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: pi,
                isCamera: !0,
                copy: function(e, t) {
                    return fn.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                },
                getWorldDirection: function(e) {
                    void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Ot), this.updateMatrixWorld(!0);
                    var t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                },
                updateMatrixWorld: function(e) {
                    fn.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), fi.prototype = Object.assign(Object.create(pi.prototype), {
                constructor: fi,
                isPerspectiveCamera: !0,
                copy: function(e, t) {
                    return pi.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                },
                setFocalLength: function(e) {
                    var t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Ct.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var e = Math.tan(.5 * Ct.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / e
                },
                getEffectiveFOV: function() {
                    return 2 * Ct.RAD2DEG * Math.atan(Math.tan(.5 * Ct.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(e, t, n, r, i, o) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var e = this.near,
                        t = e * Math.tan(.5 * Ct.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * t,
                        r = this.aspect * n,
                        i = -.5 * r,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        i += o.offsetX * r / a, t -= o.offsetY * n / s, r *= o.width / a, n *= o.height / s
                    }
                    var l = this.filmOffset;
                    0 !== l && (i += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(e) {
                    var t = fn.prototype.toJSON.call(this, e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            });

            function mi(e, t, n, r) {
                fn.call(this), this.type = "CubeCamera";
                var o = new fi(90, 1, e, t);
                o.up.set(0, -1, 0), o.lookAt(new Ot(1, 0, 0)), this.add(o);
                var a = new fi(90, 1, e, t);
                a.up.set(0, -1, 0), a.lookAt(new Ot(-1, 0, 0)), this.add(a);
                var s = new fi(90, 1, e, t);
                s.up.set(0, 0, 1), s.lookAt(new Ot(0, 1, 0)), this.add(s);
                var l = new fi(90, 1, e, t);
                l.up.set(0, 0, -1), l.lookAt(new Ot(0, -1, 0)), this.add(l);
                var c = new fi(90, 1, e, t);
                c.up.set(0, -1, 0), c.lookAt(new Ot(0, 0, 1)), this.add(c);
                var u = new fi(90, 1, e, t);
                u.up.set(0, -1, 0), u.lookAt(new Ot(0, 0, -1)), this.add(u), r = r || {
                    format: Ke,
                    magFilter: He,
                    minFilter: He
                }, this.renderTarget = new vi(n, n, r), this.renderTarget.texture.name = "CubeCamera", this.update = function(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = e.getRenderTarget(),
                        r = this.renderTarget,
                        i = r.texture.generateMipmaps;
                    r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, o), e.setRenderTarget(r, 1), e.render(t, a), e.setRenderTarget(r, 2), e.render(t, s), e.setRenderTarget(r, 3), e.render(t, l), e.setRenderTarget(r, 4), e.render(t, c), r.texture.generateMipmaps = i, e.setRenderTarget(r, 5), e.render(t, u), e.setRenderTarget(n)
                }, this.clear = function(e, t, n, r) {
                    for (var i = e.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++) e.setRenderTarget(o, a), e.clear(t, n, r);
                    e.setRenderTarget(i)
                }
            }

            function vi(e, t, n) {
                Ut.call(this, e, t, n)
            }

            function gi(e, t, n, r, i, o, a, s, l, c, u, h) {
                Ft.call(this, null, o, a, s, l, c, r, i, u, h), this.image = {
                    data: e || null,
                    width: t || 1,
                    height: n || 1
                }, this.magFilter = void 0 !== l ? l : Fe, this.minFilter = void 0 !== c ? c : Fe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }(mi.prototype = Object.create(fn.prototype)).constructor = mi, ((vi.prototype = Object.create(Ut.prototype)).constructor = vi).prototype.isWebGLRenderTargetCube = !0, vi.prototype.fromEquirectangularTexture = function(e, t) {
                this.texture.type = t.type, this.texture.format = t.format, this.texture.encoding = t.encoding;
                var n = new mn,
                    r = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
                        fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
                    },
                    i = new di({
                        type: "CubemapFromEquirect",
                        uniforms: si(r.uniforms),
                        vertexShader: r.vertexShader,
                        fragmentShader: r.fragmentShader,
                        side: Me,
                        blending: Q
                    });
                i.uniforms.tEquirect.value = t;
                var o = new Jr(new ai(5, 5, 5), i);
                n.add(o);
                var a = new mi(1, 10, 1);
                return a.renderTarget = this, a.renderTarget.texture.name = "CubeCameraTexture", a.update(e, n), o.geometry.dispose(), o.material.dispose(), this
            }, ((gi.prototype = Object.create(Ft.prototype)).constructor = gi).prototype.isDataTexture = !0;
            var yi = new On,
                xi = new Ot;

            function bi(e, t, n, r, i, o) {
                this.planes = [void 0 !== e ? e : new Wn, void 0 !== t ? t : new Wn, void 0 !== n ? n : new Wn, void 0 !== r ? r : new Wn, void 0 !== i ? i : new Wn, void 0 !== o ? o : new Wn]
            }
            Object.assign(bi.prototype, {
                set: function(e, t, n, r, i, o) {
                    var a = this.planes;
                    return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                },
                setFromMatrix: function(e) {
                    var t = this.planes,
                        n = e.elements,
                        r = n[0],
                        i = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return t[0].setComponents(a - r, u - s, f - h, y - m).normalize(), t[1].setComponents(a + r, u + s, f + h, y + m).normalize(), t[2].setComponents(a + i, u + l, f + d, y + v).normalize(), t[3].setComponents(a - i, u - l, f - d, y - v).normalize(), t[4].setComponents(a - o, u - c, f - p, y - g).normalize(), t[5].setComponents(a + o, u + c, f + p, y + g).normalize(), this
                },
                intersectsObject: function(e) {
                    var t = e.geometry;
                    return null === t.boundingSphere && t.computeBoundingSphere(), yi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(yi)
                },
                intersectsSprite: function(e) {
                    return yi.center.set(0, 0, 0), yi.radius = .7071067811865476, yi.applyMatrix4(e.matrixWorld), this.intersectsSphere(yi)
                },
                intersectsSphere: function(e) {
                    for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) {
                        if (t[i].distanceToPoint(n) < r) return !1
                    }
                    return !0
                },
                intersectsBox: function(e) {
                    for (var t = this.planes, n = 0; n < 6; n++) {
                        var r = t[n];
                        if (xi.x = 0 < r.normal.x ? e.max.x : e.min.x, xi.y = 0 < r.normal.y ? e.max.y : e.min.y, xi.z = 0 < r.normal.z ? e.max.z : e.min.z, r.distanceToPoint(xi) < 0) return !1
                    }
                    return !0
                },
                containsPoint: function(e) {
                    for (var t = this.planes, n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
            });
            var _i = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                    common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ), 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                    clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                },
                wi = {
                    common: {
                        diffuse: {
                            value: new or(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Nt
                        },
                        uv2Transform: {
                            value: new Nt
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Lt(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new or(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new or(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new Nt
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new or(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Lt(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new Nt
                        }
                    }
                },
                Si = {
                    basic: {
                        uniforms: li([wi.common, wi.specularmap, wi.envmap, wi.aomap, wi.lightmap, wi.fog]),
                        vertexShader: _i.meshbasic_vert,
                        fragmentShader: _i.meshbasic_frag
                    },
                    lambert: {
                        uniforms: li([wi.common, wi.specularmap, wi.envmap, wi.aomap, wi.lightmap, wi.emissivemap, wi.fog, wi.lights, {
                            emissive: {
                                value: new or(0)
                            }
                        }]),
                        vertexShader: _i.meshlambert_vert,
                        fragmentShader: _i.meshlambert_frag
                    },
                    phong: {
                        uniforms: li([wi.common, wi.specularmap, wi.envmap, wi.aomap, wi.lightmap, wi.emissivemap, wi.bumpmap, wi.normalmap, wi.displacementmap, wi.fog, wi.lights, {
                            emissive: {
                                value: new or(0)
                            },
                            specular: {
                                value: new or(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: _i.meshphong_vert,
                        fragmentShader: _i.meshphong_frag
                    },
                    standard: {
                        uniforms: li([wi.common, wi.envmap, wi.aomap, wi.lightmap, wi.emissivemap, wi.bumpmap, wi.normalmap, wi.displacementmap, wi.roughnessmap, wi.metalnessmap, wi.fog, wi.lights, {
                            emissive: {
                                value: new or(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: _i.meshphysical_vert,
                        fragmentShader: _i.meshphysical_frag
                    },
                    toon: {
                        uniforms: li([wi.common, wi.specularmap, wi.aomap, wi.lightmap, wi.emissivemap, wi.bumpmap, wi.normalmap, wi.displacementmap, wi.gradientmap, wi.fog, wi.lights, {
                            emissive: {
                                value: new or(0)
                            },
                            specular: {
                                value: new or(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: _i.meshtoon_vert,
                        fragmentShader: _i.meshtoon_frag
                    },
                    matcap: {
                        uniforms: li([wi.common, wi.bumpmap, wi.normalmap, wi.displacementmap, wi.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: _i.meshmatcap_vert,
                        fragmentShader: _i.meshmatcap_frag
                    },
                    points: {
                        uniforms: li([wi.points, wi.fog]),
                        vertexShader: _i.points_vert,
                        fragmentShader: _i.points_frag
                    },
                    dashed: {
                        uniforms: li([wi.common, wi.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: _i.linedashed_vert,
                        fragmentShader: _i.linedashed_frag
                    },
                    depth: {
                        uniforms: li([wi.common, wi.displacementmap]),
                        vertexShader: _i.depth_vert,
                        fragmentShader: _i.depth_frag
                    },
                    normal: {
                        uniforms: li([wi.common, wi.bumpmap, wi.normalmap, wi.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: _i.normal_vert,
                        fragmentShader: _i.normal_frag
                    },
                    sprite: {
                        uniforms: li([wi.sprite, wi.fog]),
                        vertexShader: _i.sprite_vert,
                        fragmentShader: _i.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Nt
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: _i.background_vert,
                        fragmentShader: _i.background_frag
                    },
                    cube: {
                        uniforms: li([wi.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: _i.cube_vert,
                        fragmentShader: _i.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: _i.equirect_vert,
                        fragmentShader: _i.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: li([wi.common, wi.displacementmap, {
                            referencePosition: {
                                value: new Ot
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: _i.distanceRGBA_vert,
                        fragmentShader: _i.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: li([wi.lights, wi.fog, {
                            color: {
                                value: new or(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: _i.shadow_vert,
                        fragmentShader: _i.shadow_frag
                    }
                };

            function Mi() {
                var n = null,
                    r = !1,
                    i = null;

                function o(e, t) {
                    !1 !== r && (i(e, t), n.requestAnimationFrame(o))
                }
                return {
                    start: function() {
                        !0 !== r && null !== i && (n.requestAnimationFrame(o), r = !0)
                    },
                    stop: function() {
                        r = !1
                    },
                    setAnimationLoop: function(e) {
                        i = e
                    },
                    setContext: function(e) {
                        n = e
                    }
                }
            }

            function Ti(a) {
                var r = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
                    },
                    remove: function(e) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        var t = r.get(e);
                        t && (a.deleteBuffer(t.buffer), r.delete(e))
                    },
                    update: function(e, t) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        var n = r.get(e);
                        void 0 === n ? r.set(e, function(e, t) {
                            var n = e.array,
                                r = e.usage,
                                i = a.createBuffer();
                            a.bindBuffer(t, i), a.bufferData(t, n, r), e.onUploadCallback();
                            var o = 5126;
                            return n instanceof Float32Array ? o = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? o = 5123 : n instanceof Int16Array ? o = 5122 : n instanceof Uint32Array ? o = 5125 : n instanceof Int32Array ? o = 5124 : n instanceof Int8Array ? o = 5120 : n instanceof Uint8Array && (o = 5121), {
                                buffer: i,
                                type: o,
                                bytesPerElement: n.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(e, t)) : n.version < e.version && (function(e, t, n) {
                            var r = t.array,
                                i = t.updateRange;
                            a.bindBuffer(n, e), -1 === i.count ? a.bufferSubData(n, 0, r) : (a.bufferSubData(n, i.offset * r.BYTES_PER_ELEMENT, r.subarray(i.offset, i.offset + i.count)), i.count = -1)
                        }(n.buffer, e, t), n.version = e.version)
                    }
                }
            }

            function Ei(e, t, n, r) {
                ii.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                }, this.fromBufferGeometry(new Ci(e, t, n, r)), this.mergeVertices()
            }

            function Ci(e, t, n, r) {
                Ir.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                };
                var i, o, a = (e = e || 1) / 2,
                    s = (t = t || 1) / 2,
                    l = Math.floor(n) || 1,
                    c = Math.floor(r) || 1,
                    u = l + 1,
                    h = c + 1,
                    d = e / l,
                    p = t / c,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (o = 0; o < h; o++) {
                    var y = o * p - s;
                    for (i = 0; i < u; i++) {
                        var x = i * d - a;
                        m.push(x, -y, 0), v.push(0, 0, 1), g.push(i / l), g.push(1 - o / c)
                    }
                }
                for (o = 0; o < c; o++)
                    for (i = 0; i < l; i++) {
                        var b = i + u * o,
                            _ = i + u * (o + 1),
                            w = i + 1 + u * (o + 1),
                            S = i + 1 + u * o;
                        f.push(b, _, S), f.push(_, w, S)
                    }
                this.setIndex(f), this.setAttribute("position", new wr(m, 3)), this.setAttribute("normal", new wr(v, 3)), this.setAttribute("uv", new wr(g, 2))
            }

            function Li(l, n, c, r) {
                var u, h, d = new or(0),
                    p = 0,
                    f = null,
                    m = 0;

                function v(e, t) {
                    n.buffers.color.setClear(e.r, e.g, e.b, t, r)
                }
                return {
                    getClearColor: function() {
                        return d
                    },
                    setClearColor: function(e, t) {
                        d.set(e), v(d, p = void 0 !== t ? t : 1)
                    },
                    getClearAlpha: function() {
                        return p
                    },
                    setClearAlpha: function(e) {
                        v(d, p = e)
                    },
                    render: function(e, t, n, r) {
                        var i = t.background,
                            o = l.xr,
                            a = o.getSession && o.getSession();
                        if (a && "additive" === a.environmentBlendMode && (i = null), null === i ? (v(d, p), f = null, m = 0) : i && i.isColor && (v(i, 1), r = !0, f = null, m = 0), (l.autoClear || r) && l.clear(l.autoClearColor, l.autoClearDepth, l.autoClearStencil), i && (i.isCubeTexture || i.isWebGLRenderTargetCube || i.mapping === Ie)) {
                            void 0 === h && ((h = new Jr(new ai(1, 1, 1), new di({
                                type: "BackgroundCubeMaterial",
                                uniforms: si(Si.cube.uniforms),
                                vertexShader: Si.cube.vertexShader,
                                fragmentShader: Si.cube.fragmentShader,
                                side: Me,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            }))).geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(e, t, n) {
                                this.matrixWorld.copyPosition(n.matrixWorld)
                            }, Object.defineProperty(h.material, "envMap", {
                                get: function() {
                                    return this.uniforms.envMap.value
                                }
                            }), c.update(h));
                            var s = i.isWebGLRenderTargetCube ? i.texture : i;
                            h.material.uniforms.envMap.value = s, h.material.uniforms.flipEnvMap.value = s.isCubeTexture ? -1 : 1, f === i && m === s.version || (h.material.needsUpdate = !0, f = i, m = s.version), e.unshift(h, h.geometry, h.material, 0, 0, null)
                        } else i && i.isTexture && (void 0 === u && ((u = new Jr(new Ci(2, 2), new di({
                            type: "BackgroundMaterial",
                            uniforms: si(Si.background.uniforms),
                            vertexShader: Si.background.vertexShader,
                            fragmentShader: Si.background.fragmentShader,
                            side: P,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), c.update(u)), !0 === (u.material.uniforms.t2D.value = i).matrixAutoUpdate && i.updateMatrix(), u.material.uniforms.uvTransform.value.copy(i.matrix), f === i && m === i.version || (u.material.needsUpdate = !0, m = (f = i).version), e.unshift(u, u.geometry, u.material, 0, 0, null))
                    }
                }
            }

            function Ai(a, s, l, e) {
                var c, u = e.isWebGL2;
                this.setMode = function(e) {
                    c = e
                }, this.render = function(e, t) {
                    a.drawArrays(c, e, t), l.update(t, c)
                }, this.renderInstances = function(e, t, n, r) {
                    if (0 !== r) {
                        var i, o;
                        if (u) i = a, o = "drawArraysInstanced";
                        else if (o = "drawArraysInstancedANGLE", null === (i = s.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        i[o](c, t, n, r), l.update(n, c, r)
                    }
                }
            }

            function Ri(t, n, e) {
                var r;

                function i(e) {
                    if ("highp" === e) {
                        if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
                }
                var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext,
                    a = void 0 !== e.precision ? e.precision : "highp",
                    s = i(a);
                s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
                var l = !0 === e.logarithmicDepthBuffer,
                    c = t.getParameter(34930),
                    u = t.getParameter(35660),
                    h = t.getParameter(3379),
                    d = t.getParameter(34076),
                    p = t.getParameter(34921),
                    f = t.getParameter(36347),
                    m = t.getParameter(36348),
                    v = t.getParameter(36349),
                    g = 0 < u,
                    y = o || !!n.get("OES_texture_float");
                return {
                    isWebGL2: o,
                    getMaxAnisotropy: function() {
                        if (void 0 !== r) return r;
                        var e = n.get("EXT_texture_filter_anisotropic");
                        return r = null !== e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: i,
                    precision: a,
                    logarithmicDepthBuffer: l,
                    maxTextures: c,
                    maxVertexTextures: u,
                    maxTextureSize: h,
                    maxCubemapSize: d,
                    maxAttributes: p,
                    maxVertexUniforms: f,
                    maxVaryings: m,
                    maxFragmentUniforms: v,
                    vertexTextures: g,
                    floatFragmentTextures: y,
                    floatVertexTextures: g && y,
                    maxSamples: o ? t.getParameter(36183) : 0
                }
            }

            function Pi() {
                var u = this,
                    h = null,
                    d = 0,
                    p = !1,
                    f = !1,
                    m = new Wn,
                    v = new Nt,
                    g = {
                        value: null,
                        needsUpdate: !1
                    };

                function y() {
                    g.value !== h && (g.value = h, g.needsUpdate = 0 < d), u.numPlanes = d, u.numIntersection = 0
                }

                function x(e, t, n, r) {
                    var i = null !== e ? e.length : 0,
                        o = null;
                    if (0 !== i) {
                        if (o = g.value, !0 !== r || null === o) {
                            var a = n + 4 * i,
                                s = t.matrixWorldInverse;
                            v.getNormalMatrix(s), (null === o || o.length < a) && (o = new Float32Array(a));
                            for (var l = 0, c = n; l !== i; ++l, c += 4) m.copy(e[l]).applyMatrix4(s, v), m.normal.toArray(o, c), o[c + 3] = m.constant
                        }
                        g.value = o, g.needsUpdate = !0
                    }
                    return u.numPlanes = i, o
                }
                this.uniform = g, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, n) {
                    var r = 0 !== e.length || t || 0 !== d || p;
                    return p = t, h = x(e, n, 0), d = e.length, r
                }, this.beginShadows = function() {
                    f = !0, x(null)
                }, this.endShadows = function() {
                    f = !1, y()
                }, this.setState = function(e, t, n, r, i, o) {
                    if (!p || null === e || 0 === e.length || f && !n) f ? x(null) : y();
                    else {
                        var a = f ? 0 : d,
                            s = 4 * a,
                            l = i.clippingState || null;
                        g.value = l, l = x(e, r, s, o);
                        for (var c = 0; c !== s; ++c) l[c] = h[c];
                        i.clippingState = l, this.numIntersection = t ? this.numPlanes : 0, this.numPlanes += a
                    }
                }
            }

            function Oi(n) {
                var r = {};
                return {
                    get: function(e) {
                        if (void 0 !== r[e]) return r[e];
                        var t;
                        switch (e) {
                            case "WEBGL_depth_texture":
                                t = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                t = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                t = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                t = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                t = n.getExtension(e)
                        }
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), r[e] = t
                    }
                }
            }

            function Ii(e, p, o) {
                var a = new WeakMap,
                    f = new WeakMap;

                function s(e) {
                    var t = e.target,
                        n = a.get(t);
                    for (var r in null !== n.index && p.remove(n.index), n.attributes) p.remove(n.attributes[r]);
                    t.removeEventListener("dispose", s), a.delete(t);
                    var i = f.get(n);
                    i && (p.remove(i), f.delete(n)), o.memory.geometries--
                }

                function r(e) {
                    var t = [],
                        n = e.index,
                        r = e.attributes.position,
                        i = 0;
                    if (null !== n) {
                        var o = n.array;
                        i = n.version;
                        for (var a = 0, s = o.length; a < s; a += 3) {
                            var l = o[a + 0],
                                c = o[a + 1],
                                u = o[a + 2];
                            t.push(l, c, c, u, u, l)
                        }
                    } else {
                        o = r.array;
                        i = r.version;
                        for (a = 0, s = o.length / 3 - 1; a < s; a += 3) {
                            l = a + 0, c = a + 1, u = a + 2;
                            t.push(l, c, c, u, u, l)
                        }
                    }
                    var h = new(65535 < Tr(t) ? _r : xr)(t, 1);
                    h.version = i, p.update(h, 34963);
                    var d = f.get(e);
                    d && p.remove(d), f.set(e, h)
                }
                return {
                    get: function(e, t) {
                        var n = a.get(t);
                        return n || (t.addEventListener("dispose", s), t.isBufferGeometry ? n = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Ir).setFromObject(e)), n = t._bufferGeometry), a.set(t, n), o.memory.geometries++, n)
                    },
                    update: function(e) {
                        var t = e.index,
                            n = e.attributes;
                        for (var r in null !== t && p.update(t, 34963), n) p.update(n[r], 34962);
                        var i = e.morphAttributes;
                        for (var r in i)
                            for (var o = i[r], a = 0, s = o.length; a < s; a++) p.update(o[a], 34962)
                    },
                    getWireframeAttribute: function(e) {
                        var t = f.get(e);
                        if (t) {
                            var n = e.index;
                            null !== n && t.version < n.version && r(e)
                        } else r(e);
                        return f.get(e)
                    }
                }
            }

            function Di(a, s, l, e) {
                var c, u, h, d = e.isWebGL2;
                this.setMode = function(e) {
                    c = e
                }, this.setIndex = function(e) {
                    u = e.type, h = e.bytesPerElement
                }, this.render = function(e, t) {
                    a.drawElements(c, t, u, e * h), l.update(t, c)
                }, this.renderInstances = function(e, t, n, r) {
                    if (0 !== r) {
                        var i, o;
                        if (d) i = a, o = "drawElementsInstanced";
                        else if (o = "drawElementsInstancedANGLE", null === (i = s.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        i[o](c, n, u, t * h, r), l.update(n, c, r)
                    }
                }
            }

            function Ni(e) {
                var r = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: r,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0
                    },
                    update: function(e, t, n) {
                        switch (n = n || 1, r.calls++, t) {
                            case 4:
                                r.triangles += n * (e / 3);
                                break;
                            case 1:
                                r.lines += n * (e / 2);
                                break;
                            case 3:
                                r.lines += n * (e - 1);
                                break;
                            case 2:
                                r.lines += n * e;
                                break;
                            case 0:
                                r.points += n * e;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", t)
                        }
                    }
                }
            }

            function ki(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function zi(m) {
                var v = {},
                    g = new Float32Array(8);
                return {
                    update: function(e, t, n, r) {
                        var i = e.morphTargetInfluences,
                            o = void 0 === i ? 0 : i.length,
                            a = v[t.id];
                        if (void 0 === a) {
                            a = [];
                            for (var s = 0; s < o; s++) a[s] = [s, 0];
                            v[t.id] = a
                        }
                        var l = n.morphTargets && t.morphAttributes.position,
                            c = n.morphNormals && t.morphAttributes.normal;
                        for (s = 0; s < o; s++) {
                            0 !== (h = a[s])[1] && (l && t.deleteAttribute("morphTarget" + s), c && t.deleteAttribute("morphNormal" + s))
                        }
                        for (s = 0; s < o; s++) {
                            (h = a[s])[0] = s, h[1] = i[s]
                        }
                        a.sort(ki);
                        var u = 0;
                        for (s = 0; s < 8; s++) {
                            var h;
                            if (h = a[s]) {
                                var d = h[0],
                                    p = h[1];
                                if (p) {
                                    l && t.setAttribute("morphTarget" + s, l[d]), c && t.setAttribute("morphNormal" + s, c[d]), u += g[s] = p;
                                    continue
                                }
                            }
                            g[s] = 0
                        }
                        var f = t.morphTargetsRelative ? 1 : 1 - u;
                        r.getUniforms().setValue(m, "morphTargetBaseInfluence", f), r.getUniforms().setValue(m, "morphTargetInfluences", g)
                    }
                }
            }

            function Fi(e, i, o, a) {
                var s = {};
                return {
                    update: function(e) {
                        var t = a.render.frame,
                            n = e.geometry,
                            r = i.get(e, n);
                        return s[r.id] !== t && (n.isGeometry && r.updateFromObject(e), i.update(r), s[r.id] = t), e.isInstancedMesh && o.update(e.instanceMatrix, 34962), r
                    },
                    dispose: function() {
                        s = {}
                    }
                }
            }

            function Bi(e, t, n, r, i, o, a, s, l, c) {
                Ft.call(this, e = void 0 !== e ? e : [], t = void 0 !== t ? t : q, n, r, i, o, a = void 0 !== a ? a : Ke, s, l, c), this.flipY = !1
            }

            function Ui(e, t, n, r) {
                Ft.call(this, null), this.image = {
                    data: e || null,
                    width: t || 1,
                    height: n || 1,
                    depth: r || 1
                }, this.magFilter = Fe, this.minFilter = Fe, this.wrapR = ke, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }

            function Hi(e, t, n, r) {
                Ft.call(this, null), this.image = {
                    data: e || null,
                    width: t || 1,
                    height: n || 1,
                    depth: r || 1
                }, this.magFilter = Fe, this.minFilter = Fe, this.wrapR = ke, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }
            Si.physical = {
                uniforms: li([Si.standard.uniforms, {
                    transparency: {
                        value: 0
                    },
                    clearcoat: {
                        value: 0
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    sheen: {
                        value: new or(0)
                    },
                    clearcoatNormalScale: {
                        value: new Lt(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    }
                }]),
                vertexShader: _i.meshphysical_vert,
                fragmentShader: _i.meshphysical_frag
            }, (Ei.prototype = Object.create(ii.prototype)).constructor = Ei, (Ci.prototype = Object.create(Ir.prototype)).constructor = Ci, ((Bi.prototype = Object.create(Ft.prototype)).constructor = Bi).prototype.isCubeTexture = !0, Object.defineProperty(Bi.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(e) {
                    this.image = e
                }
            }), ((Ui.prototype = Object.create(Ft.prototype)).constructor = Ui).prototype.isDataTexture2DArray = !0, ((Hi.prototype = Object.create(Ft.prototype)).constructor = Hi).prototype.isDataTexture3D = !0;
            var Gi = new Ft,
                Vi = new Ui,
                Wi = new Hi,
                ji = new Bi,
                qi = [],
                Xi = [],
                Yi = new Float32Array(16),
                Zi = new Float32Array(9),
                Ki = new Float32Array(4);

            function Ji(e, t, n) {
                var r = e[0];
                if (r <= 0 || 0 < r) return e;
                var i = t * n,
                    o = qi[i];
                if (void 0 === o && (o = new Float32Array(i), qi[i] = o), 0 !== t) {
                    r.toArray(o, 0);
                    for (var a = 1, s = 0; a !== t; ++a) s += n, e[a].toArray(o, s)
                }
                return o
            }

            function Qi(e, t) {
                if (e.length !== t.length) return !1;
                for (var n = 0, r = e.length; n < r; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function $i(e, t) {
                for (var n = 0, r = t.length; n < r; n++) e[n] = t[n]
            }

            function eo(e, t) {
                var n = Xi[t];
                void 0 === n && (n = new Int32Array(t), Xi[t] = n);
                for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
                return n
            }

            function to(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function no(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (Qi(n, t)) return;
                    e.uniform2fv(this.addr, t), $i(n, t)
                }
            }

            function ro(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (Qi(n, t)) return;
                    e.uniform3fv(this.addr, t), $i(n, t)
                }
            }

            function io(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (Qi(n, t)) return;
                    e.uniform4fv(this.addr, t), $i(n, t)
                }
            }

            function oo(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (Qi(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), $i(n, t)
                } else {
                    if (Qi(n, r)) return;
                    Ki.set(r), e.uniformMatrix2fv(this.addr, !1, Ki), $i(n, r)
                }
            }

            function ao(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (Qi(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), $i(n, t)
                } else {
                    if (Qi(n, r)) return;
                    Zi.set(r), e.uniformMatrix3fv(this.addr, !1, Zi), $i(n, r)
                }
            }

            function so(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (Qi(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), $i(n, t)
                } else {
                    if (Qi(n, r)) return;
                    Yi.set(r), e.uniformMatrix4fv(this.addr, !1, Yi), $i(n, r)
                }
            }

            function lo(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || Gi, i)
            }

            function co(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || Vi, i)
            }

            function uo(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Wi, i)
            }

            function ho(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || ji, i)
            }

            function po(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function fo(e, t) {
                var n = this.cache;
                Qi(n, t) || (e.uniform2iv(this.addr, t), $i(n, t))
            }

            function mo(e, t) {
                var n = this.cache;
                Qi(n, t) || (e.uniform3iv(this.addr, t), $i(n, t))
            }

            function vo(e, t) {
                var n = this.cache;
                Qi(n, t) || (e.uniform4iv(this.addr, t), $i(n, t))
            }

            function go(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function yo(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function xo(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function bo(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function _o(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function wo(e, t) {
                var n = Ji(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }

            function So(e, t) {
                var n = Ji(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }

            function Mo(e, t) {
                var n = Ji(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }

            function To(e, t) {
                var n = Ji(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }

            function Eo(e, t) {
                var n = Ji(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }

            function Co(e, t) {
                var n = Ji(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }

            function Lo(e, t, n) {
                var r = t.length,
                    i = eo(n, r);
                e.uniform1iv(this.addr, i);
                for (var o = 0; o !== r; ++o) n.safeSetTexture2D(t[o] || Gi, i[o])
            }

            function Ao(e, t, n) {
                var r = t.length,
                    i = eo(n, r);
                e.uniform1iv(this.addr, i);
                for (var o = 0; o !== r; ++o) n.safeSetTextureCube(t[o] || ji, i[o])
            }

            function Ro(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return to;
                        case 35664:
                            return no;
                        case 35665:
                            return ro;
                        case 35666:
                            return io;
                        case 35674:
                            return oo;
                        case 35675:
                            return ao;
                        case 35676:
                            return so;
                        case 35678:
                        case 36198:
                            return lo;
                        case 35679:
                            return uo;
                        case 35680:
                            return ho;
                        case 36289:
                            return co;
                        case 5124:
                        case 35670:
                            return po;
                        case 35667:
                        case 35671:
                            return fo;
                        case 35668:
                        case 35672:
                            return mo;
                        case 35669:
                        case 35673:
                            return vo
                    }
                }(t.type)
            }

            function Po(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return go;
                        case 35664:
                            return wo;
                        case 35665:
                            return So;
                        case 35666:
                            return Mo;
                        case 35674:
                            return To;
                        case 35675:
                            return Eo;
                        case 35676:
                            return Co;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                            return Lo;
                        case 35680:
                        case 36300:
                        case 36308:
                            return Ao;
                        case 5124:
                        case 35670:
                            return yo;
                        case 35667:
                        case 35671:
                            return xo;
                        case 35668:
                        case 35672:
                            return bo;
                        case 35669:
                        case 35673:
                            return _o
                    }
                }(t.type)
            }

            function Oo(e) {
                this.id = e, this.seq = [], this.map = {}
            }
            Po.prototype.updateCache = function(e) {
                var t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), $i(t, e)
            }, Oo.prototype.setValue = function(e, t, n) {
                for (var r = this.seq, i = 0, o = r.length; i !== o; ++i) {
                    var a = r[i];
                    a.setValue(e, t[a.id], n)
                }
            };
            var Io = /([\w\d_]+)(\])?(\[|\.)?/g;

            function Do(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function No(e, t, n) {
                var r = e.name,
                    i = r.length;
                for (Io.lastIndex = 0;;) {
                    var o = Io.exec(r),
                        a = Io.lastIndex,
                        s = o[1],
                        l = "]" === o[2],
                        c = o[3];
                    if (l && (s |= 0), void 0 === c || "[" === c && a + 2 === i) {
                        Do(n, void 0 === c ? new Ro(s, e, t) : new Po(s, e, t));
                        break
                    }
                    var u = n.map[s];
                    void 0 === u && Do(n, u = new Oo(s)), n = u
                }
            }

            function ko(e, t) {
                this.seq = [], this.map = {};
                for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
                    var i = e.getActiveUniform(t, r);
                    No(i, e.getUniformLocation(t, i.name), this)
                }
            }

            function zo(e, t, n) {
                var r = e.createShader(t);
                return e.shaderSource(r, n), e.compileShader(r), r
            }
            ko.prototype.setValue = function(e, t, n, r) {
                var i = this.map[t];
                void 0 !== i && i.setValue(e, n, r)
            }, ko.prototype.setOptional = function(e, t, n) {
                var r = t[n];
                void 0 !== r && this.setValue(e, n, r)
            }, ko.upload = function(e, t, n, r) {
                for (var i = 0, o = t.length; i !== o; ++i) {
                    var a = t[i],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(e, s.value, r)
                }
            }, ko.seqWithValue = function(e, t) {
                for (var n = [], r = 0, i = e.length; r !== i; ++r) {
                    var o = e[r];
                    o.id in t && n.push(o)
                }
                return n
            };
            var Fo = 0;

            function Bo(e) {
                switch (e) {
                    case ut:
                        return ["Linear", "( value )"];
                    case t:
                        return ["sRGB", "( value )"];
                    case ht:
                        return ["RGBE", "( value )"];
                    case pt:
                        return ["RGBM", "( value, 7.0 )"];
                    case ft:
                        return ["RGBM", "( value, 16.0 )"];
                    case mt:
                        return ["RGBD", "( value, 256.0 )"];
                    case n:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case dt:
                        return ["LogLuv", "( value )"];
                    default:
                        throw new Error("unsupported encoding: " + e)
                }
            }

            function Uo(e, t, n) {
                var r = e.getShaderParameter(t, 35713),
                    i = e.getShaderInfoLog(t).trim();
                return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function(e) {
                    for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
                    return t.join("\n")
                }(e.getShaderSource(t))
            }

            function Ho(e, t) {
                var n = Bo(t);
                return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function Go(e) {
                return "" !== e
            }

            function Vo(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function Wo(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            var jo = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function qo(e) {
                return e.replace(jo, Xo)
            }

            function Xo(e, t) {
                var n = _i[t];
                if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
                return qo(n)
            }
            var Yo = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

            function Zo(e) {
                return e.replace(Yo, Ko)
            }

            function Ko(e, t, n, r) {
                for (var i = "", o = parseInt(t); o < parseInt(n); o++) i += r.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
                return i
            }

            function Jo(e) {
                var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function Qo(e, t, n, r, i, o) {
                var a, s, l = e.getContext(),
                    c = r.defines,
                    u = i.vertexShader,
                    h = i.fragmentShader,
                    d = function(e) {
                        var t = "SHADOWMAP_TYPE_BASIC";
                        return e.shadowMapType === N ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === k ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === z && (t = "SHADOWMAP_TYPE_VSM"), t
                    }(o),
                    p = function(e) {
                        var t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case q:
                            case X:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case Ie:
                            case De:
                                t = "ENVMAP_TYPE_CUBE_UV";
                                break;
                            case Re:
                            case Pe:
                                t = "ENVMAP_TYPE_EQUIREC";
                                break;
                            case Oe:
                                t = "ENVMAP_TYPE_SPHERE"
                        }
                        return t
                    }(o),
                    f = function(e) {
                        var t = "ENVMAP_MODE_REFLECTION";
                        if (e.envMap) switch (e.envMapMode) {
                            case X:
                            case Pe:
                                t = "ENVMAP_MODE_REFRACTION"
                        }
                        return t
                    }(o),
                    m = function(e) {
                        var t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case F:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case B:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case U:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(o),
                    v = 0 < e.gammaFactor ? e.gammaFactor : 1,
                    g = o.isWebGL2 ? "" : function(e, t, n) {
                        return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Go).join("\n")
                    }(r.extensions, o, t),
                    y = function(e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            !1 !== r && t.push("#define " + n + " " + r)
                        }
                        return t.join("\n")
                    }(c),
                    x = l.createProgram(),
                    b = o.numMultiviewViews;
                if (r.isRawShaderMaterial ? (0 < (a = [y].filter(Go).join("\n")).length && (a += "\n"), 0 < (s = [g, y].filter(Go).join("\n")).length && (s += "\n")) : (a = [Jo(o), "#define SHADER_NAME " + i.name, y, o.instancing ? "#define USE_INSTANCING" : "", o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + v, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexUvs ? "#define USE_UV" : "", o.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Go).join("\n"), s = [g, Jo(o), "#define SHADER_NAME " + i.name, y, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + v, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.sheen ? "#define USE_SHEEN" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexUvs ? "#define USE_UV" : "", o.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (r.extensions && r.extensions.shaderTextureLOD || o.envMap) && (o.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", o.toneMapping !== H ? "#define TONE_MAPPING" : "", o.toneMapping !== H ? _i.tonemapping_pars_fragment : "", o.toneMapping !== H ? function(e, t) {
                        var n;
                        switch (t) {
                            case Ae:
                                n = "Linear";
                                break;
                            case G:
                                n = "Reinhard";
                                break;
                            case V:
                                n = "Uncharted2";
                                break;
                            case W:
                                n = "OptimizedCineon";
                                break;
                            case j:
                                n = "ACESFilmic";
                                break;
                            default:
                                throw new Error("unsupported toneMapping: " + t)
                        }
                        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                    }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding || o.lightMapEncoding ? _i.encodings_pars_fragment : "", o.mapEncoding ? Ho("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Ho("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Ho("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Ho("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.lightMapEncoding ? Ho("lightMapTexelToLinear", o.lightMapEncoding) : "", o.outputEncoding ? function(e, t) {
                        var n = Bo(t);
                        return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                    }("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(Go).join("\n")), u = Wo(u = Vo(u = qo(u), o), o), h = Wo(h = Vo(h = qo(h), o), o), u = Zo(u), h = Zo(h), o.isWebGL2 && !r.isRawShaderMaterial) {
                    var _ = !1,
                        w = /^\s*#version\s+300\s+es\s*\n/;
                    r.isShaderMaterial && null !== u.match(w) && null !== h.match(w) && (_ = !0, u = u.replace(w, ""), h = h.replace(w, "")), a = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + a, s = ["#version 300 es\n", "#define varying in", _ ? "" : "out highp vec4 pc_fragColor;", _ ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + s, 0 < b && (a = (a = a.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "layout(num_views = " + b + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join("\n"), ["uniform mat4 modelViewMatrices[" + b + "];", "uniform mat4 projectionMatrices[" + b + "];", "uniform mat4 viewMatrices[" + b + "];", "uniform mat3 normalMatrices[" + b + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), s = (s = s.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + b + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n")))
                }
                var S, M, T = s + h,
                    E = zo(l, 35633, a + u),
                    C = zo(l, 35632, T);
                if (l.attachShader(x, E), l.attachShader(x, C), void 0 !== r.index0AttributeName ? l.bindAttribLocation(x, 0, r.index0AttributeName) : !0 === o.morphTargets && l.bindAttribLocation(x, 0, "position"), l.linkProgram(x), e.debug.checkShaderErrors) {
                    var L = l.getProgramInfoLog(x).trim(),
                        A = l.getShaderInfoLog(E).trim(),
                        R = l.getShaderInfoLog(C).trim(),
                        P = !0,
                        O = !0;
                    if (!1 === l.getProgramParameter(x, 35714)) {
                        P = !1;
                        var I = Uo(l, E, "vertex"),
                            D = Uo(l, C, "fragment");
                        console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(x, 35715), "gl.getProgramInfoLog", L, I, D)
                    } else "" !== L ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", L) : "" !== A && "" !== R || (O = !1);
                    O && (this.diagnostics = {
                        runnable: P,
                        material: r,
                        programLog: L,
                        vertexShader: {
                            log: A,
                            prefix: a
                        },
                        fragmentShader: {
                            log: R,
                            prefix: s
                        }
                    })
                }
                return l.deleteShader(E), l.deleteShader(C), this.getUniforms = function() {
                    return void 0 === S && (S = new ko(l, x)), S
                }, this.getAttributes = function() {
                    return void 0 === M && (M = function(e, t) {
                        for (var n = {}, r = e.getProgramParameter(t, 35721), i = 0; i < r; i++) {
                            var o = e.getActiveAttrib(t, i).name;
                            n[o] = e.getAttribLocation(t, o)
                        }
                        return n
                    }(l, x)), M
                }, this.destroy = function() {
                    l.deleteProgram(x), this.program = void 0
                }, this.name = i.name, this.id = Fo++, this.cacheKey = n, this.usedTimes = 1, this.program = x, this.vertexShader = E, this.fragmentShader = C, this.numMultiviewViews = b, this
            }

            function $o(f, l, m) {
                var c = [],
                    v = m.isWebGL2,
                    g = m.logarithmicDepthBuffer,
                    y = m.floatVertexTextures,
                    x = m.precision,
                    b = m.maxVertexUniforms,
                    _ = m.vertexTextures,
                    w = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    o = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "numMultiviewViews", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

                function S(e) {
                    var t;
                    return e ? e.isTexture ? t = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = ut, t
                }
                this.getParameters = function(e, t, n, r, i, o, a) {
                    var s = r.fog,
                        l = e.isMeshStandardMaterial ? r.environment : null,
                        c = e.envMap || l,
                        u = w[e.type],
                        h = a.isSkinnedMesh ? function(e) {
                            var t = e.skeleton.bones;
                            if (y) return 1024;
                            var n = b,
                                r = Math.floor((n - 20) / 4),
                                i = Math.min(r, t.length);
                            return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i
                        }(a) : 0;
                    null !== e.precision && (x = m.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", x, "instead.");
                    var d = f.getRenderTarget(),
                        p = d && d.isWebGLMultiviewRenderTarget ? d.numViews : 0;
                    return {
                        isWebGL2: v,
                        shaderID: u,
                        precision: x,
                        instancing: !0 === a.isInstancedMesh,
                        supportsVertexTextures: _,
                        numMultiviewViews: p,
                        outputEncoding: null !== d ? S(d.texture) : f.outputEncoding,
                        map: !!e.map,
                        mapEncoding: S(e.map),
                        matcap: !!e.matcap,
                        matcapEncoding: S(e.matcap),
                        envMap: !!c,
                        envMapMode: c && c.mapping,
                        envMapEncoding: S(c),
                        envMapCubeUV: !!c && (c.mapping === Ie || c.mapping === De),
                        lightMap: !!e.lightMap,
                        lightMapEncoding: S(e.lightMap),
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: S(e.emissiveMap),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        objectSpaceNormalMap: e.normalMapType === xt,
                        tangentSpaceNormalMap: e.normalMapType === yt,
                        clearcoatNormalMap: !!e.clearcoatNormalMap,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        sheen: !!e.sheen,
                        combine: e.combine,
                        vertexTangents: e.normalMap && e.vertexTangents,
                        vertexColors: e.vertexColors,
                        vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || e.displacementMap),
                        uvsVertexOnly: !(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || !e.displacementMap),
                        fog: !!s,
                        useFog: e.fog,
                        fogExp2: s && s.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: g,
                        skinning: e.skinning && 0 < h,
                        maxBones: h,
                        useVertexTexture: y,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: f.maxMorphTargets,
                        maxMorphNormals: f.maxMorphNormals,
                        numDirLights: t.directional.length,
                        numPointLights: t.point.length,
                        numSpotLights: t.spot.length,
                        numRectAreaLights: t.rectArea.length,
                        numHemiLights: t.hemi.length,
                        numDirLightShadows: t.directionalShadowMap.length,
                        numPointLightShadows: t.pointShadowMap.length,
                        numSpotLightShadows: t.spotShadowMap.length,
                        numClippingPlanes: i,
                        numClipIntersection: o,
                        dithering: e.dithering,
                        shadowMapEnabled: f.shadowMap.enabled && 0 < n.length,
                        shadowMapType: f.shadowMap.type,
                        toneMapping: e.toneMapped ? f.toneMapping : H,
                        physicallyCorrectLights: f.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: e.side === J,
                        flipSided: e.side === Me,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking
                    }
                }, this.getProgramCacheKey = function(e, t) {
                    var n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) n.push(r), n.push(e.defines[r]);
                    if (void 0 === e.isRawShaderMaterial) {
                        for (var i = 0; i < o.length; i++) n.push(t[o[i]]);
                        n.push(f.outputEncoding), n.push(f.gammaFactor)
                    }
                    return n.push(e.onBeforeCompile.toString()), n.join()
                }, this.acquireProgram = function(e, t, n, r) {
                    for (var i, o = 0, a = c.length; o < a; o++) {
                        var s = c[o];
                        if (s.cacheKey === r) {
                            ++(i = s).usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Qo(f, l, r, e, t, n), c.push(i)), i
                }, this.releaseProgram = function(e) {
                    if (0 == --e.usedTimes) {
                        var t = c.indexOf(e);
                        c[t] = c[c.length - 1], c.pop(), e.destroy()
                    }
                }, this.programs = c
            }

            function ea() {
                var r = new WeakMap;
                return {
                    get: function(e) {
                        var t = r.get(e);
                        return void 0 === t && (t = {}, r.set(e, t)), t
                    },
                    remove: function(e) {
                        r.delete(e)
                    },
                    update: function(e, t, n) {
                        r.get(e)[t] = n
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }

            function ta(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function na(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function ra() {
                var s = [],
                    l = 0,
                    c = [],
                    u = [],
                    h = {
                        id: -1
                    };

                function d(e, t, n, r, i, o) {
                    var a = s[l];
                    return void 0 === a ? (a = {
                        id: e.id,
                        object: e,
                        geometry: t,
                        material: n,
                        program: n.program || h,
                        groupOrder: r,
                        renderOrder: e.renderOrder,
                        z: i,
                        group: o
                    }, s[l] = a) : (a.id = e.id, a.object = e, a.geometry = t, a.material = n, a.program = n.program || h, a.groupOrder = r, a.renderOrder = e.renderOrder, a.z = i, a.group = o), l++, a
                }
                return {
                    opaque: c,
                    transparent: u,
                    init: function() {
                        l = 0, c.length = 0, u.length = 0
                    },
                    push: function(e, t, n, r, i, o) {
                        var a = d(e, t, n, r, i, o);
                        (!0 === n.transparent ? u : c).push(a)
                    },
                    unshift: function(e, t, n, r, i, o) {
                        var a = d(e, t, n, r, i, o);
                        (!0 === n.transparent ? u : c).unshift(a)
                    },
                    sort: function(e, t) {
                        1 < c.length && c.sort(e || ta), 1 < u.length && u.sort(t || na)
                    }
                }
            }

            function ia() {
                var i = new WeakMap;

                function o(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", o), i.delete(t)
                }
                return {
                    get: function(e, t) {
                        var n, r = i.get(e);
                        return void 0 === r ? (n = new ra, i.set(e, new WeakMap), i.get(e).set(t, n), e.addEventListener("dispose", o)) : void 0 === (n = r.get(t)) && (n = new ra, r.set(t, n)), n
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }

            function oa() {
                var n = {};
                return {
                    get: function(e) {
                        if (void 0 !== n[e.id]) return n[e.id];
                        var t;
                        switch (e.type) {
                            case "DirectionalLight":
                                t = {
                                    direction: new Ot,
                                    color: new or,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Lt
                                };
                                break;
                            case "SpotLight":
                                t = {
                                    position: new Ot,
                                    direction: new Ot,
                                    color: new or,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Lt
                                };
                                break;
                            case "PointLight":
                                t = {
                                    position: new Ot,
                                    color: new or,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Lt,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break;
                            case "HemisphereLight":
                                t = {
                                    direction: new Ot,
                                    skyColor: new or,
                                    groundColor: new or
                                };
                                break;
                            case "RectAreaLight":
                                t = {
                                    color: new or,
                                    position: new Ot,
                                    halfWidth: new Ot,
                                    halfHeight: new Ot
                                }
                        }
                        return n[e.id] = t
                    }
                }
            }
            var aa = 0;

            function sa(e, t) {
                return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
            }

            function la() {
                for (var E = new oa, C = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    }, e = 0; e < 9; e++) C.probe.push(new Ot);
                var L = new Ot,
                    A = new Zt,
                    R = new Zt;
                return {
                    setup: function(e, t, n) {
                        for (var r = 0, i = 0, o = 0, a = 0; a < 9; a++) C.probe[a].set(0, 0, 0);
                        var s = 0,
                            l = 0,
                            c = 0,
                            u = 0,
                            h = 0,
                            d = 0,
                            p = 0,
                            f = 0,
                            m = n.matrixWorldInverse;
                        e.sort(sa), a = 0;
                        for (var v = e.length; a < v; a++) {
                            var g = e[a],
                                y = g.color,
                                x = g.intensity,
                                b = g.distance,
                                _ = g.shadow && g.shadow.map ? g.shadow.map.texture : null;
                            if (g.isAmbientLight) r += y.r * x, i += y.g * x, o += y.b * x;
                            else if (g.isLightProbe)
                                for (var w = 0; w < 9; w++) C.probe[w].addScaledVector(g.sh.coefficients[w], x);
                            else if (g.isDirectionalLight) {
                                if ((M = E.get(g)).color.copy(g.color).multiplyScalar(g.intensity), M.direction.setFromMatrixPosition(g.matrixWorld), L.setFromMatrixPosition(g.target.matrixWorld), M.direction.sub(L), M.direction.transformDirection(m), M.shadow = g.castShadow, g.castShadow) {
                                    var S = g.shadow;
                                    M.shadowBias = S.bias, M.shadowRadius = S.radius, M.shadowMapSize = S.mapSize, C.directionalShadowMap[s] = _, C.directionalShadowMatrix[s] = g.shadow.matrix, d++
                                }
                                C.directional[s] = M, s++
                            } else if (g.isSpotLight) {
                                if ((M = E.get(g)).position.setFromMatrixPosition(g.matrixWorld), M.position.applyMatrix4(m), M.color.copy(y).multiplyScalar(x), M.distance = b, M.direction.setFromMatrixPosition(g.matrixWorld), L.setFromMatrixPosition(g.target.matrixWorld), M.direction.sub(L), M.direction.transformDirection(m), M.coneCos = Math.cos(g.angle), M.penumbraCos = Math.cos(g.angle * (1 - g.penumbra)), M.decay = g.decay, M.shadow = g.castShadow, g.castShadow) {
                                    S = g.shadow;
                                    M.shadowBias = S.bias, M.shadowRadius = S.radius, M.shadowMapSize = S.mapSize, C.spotShadowMap[c] = _, C.spotShadowMatrix[c] = g.shadow.matrix, f++
                                }
                                C.spot[c] = M, c++
                            } else if (g.isRectAreaLight) {
                                (M = E.get(g)).color.copy(y).multiplyScalar(x), M.position.setFromMatrixPosition(g.matrixWorld), M.position.applyMatrix4(m), R.identity(), A.copy(g.matrixWorld), A.premultiply(m), R.extractRotation(A), M.halfWidth.set(.5 * g.width, 0, 0), M.halfHeight.set(0, .5 * g.height, 0), M.halfWidth.applyMatrix4(R), M.halfHeight.applyMatrix4(R), C.rectArea[u] = M, u++
                            } else if (g.isPointLight) {
                                if ((M = E.get(g)).position.setFromMatrixPosition(g.matrixWorld), M.position.applyMatrix4(m), M.color.copy(g.color).multiplyScalar(g.intensity), M.distance = g.distance, M.decay = g.decay, M.shadow = g.castShadow, g.castShadow) {
                                    S = g.shadow;
                                    M.shadowBias = S.bias, M.shadowRadius = S.radius, M.shadowMapSize = S.mapSize, M.shadowCameraNear = S.camera.near, M.shadowCameraFar = S.camera.far, C.pointShadowMap[l] = _, C.pointShadowMatrix[l] = g.shadow.matrix, p++
                                }
                                C.point[l] = M, l++
                            } else if (g.isHemisphereLight) {
                                var M;
                                (M = E.get(g)).direction.setFromMatrixPosition(g.matrixWorld), M.direction.transformDirection(m), M.direction.normalize(), M.skyColor.copy(g.color).multiplyScalar(x), M.groundColor.copy(g.groundColor).multiplyScalar(x), C.hemi[h] = M, h++
                            }
                        }
                        C.ambient[0] = r, C.ambient[1] = i, C.ambient[2] = o;
                        var T = C.hash;
                        T.directionalLength === s && T.pointLength === l && T.spotLength === c && T.rectAreaLength === u && T.hemiLength === h && T.numDirectionalShadows === d && T.numPointShadows === p && T.numSpotShadows === f || (C.directional.length = s, C.spot.length = c, C.rectArea.length = u, C.point.length = l, C.hemi.length = h, C.directionalShadowMap.length = d, C.pointShadowMap.length = p, C.spotShadowMap.length = f, C.directionalShadowMatrix.length = d, C.pointShadowMatrix.length = p, C.spotShadowMatrix.length = f, T.directionalLength = s, T.pointLength = l, T.spotLength = c, T.rectAreaLength = u, T.hemiLength = h, T.numDirectionalShadows = d, T.numPointShadows = p, T.numSpotShadows = f, C.version = aa++)
                    },
                    state: C
                }
            }

            function ca() {
                var t = new la,
                    n = [],
                    r = [];
                return {
                    init: function() {
                        n.length = 0, r.length = 0
                    },
                    state: {
                        lightsArray: n,
                        shadowsArray: r,
                        lights: t
                    },
                    setupLights: function(e) {
                        t.setup(n, r, e)
                    },
                    pushLight: function(e) {
                        n.push(e)
                    },
                    pushShadow: function(e) {
                        r.push(e)
                    }
                }
            }

            function ua() {
                var r = new WeakMap;

                function i(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", i), r.delete(t)
                }
                return {
                    get: function(e, t) {
                        var n;
                        return !1 === r.has(e) ? (n = new ca, r.set(e, new WeakMap), r.get(e).set(t, n), e.addEventListener("dispose", i)) : !1 === r.get(e).has(t) ? (n = new ca, r.get(e).set(t, n)) : n = r.get(e).get(t), n
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }

            function ha(e) {
                hr.call(this), this.type = "MeshDepthMaterial", this.depthPacking = vt, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
            }

            function da(e) {
                hr.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Ot, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
            }((ha.prototype = Object.create(hr.prototype)).constructor = ha).prototype.isMeshDepthMaterial = !0, ha.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }, ((da.prototype = Object.create(hr.prototype)).constructor = da).prototype.isMeshDistanceMaterial = !0, da.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            };
            var pa = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
                fa = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

            function ma(v, g, y) {
                var x = new bi,
                    b = new Lt,
                    _ = new Lt,
                    w = new Bt,
                    o = [],
                    a = [],
                    S = {},
                    M = {
                        0: Me,
                        1: P,
                        2: J
                    },
                    r = new di({
                        defines: {
                            SAMPLE_RATE: .25,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Lt
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: fa,
                        fragmentShader: pa
                    }),
                    i = r.clone();
                i.defines.HORIZONAL_PASS = 1;
                var e = new Ir;
                e.setAttribute("position", new fr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                var s = new Jr(e, r),
                    T = this;

                function E(e, t) {
                    var n = g.update(s);
                    r.uniforms.shadow_pass.value = e.map.texture, r.uniforms.resolution.value = e.mapSize, r.uniforms.radius.value = e.radius, v.setRenderTarget(e.mapPass), v.clear(), v.renderBufferDirect(t, null, n, r, s, null), i.uniforms.shadow_pass.value = e.mapPass.texture, i.uniforms.resolution.value = e.mapSize, i.uniforms.radius.value = e.radius, v.setRenderTarget(e.map), v.clear(), v.renderBufferDirect(t, null, n, i, s, null)
                }

                function C(e, t, n) {
                    var r = e << 0 | t << 1 | n << 2,
                        i = o[r];
                    return void 0 === i && (i = new ha({
                        depthPacking: gt,
                        morphTargets: e,
                        skinning: t
                    }), o[r] = i), i
                }

                function L(e, t, n) {
                    var r = e << 0 | t << 1 | n << 2,
                        i = a[r];
                    return void 0 === i && (i = new da({
                        morphTargets: e,
                        skinning: t
                    }), a[r] = i), i
                }

                function A(e, t, n, r, i, o) {
                    var a = e.geometry,
                        s = null,
                        l = C,
                        c = e.customDepthMaterial;
                    if (!0 === n.isPointLight && (l = L, c = e.customDistanceMaterial), void 0 === c) {
                        var u = !1;
                        !0 === t.morphTargets && (!0 === a.isBufferGeometry ? u = a.morphAttributes && a.morphAttributes.position && 0 < a.morphAttributes.position.length : !0 === a.isGeometry && (u = a.morphTargets && 0 < a.morphTargets.length));
                        var h = !1;
                        !0 === e.isSkinnedMesh && (!0 === t.skinning ? h = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), s = l(u, h, !0 === e.isInstancedMesh)
                    } else s = c;
                    if (v.localClippingEnabled && !0 === t.clipShadows && 0 !== t.clippingPlanes.length) {
                        var d = s.uuid,
                            p = t.uuid,
                            f = S[d];
                        void 0 === f && (f = {}, S[d] = f);
                        var m = f[p];
                        void 0 === m && (m = s.clone(), f[p] = m), s = m
                    }
                    return s.visible = t.visible, s.wireframe = t.wireframe, s.side = o === z ? null !== t.shadowSide ? t.shadowSide : t.side : null !== t.shadowSide ? t.shadowSide : M[t.side], s.clipShadows = t.clipShadows, s.clippingPlanes = t.clippingPlanes, s.clipIntersection = t.clipIntersection, s.wireframeLinewidth = t.wireframeLinewidth, s.linewidth = t.linewidth, !0 === n.isPointLight && !0 === s.isMeshDistanceMaterial && (s.referencePosition.setFromMatrixPosition(n.matrixWorld), s.nearDistance = r, s.farDistance = i), s
                }

                function R(e, t, n, r, i) {
                    if (!1 !== e.visible) {
                        if (e.layers.test(t.layers) && (e.isMesh || e.isLine || e.isPoints) && (e.castShadow || e.receiveShadow && i === z) && (!e.frustumCulled || x.intersectsObject(e))) {
                            e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld);
                            var o = g.update(e),
                                a = e.material;
                            if (Array.isArray(a))
                                for (var s = o.groups, l = 0, c = s.length; l < c; l++) {
                                    var u = s[l],
                                        h = a[u.materialIndex];
                                    if (h && h.visible) {
                                        var d = A(e, h, r, n.near, n.far, i);
                                        v.renderBufferDirect(n, null, o, d, e, u)
                                    }
                                } else if (a.visible) {
                                    d = A(e, a, r, n.near, n.far, i);
                                    v.renderBufferDirect(n, null, o, d, e, null)
                                }
                        }
                        for (var p = e.children, f = 0, m = p.length; f < m; f++) R(p[f], t, n, r, i)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = N, this.render = function(e, t, n) {
                    if (!1 !== T.enabled && (!1 !== T.autoUpdate || !1 !== T.needsUpdate) && 0 !== e.length) {
                        var r = v.getRenderTarget(),
                            i = v.getActiveCubeFace(),
                            o = v.getActiveMipmapLevel(),
                            a = v.state;
                        a.setBlending(Q), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1);
                        for (var s = 0, l = e.length; s < l; s++) {
                            var c = e[s],
                                u = c.shadow;
                            if (void 0 !== u) {
                                b.copy(u.mapSize);
                                var h = u.getFrameExtents();
                                if (b.multiply(h), _.copy(u.mapSize), (b.x > y || b.y > y) && (console.warn("THREE.WebGLShadowMap:", c, "has shadow exceeding max texture size, reducing"), b.x > y && (_.x = Math.floor(y / h.x), b.x = _.x * h.x, u.mapSize.x = _.x), b.y > y && (_.y = Math.floor(y / h.y), b.y = _.y * h.y, u.mapSize.y = _.y)), null === u.map && !u.isPointLightShadow && this.type === z) {
                                    var d = {
                                        minFilter: He,
                                        magFilter: He,
                                        format: Je
                                    };
                                    u.map = new Ut(b.x, b.y, d), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new Ut(b.x, b.y, d), u.camera.updateProjectionMatrix()
                                }
                                if (null === u.map) {
                                    d = {
                                        minFilter: Fe,
                                        magFilter: Fe,
                                        format: Je
                                    };
                                    u.map = new Ut(b.x, b.y, d), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
                                }
                                v.setRenderTarget(u.map), v.clear();
                                for (var p = u.getViewportCount(), f = 0; f < p; f++) {
                                    var m = u.getViewport(f);
                                    w.set(_.x * m.x, _.y * m.y, _.x * m.z, _.y * m.w), a.viewport(w), u.updateMatrices(c, f), x = u.getFrustum(), R(t, n, u.camera, c, this.type)
                                }
                                u.isPointLightShadow || this.type !== z || E(u, n)
                            } else console.warn("THREE.WebGLShadowMap:", c, "has no shadow.")
                        }
                        T.needsUpdate = !1, v.setRenderTarget(r, i, o)
                    }
                }
            }

            function va(u, n, e) {
                var r = e.isWebGL2;
                var i = new function() {
                        var t = !1,
                            o = new Bt,
                            n = null,
                            a = new Bt(0, 0, 0, 0);
                        return {
                            setMask: function(e) {
                                n === e || t || (u.colorMask(e, e, e, e), n = e)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(e, t, n, r, i) {
                                !0 === i && (e *= r, t *= r, n *= r), o.set(e, t, n, r), !1 === a.equals(o) && (u.clearColor(e, t, n, r), a.copy(o))
                            },
                            reset: function() {
                                t = !1, n = null, a.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    o = new function() {
                        var t = !1,
                            n = null,
                            r = null,
                            i = null;
                        return {
                            setTest: function(e) {
                                e ? F(2929) : B(2929)
                            },
                            setMask: function(e) {
                                n === e || t || (u.depthMask(e), n = e)
                            },
                            setFunc: function(e) {
                                if (r !== e) {
                                    if (e) switch (e) {
                                        case be:
                                            u.depthFunc(512);
                                            break;
                                        case _e:
                                            u.depthFunc(519);
                                            break;
                                        case we:
                                            u.depthFunc(513);
                                            break;
                                        case Se:
                                            u.depthFunc(515);
                                            break;
                                        case Te:
                                            u.depthFunc(514);
                                            break;
                                        case Ee:
                                            u.depthFunc(518);
                                            break;
                                        case Ce:
                                            u.depthFunc(516);
                                            break;
                                        case Le:
                                            u.depthFunc(517);
                                            break;
                                        default:
                                            u.depthFunc(515)
                                    } else u.depthFunc(515);
                                    r = e
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(e) {
                                i !== e && (u.clearDepth(e), i = e)
                            },
                            reset: function() {
                                t = !1, i = r = n = null
                            }
                        }
                    },
                    a = new function() {
                        var t = !1,
                            n = null,
                            r = null,
                            i = null,
                            o = null,
                            a = null,
                            s = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function(e) {
                                t || (e ? F(2960) : B(2960))
                            },
                            setMask: function(e) {
                                n === e || t || (u.stencilMask(e), n = e)
                            },
                            setFunc: function(e, t, n) {
                                r === e && i === t && o === n || (u.stencilFunc(e, t, n), r = e, i = t, o = n)
                            },
                            setOp: function(e, t, n) {
                                a === e && s === t && l === n || (u.stencilOp(e, t, n), a = e, s = t, l = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(e) {
                                c !== e && (u.clearStencil(e), c = e)
                            },
                            reset: function() {
                                t = !1, c = l = s = a = o = i = r = n = null
                            }
                        }
                    },
                    t = u.getParameter(34921),
                    s = new Uint8Array(t),
                    l = new Uint8Array(t),
                    c = new Uint8Array(t),
                    h = {},
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    v = null,
                    g = null,
                    y = null,
                    x = null,
                    b = null,
                    _ = !1,
                    w = null,
                    S = null,
                    M = null,
                    T = null,
                    E = null,
                    C = u.getParameter(35661),
                    L = !1,
                    A = 0,
                    R = u.getParameter(7938); - 1 !== R.indexOf("WebGL") ? (A = parseFloat(/^WebGL\ ([0-9])/.exec(R)[1]), L = 1 <= A) : -1 !== R.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(R)[1]), L = 2 <= A);
                var P = null,
                    O = {},
                    I = new Bt,
                    D = new Bt;

                function N(e, t, n) {
                    var r = new Uint8Array(4),
                        i = u.createTexture();
                    u.bindTexture(e, i), u.texParameteri(e, 10241, 9728), u.texParameteri(e, 10240, 9728);
                    for (var o = 0; o < n; o++) u.texImage2D(t + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return i
                }
                var k = {};

                function z(e, t) {
                    s[e] = 1, 0 === l[e] && (u.enableVertexAttribArray(e), l[e] = 1), c[e] !== t && ((r ? u : n.get("ANGLE_instanced_arrays"))[r ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t), c[e] = t)
                }

                function F(e) {
                    !0 !== h[e] && (u.enable(e), h[e] = !0)
                }

                function B(e) {
                    !1 !== h[e] && (u.disable(e), h[e] = !1)
                }
                k[3553] = N(3553, 3553, 1), k[34067] = N(34067, 34069, 6), i.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), F(2929), o.setFunc(Se), W(!1), j(Z), F(2884), V(Q);
                var U = {};
                if (U[ie] = 32774, U[oe] = 32778, U[ae] = 32779, r) U[se] = 32775, U[le] = 32776;
                else {
                    var H = n.get("EXT_blend_minmax");
                    null !== H && (U[se] = H.MIN_EXT, U[le] = H.MAX_EXT)
                }
                var G = {};

                function V(e, t, n, r, i, o, a, s) {
                    if (e !== Q) {
                        if (p || (F(3042), p = !0), e === re) i = i || t, o = o || n, a = a || r, t === m && i === y || (u.blendEquationSeparate(U[t], U[i]), m = t, y = i), n === v && r === g && o === x && a === b || (u.blendFuncSeparate(G[n], G[r], G[o], G[a]), v = n, g = r, x = o, b = a), f = e, _ = null;
                        else if (e !== f || s !== _) {
                            if (m === ie && y === ie || (u.blendEquation(32774), y = m = ie), s) switch (e) {
                                case $:
                                    u.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case ee:
                                    u.blendFunc(1, 1);
                                    break;
                                case te:
                                    u.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case ne:
                                    u.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            } else switch (e) {
                                case $:
                                    u.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case ee:
                                    u.blendFunc(770, 1);
                                    break;
                                case te:
                                    u.blendFunc(0, 769);
                                    break;
                                case ne:
                                    u.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                            b = x = g = v = null, f = e, _ = s
                        }
                    } else p && (B(3042), p = !1)
                }

                function W(e) {
                    w !== e && (e ? u.frontFace(2304) : u.frontFace(2305), w = e)
                }

                function j(e) {
                    e !== Y ? (F(2884), e !== S && (e === Z ? u.cullFace(1029) : e === K ? u.cullFace(1028) : u.cullFace(1032))) : B(2884), S = e
                }

                function q(e, t, n) {
                    e ? (F(32823), T === t && E === n || (u.polygonOffset(t, n), T = t, E = n)) : B(32823)
                }

                function X(e) {
                    void 0 === e && (e = 33984 + C - 1), P !== e && (u.activeTexture(e), P = e)
                }
                return G[ce] = 0, G[ue] = 1, G[he] = 768, G[pe] = 770, G[xe] = 776, G[ge] = 774, G[me] = 772, G[de] = 769, G[fe] = 771, G[ye] = 775, G[ve] = 773, {
                    buffers: {
                        color: i,
                        depth: o,
                        stencil: a
                    },
                    initAttributes: function() {
                        for (var e = 0, t = s.length; e < t; e++) s[e] = 0
                    },
                    enableAttribute: function(e) {
                        z(e, 0)
                    },
                    enableAttributeAndDivisor: z,
                    disableUnusedAttributes: function() {
                        for (var e = 0, t = l.length; e !== t; ++e) l[e] !== s[e] && (u.disableVertexAttribArray(e), l[e] = 0)
                    },
                    enable: F,
                    disable: B,
                    useProgram: function(e) {
                        return d !== e && (u.useProgram(e), d = e, !0)
                    },
                    setBlending: V,
                    setMaterial: function(e, t) {
                        e.side === J ? B(2884) : F(2884);
                        var n = e.side === Me;
                        t && (n = !n), W(n), e.blending === $ && !1 === e.transparent ? V(Q) : V(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), o.setFunc(e.depthFunc), o.setTest(e.depthTest), o.setMask(e.depthWrite), i.setMask(e.colorWrite);
                        var r = e.stencilWrite;
                        a.setTest(r), r && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                    },
                    setFlipSided: W,
                    setCullFace: j,
                    setLineWidth: function(e) {
                        e !== M && (L && u.lineWidth(e), M = e)
                    },
                    setPolygonOffset: q,
                    setScissorTest: function(e) {
                        e ? F(3089) : B(3089)
                    },
                    activeTexture: X,
                    bindTexture: function(e, t) {
                        null === P && X();
                        var n = O[P];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        }, O[P] = n), n.type === e && n.texture === t || (u.bindTexture(e, t || k[e]), n.type = e, n.texture = t)
                    },
                    unbindTexture: function() {
                        var e = O[P];
                        void 0 !== e && void 0 !== e.type && (u.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            u.compressedTexImage2D.apply(u, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            u.texImage2D.apply(u, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            u.texImage3D.apply(u, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(e) {
                        !1 === I.equals(e) && (u.scissor(e.x, e.y, e.z, e.w), I.copy(e))
                    },
                    viewport: function(e) {
                        !1 === D.equals(e) && (u.viewport(e.x, e.y, e.z, e.w), D.copy(e))
                    },
                    reset: function() {
                        for (var e = 0; e < l.length; e++) 1 === l[e] && (u.disableVertexAttribArray(e), l[e] = 0);
                        h = {}, O = {}, S = w = f = d = P = null, i.reset(), o.reset(), a.reset()
                    }
                }
            }

            function ga(x, b, _, w, i, S, M) {
                var c, T = i.isWebGL2,
                    t = i.maxTextures,
                    v = i.maxCubemapSize,
                    f = i.maxTextureSize,
                    n = i.maxSamples,
                    o = new WeakMap,
                    r = !1;
                try {
                    r = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}

                function u(e, t) {
                    return r ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function g(e, t, n, r) {
                    var i = 1;
                    if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            var o = t ? Ct.floorPowerOfTwo : Math.floor,
                                a = o(i * e.width),
                                s = o(i * e.height);
                            void 0 === c && (c = u(a, s));
                            var l = n ? u(a, s) : c;
                            return l.width = a, l.height = s, l.getContext("2d").drawImage(e, 0, 0, a, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + s + ")."), l
                        }
                        return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                    }
                    return e
                }

                function E(e) {
                    return Ct.isPowerOfTwo(e.width) && Ct.isPowerOfTwo(e.height)
                }

                function C(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== Fe && e.minFilter !== He
                }

                function L(e, t, n, r) {
                    x.generateMipmap(e), w.get(t).__maxMipLevel = Math.log(Math.max(n, r)) * Math.LOG2E
                }

                function A(e, t, n) {
                    if (!1 === T) return t;
                    if (null !== e) {
                        if (void 0 !== x[e]) return x[e];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'")
                    }
                    var r = t;
                    return 6403 === t && (5126 === n && (r = 33326), 5131 === n && (r = 33325), 5121 === n && (r = 33321)), 6407 === t && (5126 === n && (r = 34837), 5131 === n && (r = 34843), 5121 === n && (r = 32849)), 6408 === t && (5126 === n && (r = 34836), 5131 === n && (r = 34842), 5121 === n && (r = 32856)), 33325 === r || 33326 === r || 34842 === r || 34836 === r ? b.get("EXT_color_buffer_float") : 34843 !== r && 34837 !== r || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), r
                }

                function a(e) {
                    return e === Fe || e === Be || e === Ue ? 9728 : 9729
                }

                function s(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", s),
                        function(e) {
                            var t = w.get(e);
                            if (void 0 === t.__webglInit) return;
                            x.deleteTexture(t.__webglTexture), w.remove(e)
                        }(t), t.isVideoTexture && o.delete(t), M.memory.textures--
                }

                function R(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", R),
                        function(e) {
                            var t = w.get(e),
                                n = w.get(e.texture);
                            if (!e) return;
                            void 0 !== n.__webglTexture && x.deleteTexture(n.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLRenderTargetCube)
                                for (var r = 0; r < 6; r++) x.deleteFramebuffer(t.__webglFramebuffer[r]), t.__webglDepthbuffer && x.deleteRenderbuffer(t.__webglDepthbuffer[r]);
                            else x.deleteFramebuffer(t.__webglFramebuffer), t.__webglDepthbuffer && x.deleteRenderbuffer(t.__webglDepthbuffer);
                            if (e.isWebGLMultiviewRenderTarget) {
                                x.deleteTexture(t.__webglColorTexture), x.deleteTexture(t.__webglDepthStencilTexture), M.memory.textures -= 2;
                                r = 0;
                                for (var i = t.__webglViewFramebuffers.length; r < i; r++) x.deleteFramebuffer(t.__webglViewFramebuffers[r])
                            }
                            w.remove(e.texture), w.remove(e)
                        }(t), M.memory.textures--
                }
                var l = 0;

                function h(e, t) {
                    var n = w.get(e);
                    if (e.isVideoTexture && function(e) {
                            var t = M.render.frame;
                            o.get(e) !== t && (o.set(e, t), e.update())
                        }(e), 0 < e.version && n.__version !== e.version) {
                        var r = e.image;
                        if (void 0 === r) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== r.complete) return void I(n, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    _.activeTexture(33984 + t), _.bindTexture(3553, n.__webglTexture)
                }

                function d(e, t) {
                    if (6 === e.image.length) {
                        var n = w.get(e);
                        if (0 < e.version && n.__version !== e.version) {
                            O(n, e), _.activeTexture(33984 + t), _.bindTexture(34067, n.__webglTexture), x.pixelStorei(37440, e.flipY);
                            for (var r = e && e.isCompressedTexture, i = e.image[0] && e.image[0].isDataTexture, o = [], a = 0; a < 6; a++) o[a] = r || i ? i ? e.image[a].image : e.image[a] : g(e.image[a], !1, !0, v);
                            var s, l = o[0],
                                c = E(l) || T,
                                u = S.convert(e.format),
                                h = S.convert(e.type),
                                d = A(e.internalFormat, u, h);
                            if (P(34067, e, c), r) {
                                for (a = 0; a < 6; a++) {
                                    s = o[a].mipmaps;
                                    for (var p = 0; p < s.length; p++) {
                                        var f = s[p];
                                        e.format !== Je && e.format !== Ke ? null !== u ? _.compressedTexImage2D(34069 + a, p, d, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : _.texImage2D(34069 + a, p, d, f.width, f.height, 0, u, h, f.data)
                                    }
                                }
                                n.__maxMipLevel = s.length - 1
                            } else {
                                s = e.mipmaps;
                                for (a = 0; a < 6; a++)
                                    if (i) {
                                        _.texImage2D(34069 + a, 0, d, o[a].width, o[a].height, 0, u, h, o[a].data);
                                        for (p = 0; p < s.length; p++) {
                                            var m = (f = s[p]).image[a].image;
                                            _.texImage2D(34069 + a, p + 1, d, m.width, m.height, 0, u, h, m.data)
                                        }
                                    } else {
                                        _.texImage2D(34069 + a, 0, d, u, h, o[a]);
                                        for (p = 0; p < s.length; p++) {
                                            f = s[p];
                                            _.texImage2D(34069 + a, p + 1, d, u, h, f.image[a])
                                        }
                                    }
                                n.__maxMipLevel = s.length
                            }
                            C(e, c) && L(34067, e, l.width, l.height), n.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else _.activeTexture(33984 + t), _.bindTexture(34067, n.__webglTexture)
                    }
                }

                function p(e, t) {
                    _.activeTexture(33984 + t), _.bindTexture(34067, w.get(e).__webglTexture)
                }
                var m = {};
                m[Ne] = 10497, m[ke] = 33071, m[ze] = 33648;
                var y = {};

                function P(e, t, n) {
                    n ? (x.texParameteri(e, 10242, m[t.wrapS]), x.texParameteri(e, 10243, m[t.wrapT]), 32879 !== e && 35866 !== e || x.texParameteri(e, 32882, m[t.wrapR]), x.texParameteri(e, 10240, y[t.magFilter]), x.texParameteri(e, 10241, y[t.minFilter])) : (x.texParameteri(e, 10242, 33071), x.texParameteri(e, 10243, 33071), 32879 !== e && 35866 !== e || x.texParameteri(e, 32882, 33071), t.wrapS === ke && t.wrapT === ke || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), x.texParameteri(e, 10240, a(t.magFilter)), x.texParameteri(e, 10241, a(t.minFilter)), t.minFilter !== Fe && t.minFilter !== He && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
                    var r = b.get("EXT_texture_filter_anisotropic");
                    if (r) {
                        if (t.type === Xe && null === b.get("OES_texture_float_linear")) return;
                        if (t.type === Ye && null === (T || b.get("OES_texture_half_float_linear"))) return;
                        (1 < t.anisotropy || w.get(t).__currentAnisotropy) && (x.texParameterf(e, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, i.getMaxAnisotropy())), w.get(t).__currentAnisotropy = t.anisotropy)
                    }
                }

                function O(e, t) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", s), e.__webglTexture = x.createTexture(), M.memory.textures++)
                }

                function I(e, t, n) {
                    var r = 3553;
                    t.isDataTexture2DArray && (r = 35866), t.isDataTexture3D && (r = 32879), O(e, t), _.activeTexture(33984 + n), _.bindTexture(r, e.__webglTexture), x.pixelStorei(37440, t.flipY), x.pixelStorei(37441, t.premultiplyAlpha), x.pixelStorei(3317, t.unpackAlignment);
                    var i = function(e) {
                            return !T && (e.wrapS !== ke || e.wrapT !== ke || e.minFilter !== Fe && e.minFilter !== He)
                        }(t) && !1 === E(t.image),
                        o = g(t.image, i, !1, f),
                        a = E(o) || T,
                        s = S.convert(t.format),
                        l = S.convert(t.type),
                        c = A(t.internalFormat, s, l);
                    P(r, t, a);
                    var u, h = t.mipmaps;
                    if (t.isDepthTexture) {
                        if (c = 6402, t.type === Xe) {
                            if (!1 === T) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            c = 36012
                        } else T && (c = 33189);
                        t.format === Qe && 6402 === c && t.type !== je && t.type !== qe && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), t.type = je, l = S.convert(t.type)), t.format === $e && (c = 34041, t.type !== Ze && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), t.type = Ze, l = S.convert(t.type))), _.texImage2D(3553, 0, c, o.width, o.height, 0, s, l, null)
                    } else if (t.isDataTexture)
                        if (0 < h.length && a) {
                            for (var d = 0, p = h.length; d < p; d++) u = h[d], _.texImage2D(3553, d, c, u.width, u.height, 0, s, l, u.data);
                            t.generateMipmaps = !1, e.__maxMipLevel = h.length - 1
                        } else _.texImage2D(3553, 0, c, o.width, o.height, 0, s, l, o.data), e.__maxMipLevel = 0;
                    else if (t.isCompressedTexture) {
                        for (d = 0, p = h.length; d < p; d++) u = h[d], t.format !== Je && t.format !== Ke ? null !== s ? _.compressedTexImage2D(3553, d, c, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _.texImage2D(3553, d, c, u.width, u.height, 0, s, l, u.data);
                        e.__maxMipLevel = h.length - 1
                    } else if (t.isDataTexture2DArray) _.texImage3D(35866, 0, c, o.width, o.height, o.depth, 0, s, l, o.data), e.__maxMipLevel = 0;
                    else if (t.isDataTexture3D) _.texImage3D(32879, 0, c, o.width, o.height, o.depth, 0, s, l, o.data), e.__maxMipLevel = 0;
                    else if (0 < h.length && a) {
                        for (d = 0, p = h.length; d < p; d++) u = h[d], _.texImage2D(3553, d, c, s, l, u);
                        t.generateMipmaps = !1, e.__maxMipLevel = h.length - 1
                    } else _.texImage2D(3553, 0, c, s, l, o), e.__maxMipLevel = 0;
                    C(t, a) && L(r, t, o.width, o.height), e.__version = t.version, t.onUpdate && t.onUpdate(t)
                }

                function D(e, t, n, r) {
                    var i = S.convert(t.texture.format),
                        o = S.convert(t.texture.type),
                        a = A(t.texture.internalFormat, i, o);
                    _.texImage2D(r, 0, a, t.width, t.height, 0, i, o, null), x.bindFramebuffer(36160, e), x.framebufferTexture2D(36160, n, r, w.get(t.texture).__webglTexture, 0), x.bindFramebuffer(36160, null)
                }

                function N(e, t, n) {
                    if (x.bindRenderbuffer(36161, e), t.depthBuffer && !t.stencilBuffer) {
                        if (n) {
                            var r = z(t);
                            x.renderbufferStorageMultisample(36161, r, 33189, t.width, t.height)
                        } else x.renderbufferStorage(36161, 33189, t.width, t.height);
                        x.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (t.depthBuffer && t.stencilBuffer) {
                        if (n) {
                            r = z(t);
                            x.renderbufferStorageMultisample(36161, r, 35056, t.width, t.height)
                        } else x.renderbufferStorage(36161, 34041, t.width, t.height);
                        x.framebufferRenderbuffer(36160, 33306, 36161, e)
                    } else {
                        var i = S.convert(t.texture.format),
                            o = S.convert(t.texture.type),
                            a = A(t.texture.internalFormat, i, o);
                        if (n) {
                            r = z(t);
                            x.renderbufferStorageMultisample(36161, r, a, t.width, t.height)
                        } else x.renderbufferStorage(36161, a, t.width, t.height)
                    }
                    x.bindRenderbuffer(36161, null)
                }

                function k(e) {
                    var t = w.get(e),
                        n = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (n) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, t) {
                            if (t && t.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (x.bindFramebuffer(36160, e), !t.depthTexture || !t.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            w.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), h(t.depthTexture, 0);
                            var n = w.get(t.depthTexture).__webglTexture;
                            if (t.depthTexture.format === Qe) x.framebufferTexture2D(36160, 36096, 3553, n, 0);
                            else {
                                if (t.depthTexture.format !== $e) throw new Error("Unknown depthTexture format");
                                x.framebufferTexture2D(36160, 33306, 3553, n, 0)
                            }
                        }(t.__webglFramebuffer, e)
                    } else if (n) {
                        t.__webglDepthbuffer = [];
                        for (var r = 0; r < 6; r++) x.bindFramebuffer(36160, t.__webglFramebuffer[r]), t.__webglDepthbuffer[r] = x.createRenderbuffer(), N(t.__webglDepthbuffer[r], e)
                    } else x.bindFramebuffer(36160, t.__webglFramebuffer), t.__webglDepthbuffer = x.createRenderbuffer(), N(t.__webglDepthbuffer, e);
                    x.bindFramebuffer(36160, null)
                }

                function z(e) {
                    return T && e.isWebGLMultisampleRenderTarget ? Math.min(n, e.samples) : 0
                }
                y[Fe] = 9728, y[Be] = 9984, y[Ue] = 9986, y[He] = 9729, y[Ge] = 9985;
                var F = !(y[Ve] = 9987),
                    B = !1;
                this.allocateTextureUnit = function() {
                    var e = l;
                    return t <= e && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + t), l += 1, e
                }, this.resetTextureUnits = function() {
                    l = 0
                }, this.setTexture2D = h, this.setTexture2DArray = function(e, t) {
                    var n = w.get(e);
                    0 < e.version && n.__version !== e.version ? I(n, e, t) : (_.activeTexture(33984 + t), _.bindTexture(35866, n.__webglTexture))
                }, this.setTexture3D = function(e, t) {
                    var n = w.get(e);
                    0 < e.version && n.__version !== e.version ? I(n, e, t) : (_.activeTexture(33984 + t), _.bindTexture(32879, n.__webglTexture))
                }, this.setTextureCube = d, this.setTextureCubeDynamic = p, this.setupRenderTarget = function(e) {
                    var t = w.get(e),
                        n = w.get(e.texture);
                    e.addEventListener("dispose", R), n.__webglTexture = x.createTexture(), M.memory.textures++;
                    var r = !0 === e.isWebGLRenderTargetCube,
                        i = !0 === e.isWebGLMultisampleRenderTarget,
                        o = !0 === e.isWebGLMultiviewRenderTarget,
                        a = E(e) || T;
                    if (r) {
                        t.__webglFramebuffer = [];
                        for (var s = 0; s < 6; s++) t.__webglFramebuffer[s] = x.createFramebuffer()
                    } else if (t.__webglFramebuffer = x.createFramebuffer(), i)
                        if (T) {
                            t.__webglMultisampledFramebuffer = x.createFramebuffer(), t.__webglColorRenderbuffer = x.createRenderbuffer(), x.bindRenderbuffer(36161, t.__webglColorRenderbuffer);
                            var l = S.convert(e.texture.format),
                                c = S.convert(e.texture.type),
                                u = A(e.texture.internalFormat, l, c),
                                h = z(e);
                            x.renderbufferStorageMultisample(36161, h, u, e.width, e.height), x.bindFramebuffer(36160, t.__webglMultisampledFramebuffer), x.framebufferRenderbuffer(36160, 36064, 36161, t.__webglColorRenderbuffer), x.bindRenderbuffer(36161, null), e.depthBuffer && (t.__webglDepthRenderbuffer = x.createRenderbuffer(), N(t.__webglDepthRenderbuffer, e, !0)), x.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    else if (o) {
                        var d = e.width,
                            p = e.height,
                            f = e.numViews;
                        x.bindFramebuffer(36160, t.__webglFramebuffer);
                        var m = b.get("OVR_multiview2");
                        M.memory.textures += 2;
                        var v = x.createTexture();
                        x.bindTexture(35866, v), x.texParameteri(35866, 10240, 9728), x.texParameteri(35866, 10241, 9728), x.texImage3D(35866, 0, 32856, d, p, f, 0, 6408, 5121, null), m.framebufferTextureMultiviewOVR(36160, 36064, v, 0, 0, f);
                        var g = x.createTexture();
                        x.bindTexture(35866, g), x.texParameteri(35866, 10240, 9728), x.texParameteri(35866, 10241, 9728), x.texImage3D(35866, 0, 35056, d, p, f, 0, 34041, 34042, null), m.framebufferTextureMultiviewOVR(36160, 33306, g, 0, 0, f);
                        var y = new Array(f);
                        for (s = 0; s < f; ++s) y[s] = x.createFramebuffer(), x.bindFramebuffer(36160, y[s]), x.framebufferTextureLayer(36160, 36064, v, 0, s);
                        t.__webglColorTexture = v, t.__webglDepthStencilTexture = g, t.__webglViewFramebuffers = y, x.bindFramebuffer(36160, null), x.bindTexture(35866, null)
                    }
                    if (r) {
                        _.bindTexture(34067, n.__webglTexture), P(34067, e.texture, a);
                        for (s = 0; s < 6; s++) D(t.__webglFramebuffer[s], e, 36064, 34069 + s);
                        C(e.texture, a) && L(34067, e.texture, e.width, e.height), _.bindTexture(34067, null)
                    } else o || (_.bindTexture(3553, n.__webglTexture), P(3553, e.texture, a), D(t.__webglFramebuffer, e, 36064, 3553), C(e.texture, a) && L(3553, e.texture, e.width, e.height), _.bindTexture(3553, null));
                    e.depthBuffer && k(e)
                }, this.updateRenderTargetMipmap = function(e) {
                    var t = e.texture;
                    if (C(t, E(e) || T)) {
                        var n = e.isWebGLRenderTargetCube ? 34067 : 3553,
                            r = w.get(t).__webglTexture;
                        _.bindTexture(n, r), L(n, t, e.width, e.height), _.bindTexture(n, null)
                    }
                }, this.updateMultisampleRenderTarget = function(e) {
                    if (e.isWebGLMultisampleRenderTarget)
                        if (T) {
                            var t = w.get(e);
                            x.bindFramebuffer(36008, t.__webglMultisampledFramebuffer), x.bindFramebuffer(36009, t.__webglFramebuffer);
                            var n = e.width,
                                r = e.height,
                                i = 16384;
                            e.depthBuffer && (i |= 256), e.stencilBuffer && (i |= 1024), x.blitFramebuffer(0, 0, n, r, 0, 0, n, r, i, 9728)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }, this.safeSetTexture2D = function(e, t) {
                    e && e.isWebGLRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F = !0), e = e.texture), h(e, t)
                }, this.safeSetTextureCube = function(e, t) {
                    e && e.isWebGLRenderTargetCube && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? d(e, t) : p(e, t)
                }
            }

            function ya(e, n, t) {
                var r = t.isWebGL2;
                return {
                    convert: function(e) {
                        var t;
                        if (e === We) return 5121;
                        if (e === l) return 32819;
                        if (e === c) return 32820;
                        if (e === u) return 33635;
                        if (e === i) return 5120;
                        if (e === o) return 5122;
                        if (e === je) return 5123;
                        if (e === s) return 5124;
                        if (e === qe) return 5125;
                        if (e === Xe) return 5126;
                        if (e === Ye) return r ? 5131 : null !== (t = n.get("OES_texture_half_float")) ? t.HALF_FLOAT_OES : null;
                        if (e === h) return 6406;
                        if (e === Ke) return 6407;
                        if (e === Je) return 6408;
                        if (e === d) return 6409;
                        if (e === p) return 6410;
                        if (e === Qe) return 6402;
                        if (e === $e) return 34041;
                        if (e === f) return 6403;
                        if (e === m) return 36244;
                        if (e === v) return 33319;
                        if (e === y) return 33320;
                        if (e === x) return 36248;
                        if (e === b) return 36249;
                        if (e === _ || e === w || e === S || e === M) {
                            if (null === (t = n.get("WEBGL_compressed_texture_s3tc"))) return null;
                            if (e === _) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (e === w) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (e === S) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (e === M) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (e === T || e === E || e === C || e === L) {
                            if (null === (t = n.get("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (e === T) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (e === E) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (e === C) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (e === L) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        return e === A ? null !== (t = n.get("WEBGL_compressed_texture_etc1")) ? t.COMPRESSED_RGB_ETC1_WEBGL : null : e === R || e === O || e === I || e === D || e === et || e === tt || e === nt || e === rt || e === it || e === ot || e === at || e === st || e === lt || e === ct ? null !== (t = n.get("WEBGL_compressed_texture_astc")) ? e : null : e === Ze ? r ? 34042 : null !== (t = n.get("WEBGL_depth_texture")) ? t.UNSIGNED_INT_24_8_WEBGL : null : void 0
                    }
                }
            }

            function xa(e, t, n, r) {
                Ut.call(this, e, t, r), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = n
            }

            function ba(n, d) {
                var p, r, o, a, i, f, s, l = 2,
                    c = n.extensions,
                    m = n.properties,
                    u = 0;

                function h(e) {
                    return e.isArrayCamera ? e.cameras : (i[0] = e, i)
                }
                this.isAvailable = function() {
                    if (void 0 === s) {
                        var e = c.get("OVR_multiview2");
                        if (s = null !== e && !1 === d.getContextAttributes().antialias) {
                            u = d.getParameter(e.MAX_VIEWS_OVR), p = new xa(0, 0, l), f = new Lt, a = [], o = [], i = [];
                            for (var t = 0; t < u; t++) a[t] = new Zt, o[t] = new Nt
                        }
                    }
                    return s
                }, this.attachCamera = function(e) {
                    !1 !== function(e) {
                        if (void 0 === e.isArrayCamera) return !0;
                        var t = e.cameras;
                        if (t.length > u) return !1;
                        for (var n = 1, r = t.length; n < r; n++)
                            if (t[0].viewport.z !== t[n].viewport.z || t[0].viewport.w !== t[n].viewport.w) return !1;
                        return !0
                    }(e) && (r = n.getRenderTarget(), function(e) {
                        if (r ? f.set(r.width, r.height) : n.getDrawingBufferSize(f), e.isArrayCamera) {
                            var t = e.cameras[0].viewport;
                            p.setSize(t.z, t.w), p.setNumViews(e.cameras.length)
                        } else p.setSize(f.x, f.y), p.setNumViews(l)
                    }(e), n.setRenderTarget(p))
                }, this.detachCamera = function(e) {
                    p === n.getRenderTarget() && (n.setRenderTarget(r), function(e) {
                        var t = p,
                            n = t.numViews,
                            r = m.get(t).__webglViewFramebuffers,
                            i = t.width,
                            o = t.height;
                        if (e.isArrayCamera)
                            for (var a = 0; a < n; a++) {
                                var s = e.cameras[a].viewport,
                                    l = s.x,
                                    c = s.y,
                                    u = l + s.z,
                                    h = c + s.w;
                                d.bindFramebuffer(36008, r[a]), d.blitFramebuffer(0, 0, i, o, l, c, u, h, 16384, 9728)
                            } else d.bindFramebuffer(36008, r[0]), d.blitFramebuffer(0, 0, i, o, 0, 0, f.x, f.y, 16384, 9728)
                    }(e))
                }, this.updateCameraProjectionMatricesUniform = function(e, t) {
                    for (var n = h(e), r = 0; r < n.length; r++) a[r].copy(n[r].projectionMatrix);
                    t.setValue(d, "projectionMatrices", a)
                }, this.updateCameraViewMatricesUniform = function(e, t) {
                    for (var n = h(e), r = 0; r < n.length; r++) a[r].copy(n[r].matrixWorldInverse);
                    t.setValue(d, "viewMatrices", a)
                }, this.updateObjectMatricesUniforms = function(e, t, n) {
                    for (var r = h(t), i = 0; i < r.length; i++) a[i].multiplyMatrices(r[i].matrixWorldInverse, e.matrixWorld), o[i].getNormalMatrix(a[i]);
                    n.setValue(d, "modelViewMatrices", a), n.setValue(d, "normalMatrices", o)
                }
            }

            function _a(e) {
                fi.call(this), this.cameras = e || []
            }

            function wa() {
                fn.call(this), this.type = "Group"
            }

            function Sa(p, i) {
                var t = this,
                    f = null,
                    m = null,
                    o = "local-floor",
                    v = null,
                    g = [],
                    a = new Map,
                    s = new fi;
                s.layers.enable(1), s.viewport = new Bt;
                var l = new fi;
                l.layers.enable(2), l.viewport = new Bt;
                var y = new _a([s, l]);

                function c(e) {
                    var t = a.get(e.inputSource);
                    t && t.dispatchEvent({
                        type: e.type
                    })
                }

                function u() {
                    a.forEach(function(e, t) {
                        e.dispatchEvent({
                            type: "disconnected",
                            data: t
                        }), e.visible = !1
                    }), a.clear(), p.setFramebuffer(null), p.setRenderTarget(p.getRenderTarget()), n.stop(), t.dispatchEvent({
                        type: "sessionend"
                    }), t.isPresenting = !1
                }

                function h(e) {
                    m = e, n.setContext(f), n.start(), t.dispatchEvent({
                        type: "sessionstart"
                    }), t.isPresenting = !0
                }

                function d(e) {
                    for (var t = f.inputSources, n = 0; n < g.length; n++) a.set(t[n], g[n]);
                    for (n = 0; n < e.removed.length; n++) {
                        var r = e.removed[n];
                        (i = a.get(r)) && (i.dispatchEvent({
                            type: "disconnected",
                            data: r
                        }), a.delete(r))
                    }
                    for (n = 0; n < e.added.length; n++) {
                        var i;
                        r = e.added[n];
                        (i = a.get(r)) && i.dispatchEvent({
                            type: "connected",
                            data: r
                        })
                    }
                }
                y.layers.enable(1), y.layers.enable(2), this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                    var t = g[e];
                    return void 0 === t && ((t = new wa).matrixAutoUpdate = !1, t.visible = !1, g[e] = t), t
                }, this.setFramebufferScaleFactor = function() {}, this.setReferenceSpaceType = function(e) {
                    o = e
                }, this.getReferenceSpace = function() {
                    return m
                }, this.getSession = function() {
                    return f
                }, this.setSession = function(e) {
                    if (null !== (f = e)) {
                        f.addEventListener("select", c), f.addEventListener("selectstart", c), f.addEventListener("selectend", c), f.addEventListener("squeeze", c), f.addEventListener("squeezestart", c), f.addEventListener("squeezeend", c), f.addEventListener("end", u);
                        var t = i.getContextAttributes(),
                            n = {
                                antialias: t.antialias,
                                alpha: t.alpha,
                                depth: t.depth,
                                stencil: t.stencil
                            },
                            r = new XRWebGLLayer(f, i, n);
                        f.updateRenderState({
                            baseLayer: r
                        }), f.requestReferenceSpace(o).then(h), f.addEventListener("inputsourceschange", d)
                    }
                };
                var w = new Ot,
                    S = new Ot;

                function x(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
                }
                this.getCamera = function(e) {
                    var t = e.parent,
                        n = y.cameras;
                    x(y, t);
                    for (var r = 0; r < n.length; r++) x(n[r], t);
                    e.matrixWorld.copy(y.matrixWorld);
                    for (var i = e.children, o = (r = 0, i.length); r < o; r++) i[r].updateMatrixWorld(!0);
                    return function(e, t, n) {
                        w.setFromMatrixPosition(t.matrixWorld), S.setFromMatrixPosition(n.matrixWorld);
                        var r = w.distanceTo(S),
                            i = t.projectionMatrix.elements,
                            o = n.projectionMatrix.elements,
                            a = i[14] / (i[10] - 1),
                            s = i[14] / (i[10] + 1),
                            l = (i[9] + 1) / i[5],
                            c = (i[9] - 1) / i[5],
                            u = (i[8] - 1) / i[0],
                            h = (o[8] + 1) / o[0],
                            d = a * u,
                            p = a * h,
                            f = r / (h - u),
                            m = f * -u;
                        t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld);
                        var v = a + f,
                            g = s + f,
                            y = d - m,
                            x = r - m + p,
                            b = l * s / g * v,
                            _ = c * s / g * v;
                        e.projectionMatrix.makePerspective(y, x, b, _, v, g)
                    }(y, s, l), y
                };
                var b = null;
                var n = new Mi;
                n.setAnimationLoop(function(e, t) {
                    if (null !== (v = t.getViewerPose(m))) {
                        var n = v.views,
                            r = f.renderState.baseLayer;
                        p.setFramebuffer(r.framebuffer);
                        for (var i = 0; i < n.length; i++) {
                            var o = n[i],
                                a = r.getViewport(o),
                                s = o.transform.inverse.matrix,
                                l = y.cameras[i];
                            l.matrix.fromArray(s).getInverse(l.matrix), l.projectionMatrix.fromArray(o.projectionMatrix), l.viewport.set(a.x, a.y, a.width, a.height), 0 === i && y.matrix.copy(l.matrix)
                        }
                    }
                    var c = f.inputSources;
                    for (i = 0; i < g.length; i++) {
                        var u = g[i],
                            h = c[i];
                        if (h) {
                            var d = t.getPose(h.targetRaySpace, m);
                            if (null !== d) {
                                u.matrix.fromArray(d.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.visible = !0;
                                continue
                            }
                        }
                        u.visible = !1
                    }
                    b && b(e, t)
                }), this.setAnimationLoop = function(e) {
                    b = e
                }, this.dispose = function() {}
            }

            function Ma(e) {
                var r = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    t = void 0 !== e.context ? e.context : null,
                    n = void 0 !== e.alpha && e.alpha,
                    i = void 0 === e.depth || e.depth,
                    o = void 0 === e.stencil || e.stencil,
                    a = void 0 !== e.antialias && e.antialias,
                    s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    c = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
                    f = null,
                    _ = null;
                this.domElement = r, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = ut, this.physicallyCorrectLights = !1, this.toneMapping = Ae, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var S, M, T, E, m, w, C, L, A, v, g, h, d, p, R, P, O, y, I = this,
                    x = !1,
                    b = null,
                    D = 0,
                    N = 0,
                    k = null,
                    z = null,
                    F = -1,
                    B = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    U = null,
                    H = null,
                    G = new Bt,
                    V = new Bt,
                    W = null,
                    j = r.width,
                    q = r.height,
                    X = 1,
                    Y = null,
                    Z = null,
                    K = new Bt(0, 0, j, q),
                    J = new Bt(0, 0, j, q),
                    Q = !1,
                    $ = new bi,
                    ee = new Pi,
                    te = !1,
                    ne = !1,
                    re = new Zt,
                    ie = new Ot;

                function oe() {
                    return null === k ? X : 1
                }
                try {
                    var ae = {
                        alpha: n,
                        depth: i,
                        stencil: o,
                        antialias: a,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u,
                        xrCompatible: !0
                    };
                    if (r.addEventListener("webglcontextlost", he, !1), r.addEventListener("webglcontextrestored", de, !1), null === (S = t || r.getContext("webgl", ae) || r.getContext("experimental-webgl", ae))) throw null !== r.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === S.getShaderPrecisionFormat && (S.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message), e
                }

                function se() {
                    M = new Oi(S), !1 === (T = new Ri(S, M, e)).isWebGL2 && (M.get("WEBGL_depth_texture"), M.get("OES_texture_float"), M.get("OES_texture_half_float"), M.get("OES_texture_half_float_linear"), M.get("OES_standard_derivatives"), M.get("OES_element_index_uint"), M.get("ANGLE_instanced_arrays")), M.get("OES_texture_float_linear"), y = new ya(S, M, T), (E = new va(S, M, T)).scissor(V.copy(J).multiplyScalar(X).floor()), E.viewport(G.copy(K).multiplyScalar(X).floor()), m = new Ni(S), w = new ea, C = new ga(S, M, E, w, T, y, m), L = new Ti(S), A = new Ii(S, L, m), v = new Fi(S, A, L, m), R = new zi(S), g = new $o(I, M, T), h = new ia, d = new ua, p = new Li(I, E, v, s), P = new Ai(S, M, m, T), O = new Di(S, M, m, T), m.programs = g.programs, I.capabilities = T, I.extensions = M, I.properties = w, I.renderLists = h, I.state = E, I.info = m
                }
                se();
                var le = new Sa(I, S);
                this.xr = le;
                var ce = new ba(I, S),
                    ue = new ma(I, v, T.maxTextureSize);

                function he(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
                }

                function de() {
                    console.log("THREE.WebGLRenderer: Context Restored."), x = !1, se()
                }

                function pe(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", pe),
                        function(e) {
                            fe(e), w.remove(e)
                        }(t)
                }

                function fe(e) {
                    var t = w.get(e).program;
                    (e.program = void 0) !== t && g.releaseProgram(t)
                }
                this.shadowMap = ue, this.getContext = function() {
                    return S
                }, this.getContextAttributes = function() {
                    return S.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var e = M.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    var e = M.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return X
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (X = e, this.setSize(j, q, !1))
                }, this.getSize = function(e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new Lt), e.set(j, q)
                }, this.setSize = function(e, t, n) {
                    le.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (j = e, q = t, r.width = Math.floor(e * X), r.height = Math.floor(t * X), !1 !== n && (r.style.width = e + "px", r.style.height = t + "px"), this.setViewport(0, 0, e, t))
                }, this.getDrawingBufferSize = function(e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new Lt), e.set(j * X, q * X).floor()
                }, this.setDrawingBufferSize = function(e, t, n) {
                    j = e, q = t, X = n, r.width = Math.floor(e * n), r.height = Math.floor(t * n), this.setViewport(0, 0, e, t)
                }, this.getCurrentViewport = function(e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new Bt), e.copy(G)
                }, this.getViewport = function(e) {
                    return e.copy(K)
                }, this.setViewport = function(e, t, n, r) {
                    e.isVector4 ? K.set(e.x, e.y, e.z, e.w) : K.set(e, t, n, r), E.viewport(G.copy(K).multiplyScalar(X).floor())
                }, this.getScissor = function(e) {
                    return e.copy(J)
                }, this.setScissor = function(e, t, n, r) {
                    e.isVector4 ? J.set(e.x, e.y, e.z, e.w) : J.set(e, t, n, r), E.scissor(V.copy(J).multiplyScalar(X).floor())
                }, this.getScissorTest = function() {
                    return Q
                }, this.setScissorTest = function(e) {
                    E.setScissorTest(Q = e)
                }, this.setOpaqueSort = function(e) {
                    Y = e
                }, this.setTransparentSort = function(e) {
                    Z = e
                }, this.getClearColor = function() {
                    return p.getClearColor()
                }, this.setClearColor = function() {
                    p.setClearColor.apply(p, arguments)
                }, this.getClearAlpha = function() {
                    return p.getClearAlpha()
                }, this.setClearAlpha = function() {
                    p.setClearAlpha.apply(p, arguments)
                }, this.clear = function(e, t, n) {
                    var r = 0;
                    void 0 !== e && !e || (r |= 16384), void 0 !== t && !t || (r |= 256), void 0 !== n && !n || (r |= 1024), S.clear(r)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    r.removeEventListener("webglcontextlost", he, !1), r.removeEventListener("webglcontextrestored", de, !1), h.dispose(), d.dispose(), w.dispose(), v.dispose(), le.dispose(), ge.stop()
                }, this.renderBufferImmediate = function(e, t) {
                    E.initAttributes();
                    var n = w.get(e);
                    e.hasPositions && !n.position && (n.position = S.createBuffer()), e.hasNormals && !n.normal && (n.normal = S.createBuffer()), e.hasUvs && !n.uv && (n.uv = S.createBuffer()), e.hasColors && !n.color && (n.color = S.createBuffer());
                    var r = t.getAttributes();
                    e.hasPositions && (S.bindBuffer(34962, n.position), S.bufferData(34962, e.positionArray, 35048), E.enableAttribute(r.position), S.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), e.hasNormals && (S.bindBuffer(34962, n.normal), S.bufferData(34962, e.normalArray, 35048), E.enableAttribute(r.normal), S.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (S.bindBuffer(34962, n.uv), S.bufferData(34962, e.uvArray, 35048), E.enableAttribute(r.uv), S.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), e.hasColors && (S.bindBuffer(34962, n.color), S.bufferData(34962, e.colorArray, 35048), E.enableAttribute(r.color), S.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), E.disableUnusedAttributes(), S.drawArrays(4, 0, e.count), e.count = 0
                };
                var me = new mn;
                this.renderBufferDirect = function(e, t, n, r, i, o) {
                    null === t && (t = me);
                    var a = i.isMesh && i.matrixWorld.determinant() < 0,
                        s = _e(e, t, r, i);
                    E.setMaterial(r, a);
                    var l = !1;
                    B.geometry === n.id && B.program === s.id && B.wireframe === (!0 === r.wireframe) || (B.geometry = n.id, B.program = s.id, B.wireframe = !0 === r.wireframe, l = !0), (r.morphTargets || r.morphNormals) && (R.update(i, n, r, s), l = !0);
                    var c = n.index,
                        u = n.attributes.position;
                    if (null === c) {
                        if (void 0 === u || 0 === u.count) return
                    } else if (0 === c.count) return;
                    var h, d = 1;
                    !0 === r.wireframe && (c = A.getWireframeAttribute(n), d = 2);
                    var p = P;
                    null !== c && (h = L.get(c), (p = O).setIndex(h)), l && (function(e, t, n, r) {
                        if (!1 === T.isWebGL2 && (e.isInstancedMesh || t.isInstancedBufferGeometry) && null === M.get("ANGLE_instanced_arrays")) return;
                        E.initAttributes();
                        var i = t.attributes,
                            o = r.getAttributes(),
                            a = n.defaultAttributeValues;
                        for (var s in o) {
                            var l = o[s];
                            if (0 <= l) {
                                var c = i[s];
                                if (void 0 !== c) {
                                    var u = c.normalized,
                                        h = c.itemSize;
                                    if (void 0 === (y = L.get(c))) continue;
                                    var d = y.buffer,
                                        p = y.type,
                                        f = y.bytesPerElement;
                                    if (c.isInterleavedBufferAttribute) {
                                        var m = c.data,
                                            v = m.stride,
                                            g = c.offset;
                                        m && m.isInstancedInterleavedBuffer ? (E.enableAttributeAndDivisor(l, m.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = m.meshPerAttribute * m.count)) : E.enableAttribute(l), S.bindBuffer(34962, d), S.vertexAttribPointer(l, h, p, u, v * f, g * f)
                                    } else c.isInstancedBufferAttribute ? (E.enableAttributeAndDivisor(l, c.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = c.meshPerAttribute * c.count)) : E.enableAttribute(l), S.bindBuffer(34962, d), S.vertexAttribPointer(l, h, p, u, 0, 0)
                                } else if ("instanceMatrix" === s) {
                                    var y;
                                    if (void 0 === (y = L.get(e.instanceMatrix))) continue;
                                    d = y.buffer, p = y.type;
                                    E.enableAttributeAndDivisor(l + 0, 1), E.enableAttributeAndDivisor(l + 1, 1), E.enableAttributeAndDivisor(l + 2, 1), E.enableAttributeAndDivisor(l + 3, 1), S.bindBuffer(34962, d), S.vertexAttribPointer(l + 0, 4, p, !1, 64, 0), S.vertexAttribPointer(l + 1, 4, p, !1, 64, 16), S.vertexAttribPointer(l + 2, 4, p, !1, 64, 32), S.vertexAttribPointer(l + 3, 4, p, !1, 64, 48)
                                } else if (void 0 !== a) {
                                    var x = a[s];
                                    if (void 0 !== x) switch (x.length) {
                                        case 2:
                                            S.vertexAttrib2fv(l, x);
                                            break;
                                        case 3:
                                            S.vertexAttrib3fv(l, x);
                                            break;
                                        case 4:
                                            S.vertexAttrib4fv(l, x);
                                            break;
                                        default:
                                            S.vertexAttrib1fv(l, x)
                                    }
                                }
                            }
                        }
                        E.disableUnusedAttributes()
                    }(i, n, r, s), null !== c && S.bindBuffer(34963, h.buffer));
                    var f = null !== c ? c.count : u.count,
                        m = n.drawRange.start * d,
                        v = n.drawRange.count * d,
                        g = null !== o ? o.start * d : 0,
                        y = null !== o ? o.count * d : 1 / 0,
                        x = Math.max(m, g),
                        b = Math.min(f, m + v, g + y) - 1,
                        _ = Math.max(0, b - x + 1);
                    if (0 !== _) {
                        if (i.isMesh) !0 === r.wireframe ? (E.setLineWidth(r.wireframeLinewidth * oe()), p.setMode(1)) : p.setMode(4);
                        else if (i.isLine) {
                            var w = r.linewidth;
                            void 0 === w && (w = 1), E.setLineWidth(w * oe()), i.isLineSegments ? p.setMode(1) : i.isLineLoop ? p.setMode(2) : p.setMode(3)
                        } else i.isPoints ? p.setMode(0) : i.isSprite && p.setMode(4);
                        i.isInstancedMesh ? p.renderInstances(n, x, _, i.count) : n.isInstancedBufferGeometry ? p.renderInstances(n, x, _, n.maxInstancedCount) : p.render(x, _)
                    }
                }, this.compile = function(n, e) {
                    (_ = d.get(n, e)).init(), n.traverse(function(e) {
                        e.isLight && (_.pushLight(e), e.castShadow && _.pushShadow(e))
                    }), _.setupLights(e), n.traverse(function(e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var t = 0; t < e.material.length; t++) be(e.material[t], n, e);
                            else be(e.material, n, e)
                    })
                };
                var ve = null;
                var ge = new Mi;

                function ye(e, t, n, r) {
                    for (var i = 0, o = e.length; i < o; i++) {
                        var a = e[i],
                            s = a.object,
                            l = a.geometry,
                            c = void 0 === r ? a.material : r,
                            u = a.group;
                        if (n.isArrayCamera)
                            if (H = n, le.enabled && ce.isAvailable()) xe(s, t, n, l, c, u);
                            else
                                for (var h = n.cameras, d = 0, p = h.length; d < p; d++) {
                                    var f = h[d];
                                    s.layers.test(f.layers) && (E.viewport(G.copy(f.viewport)), _.setupLights(f), xe(s, t, f, l, c, u))
                                } else H = null, xe(s, t, n, l, c, u)
                    }
                }

                function xe(e, t, n, r, i, o) {
                    if (e.onBeforeRender(I, t, n, r, i, o), _ = d.get(t, H || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                        var a = _e(n, t, i, e);
                        E.setMaterial(i), B.geometry = null, B.program = null, B.wireframe = !1,
                            function(e, t) {
                                e.render(function(e) {
                                    I.renderBufferImmediate(e, t)
                                })
                            }(e, a)
                    } else I.renderBufferDirect(n, t, r, i, e, o);
                    e.onAfterRender(I, t, n, r, i, o), _ = d.get(t, H || n)
                }

                function be(e, t, n) {
                    var r = w.get(e),
                        i = _.state.lights,
                        o = _.state.shadowsArray,
                        a = i.state.version,
                        s = g.getParameters(e, i.state, o, t, ee.numPlanes, ee.numIntersection, n),
                        l = g.getProgramCacheKey(e, s),
                        c = r.program,
                        u = !0;
                    if (void 0 === c) e.addEventListener("dispose", pe);
                    else if (c.cacheKey !== l) fe(e);
                    else if (r.lightsStateVersion !== a) r.lightsStateVersion = a, u = !1;
                    else {
                        if (void 0 !== s.shaderID) return;
                        u = !1
                    }
                    if (u) {
                        if (s.shaderID) {
                            var h = Si[s.shaderID];
                            r.shader = {
                                name: e.type,
                                uniforms: si(h.uniforms),
                                vertexShader: h.vertexShader,
                                fragmentShader: h.fragmentShader
                            }
                        } else r.shader = {
                            name: e.type,
                            uniforms: e.uniforms,
                            vertexShader: e.vertexShader,
                            fragmentShader: e.fragmentShader
                        };
                        e.onBeforeCompile(r.shader, I), l = g.getProgramCacheKey(e, s), c = g.acquireProgram(e, r.shader, s, l), r.program = c, r.environment = e.isMeshStandardMaterial ? t.environment : null, r.outputEncoding = I.outputEncoding, e.program = c
                    }
                    var d = c.getAttributes();
                    if (e.morphTargets)
                        for (var p = e.numSupportedMorphTargets = 0; p < I.maxMorphTargets; p++) 0 <= d["morphTarget" + p] && e.numSupportedMorphTargets++;
                    if (e.morphNormals)
                        for (p = e.numSupportedMorphNormals = 0; p < I.maxMorphNormals; p++) 0 <= d["morphNormal" + p] && e.numSupportedMorphNormals++;
                    var f = r.shader.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = ee.numPlanes, r.numIntersection = ee.numIntersection, f.clippingPlanes = ee.uniform), r.fog = t.fog, r.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e), r.lightsStateVersion = a, r.needsLights && (f.ambientLightColor.value = i.state.ambient, f.lightProbe.value = i.state.probe, f.directionalLights.value = i.state.directional, f.spotLights.value = i.state.spot, f.rectAreaLights.value = i.state.rectArea, f.pointLights.value = i.state.point, f.hemisphereLights.value = i.state.hemi, f.directionalShadowMap.value = i.state.directionalShadowMap, f.directionalShadowMatrix.value = i.state.directionalShadowMatrix, f.spotShadowMap.value = i.state.spotShadowMap, f.spotShadowMatrix.value = i.state.spotShadowMatrix, f.pointShadowMap.value = i.state.pointShadowMap, f.pointShadowMatrix.value = i.state.pointShadowMatrix);
                    var m = r.program.getUniforms(),
                        v = ko.seqWithValue(m.seq, f);
                    r.uniformsList = v
                }

                function _e(e, t, n, r) {
                    C.resetTextureUnits();
                    var i = t.fog,
                        o = n.isMeshStandardMaterial ? t.environment : null,
                        a = w.get(n),
                        s = _.state.lights;
                    if (te && (ne || e !== U)) {
                        var l = e === U && n.id === F;
                        ee.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, a, l)
                    }
                    n.version === a.__version && (void 0 === a.program ? n.needsUpdate = !0 : n.fog && a.fog !== i ? n.needsUpdate = !0 : a.environment !== o ? n.needsUpdate = !0 : a.needsLights && a.lightsStateVersion !== s.state.version ? n.needsUpdate = !0 : void 0 === a.numClippingPlanes || a.numClippingPlanes === ee.numPlanes && a.numIntersection === ee.numIntersection ? a.outputEncoding !== I.outputEncoding && (n.needsUpdate = !0) : n.needsUpdate = !0), n.version !== a.__version && (be(n, t, r), a.__version = n.version);
                    var c = !1,
                        u = !1,
                        h = !1,
                        d = a.program,
                        p = d.getUniforms(),
                        f = a.shader.uniforms;
                    if (E.useProgram(d.program) && (h = u = c = !0), n.id !== F && (F = n.id, u = !0), c || U !== e) {
                        if (0 < d.numMultiviewViews ? ce.updateCameraProjectionMatricesUniform(e, p) : p.setValue(S, "projectionMatrix", e.projectionMatrix), T.logarithmicDepthBuffer && p.setValue(S, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), U !== e && (U = e, h = u = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var m = p.map.cameraPosition;
                            void 0 !== m && m.setValue(S, ie.setFromMatrixPosition(e.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && p.setValue(S, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && (0 < d.numMultiviewViews ? ce.updateCameraViewMatricesUniform(e, p) : p.setValue(S, "viewMatrix", e.matrixWorldInverse))
                    }
                    if (n.skinning) {
                        p.setOptional(S, r, "bindMatrix"), p.setOptional(S, r, "bindMatrixInverse");
                        var v = r.skeleton;
                        if (v) {
                            var g = v.bones;
                            if (T.floatVertexTextures) {
                                if (void 0 === v.boneTexture) {
                                    var y = Math.sqrt(4 * g.length);
                                    y = Ct.ceilPowerOfTwo(y), y = Math.max(y, 4);
                                    var x = new Float32Array(y * y * 4);
                                    x.set(v.boneMatrices);
                                    var b = new gi(x, y, y, Je, Xe);
                                    v.boneMatrices = x, v.boneTexture = b, v.boneTextureSize = y
                                }
                                p.setValue(S, "boneTexture", v.boneTexture, C), p.setValue(S, "boneTextureSize", v.boneTextureSize)
                            } else p.setOptional(S, v, "boneMatrices")
                        }
                    }
                    return !u && a.receiveShadow === r.receiveShadow || (a.receiveShadow = r.receiveShadow, p.setValue(S, "receiveShadow", r.receiveShadow)), u && (p.setValue(S, "toneMappingExposure", I.toneMappingExposure), p.setValue(S, "toneMappingWhitePoint", I.toneMappingWhitePoint), a.needsLights && function(e, t) {
                        e.ambientLightColor.needsUpdate = t, e.lightProbe.needsUpdate = t, e.directionalLights.needsUpdate = t, e.pointLights.needsUpdate = t, e.spotLights.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
                    }(f, h), i && n.fog && function(e, t) {
                        e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                    }(f, i), n.isMeshBasicMaterial ? we(f, n) : n.isMeshLambertMaterial ? (we(f, n), function(e, t) {
                        t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                    }(f, n)) : n.isMeshToonMaterial ? (we(f, n), function(e, t) {
                        e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.gradientMap && (e.gradientMap.value = t.gradientMap);
                        t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                        t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Me && (e.bumpScale.value *= -1));
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Me && e.normalScale.value.negate());
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                    }(f, n)) : n.isMeshPhongMaterial ? (we(f, n), function(e, t) {
                        e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                        t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Me && (e.bumpScale.value *= -1));
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Me && e.normalScale.value.negate());
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                    }(f, n)) : n.isMeshStandardMaterial ? (we(f, n, o), n.isMeshPhysicalMaterial ? function(e, t, n) {
                        Se(e, t, n), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen);
                        t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === Me && e.clearcoatNormalScale.value.negate());
                        e.transparency.value = t.transparency
                    }(f, n, o) : Se(f, n, o)) : n.isMeshMatcapMaterial ? (we(f, n), function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap);
                        t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Me && (e.bumpScale.value *= -1));
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Me && e.normalScale.value.negate());
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                    }(f, n)) : n.isMeshDepthMaterial ? (we(f, n), function(e, t) {
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                    }(f, n)) : n.isMeshDistanceMaterial ? (we(f, n), function(e, t) {
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                        e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                    }(f, n)) : n.isMeshNormalMaterial ? (we(f, n), function(e, t) {
                        t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Me && (e.bumpScale.value *= -1));
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Me && e.normalScale.value.negate());
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                    }(f, n)) : n.isLineBasicMaterial ? (function(e, t) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                    }(f, n), n.isLineDashedMaterial && function(e, t) {
                        e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                    }(f, n)) : n.isPointsMaterial ? function(e, t) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * X, e.scale.value = .5 * q, t.map && (e.map.value = t.map);
                        t.alphaMap && (e.alphaMap.value = t.alphaMap);
                        var n;
                        t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                    }(f, n) : n.isSpriteMaterial ? function(e, t) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
                        t.alphaMap && (e.alphaMap.value = t.alphaMap);
                        var n;
                        t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                    }(f, n) : n.isShadowMaterial && (f.color.value.copy(n.color), f.opacity.value = n.opacity), void 0 !== f.ltc_1 && (f.ltc_1.value = wi.LTC_1), void 0 !== f.ltc_2 && (f.ltc_2.value = wi.LTC_2), ko.upload(S, a.uniformsList, f, C), n.isShaderMaterial && (n.uniformsNeedUpdate = !1)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ko.upload(S, a.uniformsList, f, C), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && p.setValue(S, "center", r.center), 0 < d.numMultiviewViews ? ce.updateObjectMatricesUniforms(r, e, p) : (p.setValue(S, "modelViewMatrix", r.modelViewMatrix), p.setValue(S, "normalMatrix", r.normalMatrix)), p.setValue(S, "modelMatrix", r.matrixWorld), d
                }

                function we(e, t, n) {
                    e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap);
                    var r, i, o = t.envMap || n;
                    o && (e.envMap.value = o, e.flipEnvMap.value = o.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = w.get(o).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? r = t.map : t.specularMap ? r = t.specularMap : t.displacementMap ? r = t.displacementMap : t.normalMap ? r = t.normalMap : t.bumpMap ? r = t.bumpMap : t.roughnessMap ? r = t.roughnessMap : t.metalnessMap ? r = t.metalnessMap : t.alphaMap ? r = t.alphaMap : t.emissiveMap && (r = t.emissiveMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), t.aoMap ? i = t.aoMap : t.lightMap && (i = t.lightMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uv2Transform.value.copy(i.matrix))
                }

                function Se(e, t, n) {
                    e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Me && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Me && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), (t.envMap || n) && (e.envMapIntensity.value = t.envMapIntensity)
                }
                ge.setAnimationLoop(function(e) {
                    le.isPresenting || ve && ve(e)
                }), "undefined" != typeof window && ge.setContext(window), this.setAnimationLoop = function(e) {
                    ve = e, le.setAnimationLoop(e), ge.start()
                }, this.render = function(e, t) {
                    var n, r;
                    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), t && t.isCamera) {
                        if (!x) {
                            B.geometry = null, B.program = null, B.wireframe = !1, F = -1, !(U = null) === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), le.enabled && le.isPresenting && (t = le.getCamera(t)), (_ = d.get(e, t)).init(), e.onBeforeRender(I, e, t, n || k), re.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), $.setFromMatrix(re), ne = this.localClippingEnabled, te = ee.init(this.clippingPlanes, ne, t), (f = h.get(e, t)).init(),
                                function e(t, n, r, i) {
                                    if (!1 === t.visible) return;
                                    var o = t.layers.test(n.layers);
                                    if (o)
                                        if (t.isGroup) r = t.renderOrder;
                                        else if (t.isLOD) !0 === t.autoUpdate && t.update(n);
                                    else if (t.isLight) _.pushLight(t), t.castShadow && _.pushShadow(t);
                                    else if (t.isSprite) {
                                        if (!t.frustumCulled || $.intersectsSprite(t)) {
                                            i && ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(re);
                                            var a = v.update(t),
                                                s = t.material;
                                            s.visible && f.push(t, a, s, r, ie.z, null)
                                        }
                                    } else if (t.isImmediateRenderObject) i && ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(re), f.push(t, null, t.material, r, ie.z, null);
                                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== m.render.frame && (t.skeleton.update(), t.skeleton.frame = m.render.frame), !t.frustumCulled || $.intersectsObject(t))) {
                                        i && ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(re);
                                        var a = v.update(t),
                                            s = t.material;
                                        if (Array.isArray(s))
                                            for (var l = a.groups, c = 0, u = l.length; c < u; c++) {
                                                var h = l[c],
                                                    d = s[h.materialIndex];
                                                d && d.visible && f.push(t, a, d, r, ie.z, h)
                                            } else s.visible && f.push(t, a, s, r, ie.z, null)
                                    }
                                    var p = t.children;
                                    for (var c = 0, u = p.length; c < u; c++) e(p[c], n, r, i)
                                }(e, t, 0, I.sortObjects), !0 === I.sortObjects && f.sort(Y, Z), te && ee.beginShadows();
                            var i = _.state.shadowsArray;
                            ue.render(i, e, t), _.setupLights(t), te && ee.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), le.enabled && ce.isAvailable() && ce.attachCamera(t), p.render(f, e, t, r);
                            var o = f.opaque,
                                a = f.transparent;
                            if (e.overrideMaterial) {
                                var s = e.overrideMaterial;
                                o.length && ye(o, e, t, s), a.length && ye(a, e, t, s)
                            } else o.length && ye(o, e, t), a.length && ye(a, e, t);
                            e.onAfterRender(I, e, t), null !== k && (C.updateRenderTargetMipmap(k), C.updateMultisampleRenderTarget(k)), E.buffers.depth.setTest(!0), E.buffers.depth.setMask(!0), E.buffers.color.setMask(!0), E.setPolygonOffset(!1), le.enabled && ce.isAvailable() && ce.detachCamera(t), _ = f = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.setFramebuffer = function(e) {
                    b !== e && null === k && S.bindFramebuffer(36160, e), b = e
                }, this.getActiveCubeFace = function() {
                    return D
                }, this.getActiveMipmapLevel = function() {
                    return N
                }, this.getRenderTarget = function() {
                    return k
                }, this.setRenderTarget = function(e, t, n) {
                    D = t, N = n, (k = e) && void 0 === w.get(e).__webglFramebuffer && C.setupRenderTarget(e);
                    var r = b,
                        i = !1;
                    if (e) {
                        var o = w.get(e).__webglFramebuffer;
                        e.isWebGLRenderTargetCube ? (r = o[t || 0], i = !0) : r = e.isWebGLMultisampleRenderTarget ? w.get(e).__webglMultisampledFramebuffer : o, G.copy(e.viewport), V.copy(e.scissor), W = e.scissorTest
                    } else G.copy(K).multiplyScalar(X).floor(), V.copy(J).multiplyScalar(X).floor(), W = Q;
                    if (z !== r && (S.bindFramebuffer(36160, r), z = r), E.viewport(G), E.scissor(V), E.setScissorTest(W), i) {
                        var a = w.get(e.texture);
                        S.framebufferTexture2D(36160, 36064, 34069 + (t || 0), a.__webglTexture, n || 0)
                    }
                }, this.readRenderTargetPixels = function(e, t, n, r, i, o, a) {
                    if (e && e.isWebGLRenderTarget) {
                        var s = w.get(e).__webglFramebuffer;
                        if (e.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s) {
                            var l = !1;
                            s !== z && (S.bindFramebuffer(36160, s), l = !0);
                            try {
                                var c = e.texture,
                                    u = c.format,
                                    h = c.type;
                                if (u !== Je && y.convert(u) !== S.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(h === We || y.convert(h) === S.getParameter(35738) || h === Xe && (T.isWebGL2 || M.get("OES_texture_float") || M.get("WEBGL_color_buffer_float")) || h === Ye && (T.isWebGL2 ? M.get("EXT_color_buffer_float") : M.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === S.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - r && 0 <= n && n <= e.height - i && S.readPixels(t, n, r, i, y.convert(u), y.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                l && S.bindFramebuffer(36160, z)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function(e, t, n) {
                    void 0 === n && (n = 0);
                    var r = Math.pow(2, -n),
                        i = Math.floor(t.image.width * r),
                        o = Math.floor(t.image.height * r),
                        a = y.convert(t.format);
                    C.setTexture2D(t, 0), S.copyTexImage2D(3553, n, a, e.x, e.y, i, o, 0), E.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, n, r) {
                    var i = t.image.width,
                        o = t.image.height,
                        a = y.convert(n.format),
                        s = y.convert(n.type);
                    C.setTexture2D(n, 0), t.isDataTexture ? S.texSubImage2D(3553, r || 0, e.x, e.y, i, o, a, s, t.image.data) : S.texSubImage2D(3553, r || 0, e.x, e.y, a, s, t.image), E.unbindTexture()
                }, this.initTexture = function(e) {
                    C.setTexture2D(e, 0), E.unbindTexture()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function Ta(e, t) {
                this.name = "", this.color = new or(e), this.density = void 0 !== t ? t : 25e-5
            }

            function Ea(e, t, n) {
                this.name = "", this.color = new or(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
            }

            function Ca(e, t) {
                this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = wt, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }
            xa.prototype = Object.assign(Object.create(Ut.prototype), {
                constructor: xa,
                isWebGLMultiviewRenderTarget: !0,
                copy: function(e) {
                    return Ut.prototype.copy.call(this, e), this.numViews = e.numViews, this
                },
                setNumViews: function(e) {
                    return this.numViews !== e && (this.numViews = e, this.dispose()), this
                }
            }), _a.prototype = Object.assign(Object.create(fi.prototype), {
                constructor: _a,
                isArrayCamera: !0
            }), wa.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: wa,
                isGroup: !0
            }), Object.assign(Sa.prototype, Mt.prototype), Object.assign(Ta.prototype, {
                isFogExp2: !0,
                clone: function() {
                    return new Ta(this.color, this.density)
                },
                toJSON: function() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }), Object.assign(Ea.prototype, {
                isFog: !0,
                clone: function() {
                    return new Ea(this.color, this.near, this.far)
                },
                toJSON: function() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }), Object.defineProperty(Ca.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            }), Object.assign(Ca.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setUsage: function(e) {
                    return this.usage = e, this
                },
                copy: function(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                },
                copyAt: function(e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                },
                set: function(e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(e) {
                    return this.onUploadCallback = e, this
                }
            });
            var La, Aa = new Ot;

            function Ra(e, t, n, r) {
                this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
            }

            function Pa(e) {
                hr.call(this), this.type = "SpriteMaterial", this.color = new or(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
            }
            Object.defineProperties(Ra.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(Ra.prototype, {
                isInterleavedBufferAttribute: !0,
                applyMatrix4: function(e) {
                    for (var t = 0, n = this.data.count; t < n; t++) Aa.x = this.getX(t), Aa.y = this.getY(t), Aa.z = this.getZ(t), Aa.applyMatrix4(e), this.setXYZ(t, Aa.x, Aa.y, Aa.z);
                    return this
                },
                setX: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                },
                setY: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                },
                setZ: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                },
                setW: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                },
                getX: function(e) {
                    return this.data.array[e * this.data.stride + this.offset]
                },
                getY: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                },
                getZ: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                },
                getW: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                },
                setXY: function(e, t, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                },
                setXYZ: function(e, t, n, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
                },
                setXYZW: function(e, t, n, r, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
                }
            }), ((Pa.prototype = Object.create(hr.prototype)).constructor = Pa).prototype.isSpriteMaterial = !0, Pa.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
            };
            var Oa = new Ot,
                Ia = new Ot,
                Da = new Ot,
                Na = new Lt,
                ka = new Lt,
                za = new Zt,
                Fa = new Ot,
                Ba = new Ot,
                Ua = new Ot,
                Ha = new Lt,
                Ga = new Lt,
                Va = new Lt;

            function Wa(e) {
                if (fn.call(this), this.type = "Sprite", void 0 === La) {
                    La = new Ir;
                    var t = new Ca(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    La.setIndex([0, 1, 2, 0, 2, 3]), La.setAttribute("position", new Ra(t, 3, 0, !1)), La.setAttribute("uv", new Ra(t, 2, 3, !1))
                }
                this.geometry = La, this.material = void 0 !== e ? e : new Pa, this.center = new Lt(.5, .5)
            }

            function ja(e, t, n, r, i, o) {
                Na.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (ka.x = o * Na.x - i * Na.y, ka.y = i * Na.x + o * Na.y) : ka.copy(Na), e.copy(t), e.x += ka.x, e.y += ka.y, e.applyMatrix4(za)
            }
            Wa.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: Wa,
                isSprite: !0,
                raycast: function(e, t) {
                    null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ia.setFromMatrixScale(this.matrixWorld), za.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Da.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ia.multiplyScalar(-Da.z);
                    var n, r, i = this.material.rotation;
                    0 !== i && (r = Math.cos(i), n = Math.sin(i));
                    var o = this.center;
                    ja(Fa.set(-.5, -.5, 0), Da, o, Ia, n, r), ja(Ba.set(.5, -.5, 0), Da, o, Ia, n, r), ja(Ua.set(.5, .5, 0), Da, o, Ia, n, r), Ha.set(0, 0), Ga.set(1, 0), Va.set(1, 1);
                    var a = e.ray.intersectTriangle(Fa, Ba, Ua, !1, Oa);
                    if (null !== a || (ja(Ba.set(-.5, .5, 0), Da, o, Ia, n, r), Ga.set(0, 1), null !== (a = e.ray.intersectTriangle(Fa, Ua, Ba, !1, Oa)))) {
                        var s = e.ray.origin.distanceTo(Oa);
                        s < e.near || s > e.far || t.push({
                            distance: s,
                            point: Oa.clone(),
                            uv: tr.getUV(Oa, Fa, Ba, Ua, Ha, Ga, Va, new Lt),
                            face: null,
                            object: this
                        })
                    }
                },
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function(e) {
                    return fn.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
                }
            });
            var qa = new Ot,
                Xa = new Ot;

            function Ya() {
                fn.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                }), this.autoUpdate = !0
            }

            function Za(e, t) {
                e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Jr.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Zt, this.bindMatrixInverse = new Zt
            }
            Ya.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: Ya,
                isLOD: !0,
                copy: function(e) {
                    fn.prototype.copy.call(this, e, !1);
                    for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        this.addLevel(i.object.clone(), i.distance)
                    }
                    return this.autoUpdate = e.autoUpdate, this
                },
                addLevel: function(e, t) {
                    void 0 === t && (t = 0), t = Math.abs(t);
                    for (var n = this.levels, r = 0; r < n.length && !(t < n[r].distance); r++);
                    return n.splice(r, 0, {
                        distance: t,
                        object: e
                    }), this.add(e), this
                },
                getObjectForDistance: function(e) {
                    var t = this.levels;
                    if (0 < t.length) {
                        for (var n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
                        return t[n - 1].object
                    }
                    return null
                },
                raycast: function(e, t) {
                    if (0 < this.levels.length) {
                        qa.setFromMatrixPosition(this.matrixWorld);
                        var n = e.ray.origin.distanceTo(qa);
                        this.getObjectForDistance(n).raycast(e, t)
                    }
                },
                update: function(e) {
                    var t = this.levels;
                    if (1 < t.length) {
                        qa.setFromMatrixPosition(e.matrixWorld), Xa.setFromMatrixPosition(this.matrixWorld);
                        var n = qa.distanceTo(Xa);
                        t[0].object.visible = !0;
                        for (var r = 1, i = t.length; r < i && n >= t[r].distance; r++) t[r - 1].object.visible = !1, t[r].object.visible = !0;
                        for (; r < i; r++) t[r].object.visible = !1
                    }
                },
                toJSON: function(e) {
                    var t = fn.prototype.toJSON.call(this, e);
                    !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
                    for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                        var o = n[r];
                        t.object.levels.push({
                            object: o.object.uuid,
                            distance: o.distance
                        })
                    }
                    return t
                }
            }), Za.prototype = Object.assign(Object.create(Jr.prototype), {
                constructor: Za,
                isSkinnedMesh: !0,
                bind: function(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    for (var e = new Bt, t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) {
                        e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                        var i = 1 / e.manhattanLength();
                        i != 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                },
                updateMatrixWorld: function(e) {
                    Jr.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });
            var Ka = new Zt,
                Ja = new Zt;

            function Qa(e, t) {
                if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new Zt)
                }
            }

            function $a() {
                fn.call(this), this.type = "Bone"
            }
            Object.assign(Qa.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var e = 0, t = this.bones.length; e < t; e++) {
                        var n = new Zt;
                        this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function() {
                    var e, t, n;
                    for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
                    for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                },
                update: function() {
                    for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, o = e.length; i < o; i++) {
                        var a = e[i] ? e[i].matrixWorld : Ja;
                        Ka.multiplyMatrices(a, t[i]), Ka.toArray(n, 16 * i)
                    }
                    void 0 !== r && (r.needsUpdate = !0)
                },
                clone: function() {
                    return new Qa(this.bones, this.boneInverses)
                },
                getBoneByName: function(e) {
                    for (var t = 0, n = this.bones.length; t < n; t++) {
                        var r = this.bones[t];
                        if (r.name === e) return r
                    }
                }
            }), $a.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: $a,
                isBone: !0
            });
            var es = new Zt,
                ts = new Zt,
                ns = [],
                rs = new Jr;

            function is(e, t, n) {
                Jr.call(this, e, t), this.instanceMatrix = new fr(new Float32Array(16 * n), 16), this.count = n
            }

            function os(e) {
                hr.call(this), this.type = "LineBasicMaterial", this.color = new or(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
            }
            is.prototype = Object.assign(Object.create(Jr.prototype), {
                constructor: is,
                isInstancedMesh: !0,
                getMatrixAt: function(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                },
                raycast: function(e, t) {
                    var n = this.matrixWorld,
                        r = this.count;
                    if (rs.geometry = this.geometry, rs.material = this.material, void 0 !== rs.material)
                        for (var i = 0; i < r; i++) this.getMatrixAt(i, es), ts.multiplyMatrices(n, es), rs.matrixWorld = ts, rs.raycast(e, ns), 0 < ns.length && (ns[0].instanceId = i, ns[0].object = this, t.push(ns[0]), ns.length = 0)
                },
                setMatrixAt: function(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                },
                updateMorphTargets: function() {}
            }), ((os.prototype = Object.create(hr.prototype)).constructor = os).prototype.isLineBasicMaterial = !0, os.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
            };
            var as = new Ot,
                ss = new Ot,
                ls = new Zt,
                cs = new Un,
                us = new On;

            function hs(e, t, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), fn.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Ir, this.material = void 0 !== t ? t : new os({
                    color: 16777215 * Math.random()
                })
            }
            hs.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: hs,
                isLine: !0,
                computeLineDistances: function() {
                    var e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) as.fromBufferAttribute(t, r - 1), ss.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += as.distanceTo(ss);
                            e.setAttribute("lineDistance", new wr(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry) {
                        var o = e.vertices;
                        (n = e.lineDistances)[0] = 0;
                        for (r = 1, i = o.length; r < i; r++) n[r] = n[r - 1], n[r] += o[r - 1].distanceTo(o[r])
                    }
                    return this
                },
                raycast: function(e, t) {
                    var n = e.linePrecision,
                        r = this.geometry,
                        i = this.matrixWorld;
                    if (null === r.boundingSphere && r.computeBoundingSphere(), us.copy(r.boundingSphere), us.applyMatrix4(i), us.radius += n, !1 !== e.ray.intersectsSphere(us)) {
                        ls.getInverse(i), cs.copy(e.ray).applyMatrix4(ls);
                        var o = n / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o,
                            s = new Ot,
                            l = new Ot,
                            c = new Ot,
                            u = new Ot,
                            h = this && this.isLineSegments ? 2 : 1;
                        if (r.isBufferGeometry) {
                            var d = r.index,
                                p = r.attributes.position.array;
                            if (null !== d)
                                for (var f = d.array, m = 0, v = f.length - 1; m < v; m += h) {
                                    var g = f[m],
                                        y = f[m + 1];
                                    if (s.fromArray(p, 3 * g), l.fromArray(p, 3 * y), !(a < cs.distanceSqToSegment(s, l, u, c))) u.applyMatrix4(this.matrixWorld), (_ = e.ray.origin.distanceTo(u)) < e.near || _ > e.far || t.push({
                                        distance: _,
                                        point: c.clone().applyMatrix4(this.matrixWorld),
                                        index: m,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                } else
                                    for (m = 0, v = p.length / 3 - 1; m < v; m += h) {
                                        if (s.fromArray(p, 3 * m), l.fromArray(p, 3 * m + 3), !(a < cs.distanceSqToSegment(s, l, u, c))) u.applyMatrix4(this.matrixWorld), (_ = e.ray.origin.distanceTo(u)) < e.near || _ > e.far || t.push({
                                            distance: _,
                                            point: c.clone().applyMatrix4(this.matrixWorld),
                                            index: m,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                        } else if (r.isGeometry) {
                            var x = r.vertices,
                                b = x.length;
                            for (m = 0; m < b - 1; m += h) {
                                var _;
                                if (!(a < cs.distanceSqToSegment(x[m], x[m + 1], u, c))) u.applyMatrix4(this.matrixWorld), (_ = e.ray.origin.distanceTo(u)) < e.near || _ > e.far || t.push({
                                    distance: _,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    }
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });
            var ds = new Ot,
                ps = new Ot;

            function fs(e, t) {
                hs.call(this, e, t), this.type = "LineSegments"
            }

            function ms(e, t) {
                hs.call(this, e, t), this.type = "LineLoop"
            }

            function vs(e) {
                hr.call(this), this.type = "PointsMaterial", this.color = new or(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e)
            }
            fs.prototype = Object.assign(Object.create(hs.prototype), {
                constructor: fs,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) ds.fromBufferAttribute(t, r), ps.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + ds.distanceTo(ps);
                            e.setAttribute("lineDistance", new wr(n, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry) {
                        var o = e.vertices;
                        for (n = e.lineDistances, r = 0, i = o.length; r < i; r += 2) ds.copy(o[r]), ps.copy(o[r + 1]), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + ds.distanceTo(ps)
                    }
                    return this
                }
            }), ms.prototype = Object.assign(Object.create(hs.prototype), {
                constructor: ms,
                isLineLoop: !0
            }), ((vs.prototype = Object.create(hr.prototype)).constructor = vs).prototype.isPointsMaterial = !0, vs.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
            };
            var gs = new Zt,
                ys = new Un,
                xs = new On,
                bs = new Ot;

            function _s(e, t) {
                fn.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Ir, this.material = void 0 !== t ? t : new vs({
                    color: 16777215 * Math.random()
                }), this.updateMorphTargets()
            }

            function ws(e, t, n, r, i, o, a) {
                var s = ys.distanceSqToPoint(e);
                if (s < n) {
                    var l = new Ot;
                    ys.closestPointToPoint(e, l), l.applyMatrix4(r);
                    var c = i.ray.origin.distanceTo(l);
                    if (c < i.near || c > i.far) return;
                    o.push({
                        distance: c,
                        distanceToRay: Math.sqrt(s),
                        point: l,
                        index: t,
                        face: null,
                        object: a
                    })
                }
            }

            function Ss(e, t, n, r, i, o, a, s, l) {
                Ft.call(this, e, t, n, r, i, o, a, s, l), this.format = void 0 !== a ? a : Ke, this.minFilter = void 0 !== o ? o : He, this.magFilter = void 0 !== i ? i : He, this.generateMipmaps = !1
            }

            function Ms(e, t, n, r, i, o, a, s, l, c, u, h) {
                Ft.call(this, null, o, a, s, l, c, r, i, u, h), this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }

            function Ts(e, t, n, r, i, o, a, s, l) {
                Ft.call(this, e, t, n, r, i, o, a, s, l), this.needsUpdate = !0
            }

            function Es(e, t, n, r, i, o, a, s, l, c) {
                if ((c = void 0 !== c ? c : Qe) !== Qe && c !== $e) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === Qe && (n = je), void 0 === n && c === $e && (n = Ze), Ft.call(this, null, r, i, o, a, s, c, n, l), this.image = {
                    width: e,
                    height: t
                }, this.magFilter = void 0 !== a ? a : Fe, this.minFilter = void 0 !== s ? s : Fe, this.flipY = !1, this.generateMipmaps = !1
            }

            function Cs(e) {
                Ir.call(this), this.type = "WireframeGeometry";
                var t, n, r, i, o, a, s, l, c, u, h = [],
                    d = [0, 0],
                    p = {},
                    f = ["a", "b", "c"];
                if (e && e.isGeometry) {
                    var m = e.faces;
                    for (t = 0, r = m.length; t < r; t++) {
                        var v = m[t];
                        for (n = 0; n < 3; n++) s = v[f[n]], l = v[f[(n + 1) % 3]], d[0] = Math.min(s, l), d[1] = Math.max(s, l), void 0 === p[c = d[0] + "," + d[1]] && (p[c] = {
                            index1: d[0],
                            index2: d[1]
                        })
                    }
                    for (c in p) a = p[c], u = e.vertices[a.index1], h.push(u.x, u.y, u.z), u = e.vertices[a.index2], h.push(u.x, u.y, u.z)
                } else if (e && e.isBufferGeometry) {
                    var g, y, x, b, _, w;
                    if (u = new Ot, null !== e.index) {
                        for (g = e.attributes.position, y = e.index, 0 === (x = e.groups).length && (x = [{
                                start: 0,
                                count: y.count,
                                materialIndex: 0
                            }]), i = 0, o = x.length; i < o; ++i)
                            for (r = (t = (b = x[i]).start) + b.count; t < r; t += 3)
                                for (n = 0; n < 3; n++) s = y.getX(t + n), l = y.getX(t + (n + 1) % 3), d[0] = Math.min(s, l), d[1] = Math.max(s, l), void 0 === p[c = d[0] + "," + d[1]] && (p[c] = {
                                    index1: d[0],
                                    index2: d[1]
                                });
                        for (c in p) a = p[c], u.fromBufferAttribute(g, a.index1), h.push(u.x, u.y, u.z), u.fromBufferAttribute(g, a.index2), h.push(u.x, u.y, u.z)
                    } else
                        for (t = 0, r = (g = e.attributes.position).count / 3; t < r; t++)
                            for (n = 0; n < 3; n++) _ = 3 * t + n, u.fromBufferAttribute(g, _), h.push(u.x, u.y, u.z), w = 3 * t + (n + 1) % 3, u.fromBufferAttribute(g, w), h.push(u.x, u.y, u.z)
                }
                this.setAttribute("position", new wr(h, 3))
            }

            function Ls(e, t, n) {
                ii.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                }, this.fromBufferGeometry(new As(e, t, n)), this.mergeVertices()
            }

            function As(e, t, n) {
                Ir.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                };
                var r, i, o = [],
                    a = [],
                    s = [],
                    l = [],
                    c = new Ot,
                    u = new Ot,
                    h = new Ot,
                    d = new Ot,
                    p = new Ot;
                e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var f = t + 1;
                for (r = 0; r <= n; r++) {
                    var m = r / n;
                    for (i = 0; i <= t; i++) {
                        var v = i / t;
                        e(v, m, u), a.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (e(v - 1e-5, m, h), d.subVectors(u, h)) : (e(1e-5 + v, m, h), d.subVectors(h, u)), 0 <= m - 1e-5 ? (e(v, m - 1e-5, h), p.subVectors(u, h)) : (e(v, 1e-5 + m, h), p.subVectors(h, u)), c.crossVectors(d, p).normalize(), s.push(c.x, c.y, c.z), l.push(v, m)
                    }
                }
                for (r = 0; r < n; r++)
                    for (i = 0; i < t; i++) {
                        var g = r * f + i,
                            y = r * f + i + 1,
                            x = (r + 1) * f + i + 1,
                            b = (r + 1) * f + i;
                        o.push(g, y, b), o.push(y, x, b)
                    }
                this.setIndex(o), this.setAttribute("position", new wr(a, 3)), this.setAttribute("normal", new wr(s, 3)), this.setAttribute("uv", new wr(l, 2))
            }

            function Rs(e, t, n, r) {
                ii.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: r
                }, this.fromBufferGeometry(new Ps(e, t, n, r)), this.mergeVertices()
            }

            function Ps(r, o, e, t) {
                Ir.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: r,
                    indices: o,
                    radius: e,
                    detail: t
                }, e = e || 1;
                var u = [],
                    h = [];

                function a(e, t, n, r) {
                    var i, o, a = Math.pow(2, r),
                        s = [];
                    for (i = 0; i <= a; i++) {
                        s[i] = [];
                        var l = e.clone().lerp(n, i / a),
                            c = t.clone().lerp(n, i / a),
                            u = a - i;
                        for (o = 0; o <= u; o++) s[i][o] = 0 === o && i === a ? l : l.clone().lerp(c, o / u)
                    }
                    for (i = 0; i < a; i++)
                        for (o = 0; o < 2 * (a - i) - 1; o++) {
                            var h = Math.floor(o / 2);
                            o % 2 == 0 ? (d(s[i][h + 1]), d(s[i + 1][h]), d(s[i][h])) : (d(s[i][h + 1]), d(s[i + 1][h + 1]), d(s[i + 1][h]))
                        }
                }

                function d(e) {
                    u.push(e.x, e.y, e.z)
                }

                function s(e, t) {
                    var n = 3 * e;
                    t.x = r[0 + n], t.y = r[1 + n], t.z = r[2 + n]
                }

                function p(e, t, n, r) {
                    r < 0 && 1 === e.x && (h[t] = e.x - 1), 0 === n.x && 0 === n.z && (h[t] = r / 2 / Math.PI + .5)
                }

                function f(e) {
                    return Math.atan2(e.z, -e.x)
                }! function(e) {
                    for (var t = new Ot, n = new Ot, r = new Ot, i = 0; i < o.length; i += 3) s(o[i + 0], t), s(o[i + 1], n), s(o[i + 2], r), a(t, n, r, e)
                }(t = t || 0),
                function(e) {
                    for (var t = new Ot, n = 0; n < u.length; n += 3) t.x = u[n + 0], t.y = u[n + 1], t.z = u[n + 2], t.normalize().multiplyScalar(e), u[n + 0] = t.x, u[n + 1] = t.y, u[n + 2] = t.z
                }(e),
                function() {
                    for (var e = new Ot, t = 0; t < u.length; t += 3) {
                        e.x = u[t + 0], e.y = u[t + 1], e.z = u[t + 2];
                        var n = f(e) / 2 / Math.PI + .5,
                            r = (i = e, Math.atan2(-i.y, Math.sqrt(i.x * i.x + i.z * i.z)) / Math.PI + .5);
                        h.push(n, 1 - r)
                    }
                    var i;
                    (function() {
                        for (var e = new Ot, t = new Ot, n = new Ot, r = new Ot, i = new Lt, o = new Lt, a = new Lt, s = 0, l = 0; s < u.length; s += 9, l += 6) {
                            e.set(u[s + 0], u[s + 1], u[s + 2]), t.set(u[s + 3], u[s + 4], u[s + 5]), n.set(u[s + 6], u[s + 7], u[s + 8]), i.set(h[l + 0], h[l + 1]), o.set(h[l + 2], h[l + 3]), a.set(h[l + 4], h[l + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                            var c = f(r);
                            p(i, l + 0, e, c), p(o, l + 2, t, c), p(a, l + 4, n, c)
                        }
                    })(),
                    function() {
                        for (var e = 0; e < h.length; e += 6) {
                            var t = h[e + 0],
                                n = h[e + 2],
                                r = h[e + 4],
                                i = Math.max(t, n, r),
                                o = Math.min(t, n, r);.9 < i && o < .1 && (t < .2 && (h[e + 0] += 1), n < .2 && (h[e + 2] += 1), r < .2 && (h[e + 4] += 1))
                        }
                    }()
                }(), this.setAttribute("position", new wr(u, 3)), this.setAttribute("normal", new wr(u.slice(), 3)), this.setAttribute("uv", new wr(h, 2)), 0 === t ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function Os(e, t) {
                ii.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new Is(e, t)), this.mergeVertices()
            }

            function Is(e, t) {
                Ps.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function Ds(e, t) {
                ii.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new Ns(e, t)), this.mergeVertices()
            }

            function Ns(e, t) {
                Ps.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function ks(e, t) {
                ii.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new zs(e, t)), this.mergeVertices()
            }

            function zs(e, t) {
                var n = (1 + Math.sqrt(5)) / 2;
                Ps.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function Fs(e, t) {
                ii.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new Bs(e, t)), this.mergeVertices()
            }

            function Bs(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n;
                Ps.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function Us(e, t, n, r, i, o) {
                ii.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: r,
                    closed: i
                }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                var a = new Hs(e, t, n, r, i);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Hs(a, s, l, c, e) {
                Ir.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: a,
                    tubularSegments: s,
                    radius: l,
                    radialSegments: c,
                    closed: e
                }, s = s || 64, l = l || 1, c = c || 8, e = e || !1;
                var u = a.computeFrenetFrames(s, e);
                this.tangents = u.tangents, this.normals = u.normals, this.binormals = u.binormals;
                var i, h, d = new Ot,
                    p = new Ot,
                    t = new Lt,
                    f = new Ot,
                    m = [],
                    v = [],
                    n = [],
                    o = [];

                function r(e) {
                    f = a.getPointAt(e / s, f);
                    var t = u.normals[e],
                        n = u.binormals[e];
                    for (h = 0; h <= c; h++) {
                        var r = h / c * Math.PI * 2,
                            i = Math.sin(r),
                            o = -Math.cos(r);
                        p.x = o * t.x + i * n.x, p.y = o * t.y + i * n.y, p.z = o * t.z + i * n.z, p.normalize(), v.push(p.x, p.y, p.z), d.x = f.x + l * p.x, d.y = f.y + l * p.y, d.z = f.z + l * p.z, m.push(d.x, d.y, d.z)
                    }
                }! function() {
                    for (i = 0; i < s; i++) r(i);
                    r(!1 === e ? s : 0),
                        function() {
                            for (i = 0; i <= s; i++)
                                for (h = 0; h <= c; h++) t.x = i / s, t.y = h / c, n.push(t.x, t.y)
                        }(),
                        function() {
                            for (h = 1; h <= s; h++)
                                for (i = 1; i <= c; i++) {
                                    var e = (c + 1) * (h - 1) + (i - 1),
                                        t = (c + 1) * h + (i - 1),
                                        n = (c + 1) * h + i,
                                        r = (c + 1) * (h - 1) + i;
                                    o.push(e, t, r), o.push(t, n, r)
                                }
                        }()
                }(), this.setIndex(o), this.setAttribute("position", new wr(m, 3)), this.setAttribute("normal", new wr(v, 3)), this.setAttribute("uv", new wr(n, 2))
            }

            function Gs(e, t, n, r, i, o, a) {
                ii.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: o
                }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Vs(e, t, n, r, i, o)), this.mergeVertices()
            }

            function Vs(e, t, n, r, i, o) {
                Ir.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: o
                }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, o = o || 3;
                var a, s, l = [],
                    c = [],
                    u = [],
                    h = [],
                    d = new Ot,
                    p = new Ot,
                    f = new Ot,
                    m = new Ot,
                    v = new Ot,
                    g = new Ot,
                    y = new Ot;
                for (a = 0; a <= n; ++a) {
                    var x = a / n * i * Math.PI * 2;
                    for (C(x, i, o, e, f), C(.01 + x, i, o, e, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= r; ++s) {
                        var b = s / r * Math.PI * 2,
                            _ = -t * Math.cos(b),
                            w = t * Math.sin(b);
                        d.x = f.x + (_ * y.x + w * v.x), d.y = f.y + (_ * y.y + w * v.y), d.z = f.z + (_ * y.z + w * v.z), c.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), u.push(p.x, p.y, p.z), h.push(a / n), h.push(s / r)
                    }
                }
                for (s = 1; s <= n; s++)
                    for (a = 1; a <= r; a++) {
                        var S = (r + 1) * (s - 1) + (a - 1),
                            M = (r + 1) * s + (a - 1),
                            T = (r + 1) * s + a,
                            E = (r + 1) * (s - 1) + a;
                        l.push(S, M, E), l.push(M, T, E)
                    }

                function C(e, t, n, r, i) {
                    var o = Math.cos(e),
                        a = Math.sin(e),
                        s = n / t * e,
                        l = Math.cos(s);
                    i.x = r * (2 + l) * .5 * o, i.y = r * (2 + l) * a * .5, i.z = r * Math.sin(s) * .5
                }
                this.setIndex(l), this.setAttribute("position", new wr(c, 3)), this.setAttribute("normal", new wr(u, 3)), this.setAttribute("uv", new wr(h, 2))
            }

            function Ws(e, t, n, r, i) {
                ii.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, this.fromBufferGeometry(new js(e, t, n, r, i)), this.mergeVertices()
            }

            function js(e, t, n, r, i) {
                Ir.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
                var o, a, s = [],
                    l = [],
                    c = [],
                    u = [],
                    h = new Ot,
                    d = new Ot,
                    p = new Ot;
                for (o = 0; o <= n; o++)
                    for (a = 0; a <= r; a++) {
                        var f = a / r * i,
                            m = o / n * Math.PI * 2;
                        d.x = (e + t * Math.cos(m)) * Math.cos(f), d.y = (e + t * Math.cos(m)) * Math.sin(f), d.z = t * Math.sin(m), l.push(d.x, d.y, d.z), h.x = e * Math.cos(f), h.y = e * Math.sin(f), p.subVectors(d, h).normalize(), c.push(p.x, p.y, p.z), u.push(a / r), u.push(o / n)
                    }
                for (o = 1; o <= n; o++)
                    for (a = 1; a <= r; a++) {
                        var v = (r + 1) * o + a - 1,
                            g = (r + 1) * (o - 1) + a - 1,
                            y = (r + 1) * (o - 1) + a,
                            x = (r + 1) * o + a;
                        s.push(v, g, x), s.push(g, y, x)
                    }
                this.setIndex(s), this.setAttribute("position", new wr(l, 3)), this.setAttribute("normal", new wr(c, 3)), this.setAttribute("uv", new wr(u, 2))
            }
            _s.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: _s,
                isPoints: !0,
                raycast: function(e, t) {
                    var n = this.geometry,
                        r = this.matrixWorld,
                        i = e.params.Points.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), xs.copy(n.boundingSphere), xs.applyMatrix4(r), xs.radius += i, !1 !== e.ray.intersectsSphere(xs)) {
                        gs.getInverse(r), ys.copy(e.ray).applyMatrix4(gs);
                        var o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o;
                        if (n.isBufferGeometry) {
                            var s = n.index,
                                l = n.attributes.position.array;
                            if (null !== s)
                                for (var c = s.array, u = 0, h = c.length; u < h; u++) {
                                    var d = c[u];
                                    bs.fromArray(l, 3 * d), ws(bs, d, a, r, e, t, this)
                                } else {
                                    u = 0;
                                    for (var p = l.length / 3; u < p; u++) bs.fromArray(l, 3 * u), ws(bs, u, a, r, e, t, this)
                                }
                        } else {
                            var f = n.vertices;
                            for (u = 0, p = f.length; u < p; u++) ws(f[u], u, a, r, e, t, this)
                        }
                    }
                },
                updateMorphTargets: function() {
                    var e, t, n, r = this.geometry;
                    if (r.isBufferGeometry) {
                        var i = r.morphAttributes,
                            o = Object.keys(i);
                        if (0 < o.length) {
                            var a = i[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    } else {
                        var s = r.morphTargets;
                        void 0 !== s && 0 < s.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Ss.prototype = Object.assign(Object.create(Ft.prototype), {
                constructor: Ss,
                isVideoTexture: !0,
                update: function() {
                    var e = this.image;
                    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), ((Ms.prototype = Object.create(Ft.prototype)).constructor = Ms).prototype.isCompressedTexture = !0, ((Ts.prototype = Object.create(Ft.prototype)).constructor = Ts).prototype.isCanvasTexture = !0, ((Es.prototype = Object.create(Ft.prototype)).constructor = Es).prototype.isDepthTexture = !0, (Cs.prototype = Object.create(Ir.prototype)).constructor = Cs, (Ls.prototype = Object.create(ii.prototype)).constructor = Ls, (As.prototype = Object.create(Ir.prototype)).constructor = As, (Rs.prototype = Object.create(ii.prototype)).constructor = Rs, (Ps.prototype = Object.create(Ir.prototype)).constructor = Ps, (Os.prototype = Object.create(ii.prototype)).constructor = Os, (Is.prototype = Object.create(Ps.prototype)).constructor = Is, (Ds.prototype = Object.create(ii.prototype)).constructor = Ds, (Ns.prototype = Object.create(Ps.prototype)).constructor = Ns, (ks.prototype = Object.create(ii.prototype)).constructor = ks, (zs.prototype = Object.create(Ps.prototype)).constructor = zs, (Fs.prototype = Object.create(ii.prototype)).constructor = Fs, (Bs.prototype = Object.create(Ps.prototype)).constructor = Bs, (Us.prototype = Object.create(ii.prototype)).constructor = Us, ((Hs.prototype = Object.create(Ir.prototype)).constructor = Hs).prototype.toJSON = function() {
                var e = Ir.prototype.toJSON.call(this);
                return e.path = this.parameters.path.toJSON(), e
            }, (Gs.prototype = Object.create(ii.prototype)).constructor = Gs, (Vs.prototype = Object.create(Ir.prototype)).constructor = Vs, (Ws.prototype = Object.create(ii.prototype)).constructor = Ws, (js.prototype = Object.create(Ir.prototype)).constructor = js;
            var qs = function(e, t, n) {
                n = n || 2;
                var r, i, o, a, s, l, c, u = t && t.length,
                    h = u ? t[0] * n : e.length,
                    d = Xs(e, 0, h, n, !0),
                    p = [];
                if (!d || d.next === d.prev) return p;
                if (u && (d = function(e, t, n, r) {
                        var i, o, a, s, l, c = [];
                        for (i = 0, o = t.length; i < o; i++) a = t[i] * r, s = i < o - 1 ? t[i + 1] * r : e.length, (l = Xs(e, a, s, r, !1)) === l.next && (l.steiner = !0), c.push(rl(l));
                        for (c.sort(el), i = 0; i < c.length; i++) tl(c[i], n), n = Ys(n, n.next);
                        return n
                    }(e, t, d, n)), e.length > 80 * n) {
                    r = o = e[0], i = a = e[1];
                    for (var f = n; f < h; f += n)(s = e[f]) < r && (r = s), (l = e[f + 1]) < i && (i = l), o < s && (o = s), a < l && (a = l);
                    c = 0 !== (c = Math.max(o - r, a - i)) ? 1 / c : 0
                }
                return Zs(d, p, n, r, i, c), p
            };

            function Xs(e, t, n, r, i) {
                var o, a;
                if (i === 0 < function(e, t, n, r) {
                        for (var i = 0, o = t, a = n - r; o < n; o += r) i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
                        return i
                    }(e, t, n, r))
                    for (o = t; o < n; o += r) a = ul(o, e[o], e[o + 1], a);
                else
                    for (o = n - r; t <= o; o -= r) a = ul(o, e[o], e[o + 1], a);
                return a && al(a, a.next) && (hl(a), a = a.next), a
            }

            function Ys(e, t) {
                if (!e) return e;
                t = t || e;
                var n, r = e;
                do {
                    if (n = !1, r.steiner || !al(r, r.next) && 0 !== ol(r.prev, r, r.next)) r = r.next;
                    else {
                        if (hl(r), (r = t = r.prev) === r.next) break;
                        n = !0
                    }
                } while (n || r !== t);
                return t
            }

            function Zs(e, t, n, r, i, o, a) {
                if (e) {
                    !a && o && function(e, t, n, r) {
                        var i = e;
                        for (; null === i.z && (i.z = nl(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next, i !== e;);
                        i.prevZ.nextZ = null, i.prevZ = null,
                            function(e) {
                                var t, n, r, i, o, a, s, l, c = 1;
                                do {
                                    for (n = e, o = e = null, a = 0; n;) {
                                        for (a++, r = n, t = s = 0; t < c && (s++, r = r.nextZ); t++);
                                        for (l = c; 0 < s || 0 < l && r;) 0 !== s && (0 === l || !r || n.z <= r.z) ? (n = (i = n).nextZ, s--) : (r = (i = r).nextZ, l--), o ? o.nextZ = i : e = i, i.prevZ = o, o = i;
                                        n = r
                                    }
                                    o.nextZ = null, c *= 2
                                } while (1 < a)
                            }(i)
                    }(e, r, i, o);
                    for (var s, l, c = e; e.prev !== e.next;)
                        if (s = e.prev, l = e.next, o ? Js(e, r, i, o) : Ks(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), hl(e), e = l.next, c = l.next;
                        else if ((e = l) === c) {
                        a ? 1 === a ? Zs(e = Qs(e, t, n), t, n, r, i, o, 2) : 2 === a && $s(e, t, n, r, i, o) : Zs(Ys(e), t, n, r, i, o, 1);
                        break
                    }
                }
            }

            function Ks(e) {
                var t = e.prev,
                    n = e,
                    r = e.next;
                if (0 <= ol(t, n, r)) return !1;
                for (var i = e.next.next; i !== e.prev;) {
                    if (il(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && 0 <= ol(i.prev, i, i.next)) return !1;
                    i = i.next
                }
                return !0
            }

            function Js(e, t, n, r) {
                var i = e.prev,
                    o = e,
                    a = e.next;
                if (0 <= ol(i, o, a)) return !1;
                for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, l = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, c = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, u = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, h = nl(s, l, t, n, r), d = nl(c, u, t, n, r), p = e.prevZ, f = e.nextZ; p && p.z >= h && f && f.z <= d;) {
                    if (p !== e.prev && p !== e.next && il(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) && 0 <= ol(p.prev, p, p.next)) return !1;
                    if (p = p.prevZ, f !== e.prev && f !== e.next && il(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && 0 <= ol(f.prev, f, f.next)) return !1;
                    f = f.nextZ
                }
                for (; p && p.z >= h;) {
                    if (p !== e.prev && p !== e.next && il(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) && 0 <= ol(p.prev, p, p.next)) return !1;
                    p = p.prevZ
                }
                for (; f && f.z <= d;) {
                    if (f !== e.prev && f !== e.next && il(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && 0 <= ol(f.prev, f, f.next)) return !1;
                    f = f.nextZ
                }
                return !0
            }

            function Qs(e, t, n) {
                var r = e;
                do {
                    var i = r.prev,
                        o = r.next.next;
                    !al(i, o) && sl(i, r, r.next, o) && ll(i, o) && ll(o, i) && (t.push(i.i / n), t.push(r.i / n), t.push(o.i / n), hl(r), hl(r.next), r = e = o), r = r.next
                } while (r !== e);
                return r
            }

            function $s(e, t, n, r, i, o) {
                var a, s, l = e;
                do {
                    for (var c = l.next.next; c !== l.prev;) {
                        if (l.i !== c.i && (s = c, (a = l).next.i !== s.i && a.prev.i !== s.i && ! function(e, t) {
                                var n = e;
                                do {
                                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && sl(n, n.next, e, t)) return !0;
                                    n = n.next
                                } while (n !== e);
                                return !1
                            }(a, s) && ll(a, s) && ll(s, a) && function(e, t) {
                                var n = e,
                                    r = !1,
                                    i = (e.x + t.x) / 2,
                                    o = (e.y + t.y) / 2;
                                for (; n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next, n !== e;);
                                return r
                            }(a, s))) {
                            var u = cl(l, c);
                            return l = Ys(l, l.next), u = Ys(u, u.next), Zs(l, t, n, r, i, o), void Zs(u, t, n, r, i, o)
                        }
                        c = c.next
                    }
                    l = l.next
                } while (l !== e)
            }

            function el(e, t) {
                return e.x - t.x
            }

            function tl(e, t) {
                if (t = function(e, t) {
                        var n, r = t,
                            i = e.x,
                            o = e.y,
                            a = -1 / 0;
                        do {
                            if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                                var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                                if (s <= i && a < s) {
                                    if ((a = s) === i) {
                                        if (o === r.y) return r;
                                        if (o === r.next.y) return r.next
                                    }
                                    n = r.x < r.next.x ? r : r.next
                                }
                            }
                            r = r.next
                        } while (r !== t);
                        if (!n) return null;
                        if (i === a) return n.prev;
                        var l, c = n,
                            u = n.x,
                            h = n.y,
                            d = 1 / 0;
                        r = n.next;
                        for (; r !== c;) i >= r.x && r.x >= u && i !== r.x && il(o < h ? i : a, o, u, h, o < h ? a : i, o, r.x, r.y) && ((l = Math.abs(o - r.y) / (i - r.x)) < d || l === d && r.x > n.x) && ll(r, e) && (n = r, d = l), r = r.next;
                        return n
                    }(e, t)) {
                    var n = cl(t, e);
                    Ys(n, n.next)
                }
            }

            function nl(e, t, n, r, i) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function rl(e) {
                for (var t = e, n = e;
                    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), (t = t.next) !== e;);
                return n
            }

            function il(e, t, n, r, i, o, a, s) {
                return 0 <= (i - a) * (t - s) - (e - a) * (o - s) && 0 <= (e - a) * (r - s) - (n - a) * (t - s) && 0 <= (n - a) * (o - s) - (i - a) * (r - s)
            }

            function ol(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function al(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function sl(e, t, n, r) {
                return !!(al(e, n) && al(t, r) || al(e, r) && al(n, t)) || 0 < ol(e, t, n) != 0 < ol(e, t, r) && 0 < ol(n, r, e) != 0 < ol(n, r, t)
            }

            function ll(e, t) {
                return ol(e.prev, e, e.next) < 0 ? 0 <= ol(e, t, e.next) && 0 <= ol(e, e.prev, t) : ol(e, t, e.prev) < 0 || ol(e, e.next, t) < 0
            }

            function cl(e, t) {
                var n = new dl(e.i, e.x, e.y),
                    r = new dl(t.i, t.x, t.y),
                    i = e.next,
                    o = t.prev;
                return (e.next = t).prev = e, (n.next = i).prev = n, (r.next = n).prev = r, (o.next = r).prev = o, r
            }

            function ul(e, t, n, r) {
                var i = new dl(e, t, n);
                return r ? (i.next = r.next, (i.prev = r).next.prev = i, r.next = i) : (i.prev = i).next = i, i
            }

            function hl(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function dl(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var pl = {
                area: function(e) {
                    for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                    return .5 * n
                },
                isClockWise: function(e) {
                    return pl.area(e) < 0
                },
                triangulateShape: function(e, t) {
                    var n = [],
                        r = [],
                        i = [];
                    fl(e), ml(n, e);
                    var o = e.length;
                    t.forEach(fl);
                    for (var a = 0; a < t.length; a++) r.push(o), o += t[a].length, ml(n, t[a]);
                    var s = qs(n, r);
                    for (a = 0; a < s.length; a += 3) i.push(s.slice(a, a + 3));
                    return i
                }
            };

            function fl(e) {
                var t = e.length;
                2 < t && e[t - 1].equals(e[0]) && e.pop()
            }

            function ml(e, t) {
                for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }

            function vl(e, t) {
                ii.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: e,
                    options: t
                }, this.fromBufferGeometry(new gl(e, t)), this.mergeVertices()
            }

            function gl(e, J) {
                Ir.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: e,
                    options: J
                }, e = Array.isArray(e) ? e : [e];
                for (var Q = this, $ = [], ee = [], t = 0, n = e.length; t < n; t++) {
                    r(e[t])
                }

                function r(e) {
                    var r = [],
                        t = void 0 !== J.curveSegments ? J.curveSegments : 12,
                        l = void 0 !== J.steps ? J.steps : 1,
                        n = void 0 !== J.depth ? J.depth : 100,
                        i = void 0 === J.bevelEnabled || J.bevelEnabled,
                        o = void 0 !== J.bevelThickness ? J.bevelThickness : 6,
                        a = void 0 !== J.bevelSize ? J.bevelSize : o - 2,
                        s = void 0 !== J.bevelOffset ? J.bevelOffset : 0,
                        c = void 0 !== J.bevelSegments ? J.bevelSegments : 3,
                        u = J.extrudePath,
                        h = void 0 !== J.UVGenerator ? J.UVGenerator : yl;
                    void 0 !== J.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), n = J.amount);
                    var d, p, f, m, v, g, y, x, b = !1;
                    u && (d = u.getSpacedPoints(l), i = !(b = !0), p = u.computeFrenetFrames(l, !1), f = new Ot, m = new Ot, v = new Ot), i || (s = a = o = c = 0);
                    var _ = e.extractPoints(t),
                        w = _.shape,
                        S = _.holes;
                    if (!pl.isClockWise(w))
                        for (w = w.reverse(), y = 0, x = S.length; y < x; y++) g = S[y], pl.isClockWise(g) && (S[y] = g.reverse());
                    var M = pl.triangulateShape(w, S),
                        T = w;
                    for (y = 0, x = S.length; y < x; y++) g = S[y], w = w.concat(g);

                    function E(e, t, n) {
                        return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                    }
                    var C, L, A, R, P, O, I = w.length,
                        D = M.length;

                    function N(e, t, n) {
                        var r, i, o, a = e.x - t.x,
                            s = e.y - t.y,
                            l = n.x - e.x,
                            c = n.y - e.y,
                            u = a * a + s * s,
                            h = a * c - s * l;
                        if (Math.abs(h) > Number.EPSILON) {
                            var d = Math.sqrt(u),
                                p = Math.sqrt(l * l + c * c),
                                f = t.x - s / d,
                                m = t.y + a / d,
                                v = ((n.x - c / p - f) * c - (n.y + l / p - m) * l) / (a * c - s * l),
                                g = (r = f + a * v - e.x) * r + (i = m + s * v - e.y) * i;
                            if (g <= 2) return new Lt(r, i);
                            o = Math.sqrt(g / 2)
                        } else {
                            var y = !1;
                            a > Number.EPSILON ? l > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(c) && (y = !0), o = y ? (r = -s, i = a, Math.sqrt(u)) : (r = a, i = s, Math.sqrt(u / 2))
                        }
                        return new Lt(r / o, i / o)
                    }
                    for (var k = [], z = 0, F = T.length, B = F - 1, U = z + 1; z < F; z++, B++, U++) B === F && (B = 0), U === F && (U = 0), k[z] = N(T[z], T[B], T[U]);
                    var H, G, V = [],
                        W = k.concat();
                    for (y = 0, x = S.length; y < x; y++) {
                        for (g = S[y], H = [], z = 0, B = (F = g.length) - 1, U = z + 1; z < F; z++, B++, U++) B === F && (B = 0), U === F && (U = 0), H[z] = N(g[z], g[B], g[U]);
                        V.push(H), W = W.concat(H)
                    }
                    for (C = 0; C < c; C++) {
                        for (A = C / c, R = o * Math.cos(A * Math.PI / 2), L = a * Math.sin(A * Math.PI / 2) + s, z = 0, F = T.length; z < F; z++) q((P = E(T[z], k[z], L)).x, P.y, -R);
                        for (y = 0, x = S.length; y < x; y++)
                            for (g = S[y], H = V[y], z = 0, F = g.length; z < F; z++) q((P = E(g[z], H[z], L)).x, P.y, -R)
                    }
                    for (L = a + s, z = 0; z < I; z++) P = i ? E(w[z], W[z], L) : w[z], b ? (m.copy(p.normals[0]).multiplyScalar(P.x), f.copy(p.binormals[0]).multiplyScalar(P.y), v.copy(d[0]).add(m).add(f), q(v.x, v.y, v.z)) : q(P.x, P.y, 0);
                    for (G = 1; G <= l; G++)
                        for (z = 0; z < I; z++) P = i ? E(w[z], W[z], L) : w[z], b ? (m.copy(p.normals[G]).multiplyScalar(P.x), f.copy(p.binormals[G]).multiplyScalar(P.y), v.copy(d[G]).add(m).add(f), q(v.x, v.y, v.z)) : q(P.x, P.y, n / l * G);
                    for (C = c - 1; 0 <= C; C--) {
                        for (A = C / c, R = o * Math.cos(A * Math.PI / 2), L = a * Math.sin(A * Math.PI / 2) + s, z = 0, F = T.length; z < F; z++) q((P = E(T[z], k[z], L)).x, P.y, n + R);
                        for (y = 0, x = S.length; y < x; y++)
                            for (g = S[y], H = V[y], z = 0, F = g.length; z < F; z++) P = E(g[z], H[z], L), b ? q(P.x, P.y + d[l - 1].y, d[l - 1].x + R) : q(P.x, P.y, n + R)
                    }

                    function j(e, t) {
                        var n, r;
                        for (z = e.length; 0 <= --z;) {
                            (r = (n = z) - 1) < 0 && (r = e.length - 1);
                            var i = 0,
                                o = l + 2 * c;
                            for (i = 0; i < o; i++) {
                                var a = I * i,
                                    s = I * (i + 1);
                                Y(t + n + a, t + r + a, t + r + s, t + n + s)
                            }
                        }
                    }

                    function q(e, t, n) {
                        r.push(e), r.push(t), r.push(n)
                    }

                    function X(e, t, n) {
                        Z(e), Z(t), Z(n);
                        var r = $.length / 3,
                            i = h.generateTopUV(Q, $, r - 3, r - 2, r - 1);
                        K(i[0]), K(i[1]), K(i[2])
                    }

                    function Y(e, t, n, r) {
                        Z(e), Z(t), Z(r), Z(t), Z(n), Z(r);
                        var i = $.length / 3,
                            o = h.generateSideWallUV(Q, $, i - 6, i - 3, i - 2, i - 1);
                        K(o[0]), K(o[1]), K(o[3]), K(o[1]), K(o[2]), K(o[3])
                    }

                    function Z(e) {
                        $.push(r[3 * e + 0]), $.push(r[3 * e + 1]), $.push(r[3 * e + 2])
                    }

                    function K(e) {
                        ee.push(e.x), ee.push(e.y)
                    }! function() {
                        var e = $.length / 3;
                        if (i) {
                            var t = 0,
                                n = I * t;
                            for (z = 0; z < D; z++) X((O = M[z])[2] + n, O[1] + n, O[0] + n);
                            for (n = I * (t = l + 2 * c), z = 0; z < D; z++) X((O = M[z])[0] + n, O[1] + n, O[2] + n)
                        } else {
                            for (z = 0; z < D; z++) X((O = M[z])[2], O[1], O[0]);
                            for (z = 0; z < D; z++) X((O = M[z])[0] + I * l, O[1] + I * l, O[2] + I * l)
                        }
                        Q.addGroup(e, $.length / 3 - e, 0)
                    }(),
                    function() {
                        var e = $.length / 3,
                            t = 0;
                        for (j(T, t), t += T.length, y = 0, x = S.length; y < x; y++) j(g = S[y], t), t += g.length;
                        Q.addGroup(e, $.length / 3 - e, 1)
                    }()
                }
                this.setAttribute("position", new wr($, 3)), this.setAttribute("uv", new wr(ee, 2)), this.computeVertexNormals()
            }((vl.prototype = Object.create(ii.prototype)).constructor = vl).prototype.toJSON = function() {
                var e = ii.prototype.toJSON.call(this);
                return xl(this.parameters.shapes, this.parameters.options, e)
            }, ((gl.prototype = Object.create(Ir.prototype)).constructor = gl).prototype.toJSON = function() {
                var e = Ir.prototype.toJSON.call(this);
                return xl(this.parameters.shapes, this.parameters.options, e)
            };
            var yl = {
                generateTopUV: function(e, t, n, r, i) {
                    var o = t[3 * n],
                        a = t[3 * n + 1],
                        s = t[3 * r],
                        l = t[3 * r + 1],
                        c = t[3 * i],
                        u = t[3 * i + 1];
                    return [new Lt(o, a), new Lt(s, l), new Lt(c, u)]
                },
                generateSideWallUV: function(e, t, n, r, i, o) {
                    var a = t[3 * n],
                        s = t[3 * n + 1],
                        l = t[3 * n + 2],
                        c = t[3 * r],
                        u = t[3 * r + 1],
                        h = t[3 * r + 2],
                        d = t[3 * i],
                        p = t[3 * i + 1],
                        f = t[3 * i + 2],
                        m = t[3 * o],
                        v = t[3 * o + 1],
                        g = t[3 * o + 2];
                    return Math.abs(s - u) < .01 ? [new Lt(a, 1 - l), new Lt(c, 1 - h), new Lt(d, 1 - f), new Lt(m, 1 - g)] : [new Lt(s, 1 - l), new Lt(u, 1 - h), new Lt(p, 1 - f), new Lt(v, 1 - g)]
                }
            };

            function xl(e, t, n) {
                if (n.shapes = [], Array.isArray(e))
                    for (var r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        n.shapes.push(o.uuid)
                    } else n.shapes.push(e.uuid);
                return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
            }

            function bl(e, t) {
                ii.call(this), this.type = "TextGeometry", this.parameters = {
                    text: e,
                    parameters: t
                }, this.fromBufferGeometry(new _l(e, t)), this.mergeVertices()
            }

            function _l(e, t) {
                var n = (t = t || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ii;
                var r = n.generateShapes(e, t.size);
                t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), gl.call(this, r, t), this.type = "TextBufferGeometry"
            }

            function wl(e, t, n, r, i, o, a) {
                ii.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: a
                }, this.fromBufferGeometry(new Sl(e, t, n, r, i, o, a)), this.mergeVertices()
            }

            function Sl(e, t, n, r, i, o, a) {
                Ir.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: a
                }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
                var s, l, c = Math.min(o + a, Math.PI),
                    u = 0,
                    h = [],
                    d = new Ot,
                    p = new Ot,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (l = 0; l <= n; l++) {
                    var y = [],
                        x = l / n,
                        b = 0;
                    for (0 == l && 0 == o ? b = .5 / t : l == n && c == Math.PI && (b = -.5 / t), s = 0; s <= t; s++) {
                        var _ = s / t;
                        d.x = -e * Math.cos(r + _ * i) * Math.sin(o + x * a), d.y = e * Math.cos(o + x * a), d.z = e * Math.sin(r + _ * i) * Math.sin(o + x * a), m.push(d.x, d.y, d.z), p.copy(d).normalize(), v.push(p.x, p.y, p.z), g.push(_ + b, 1 - x), y.push(u++)
                    }
                    h.push(y)
                }
                for (l = 0; l < n; l++)
                    for (s = 0; s < t; s++) {
                        var w = h[l][s + 1],
                            S = h[l][s],
                            M = h[l + 1][s],
                            T = h[l + 1][s + 1];
                        (0 !== l || 0 < o) && f.push(w, S, T), (l !== n - 1 || c < Math.PI) && f.push(S, M, T)
                    }
                this.setIndex(f), this.setAttribute("position", new wr(m, 3)), this.setAttribute("normal", new wr(v, 3)), this.setAttribute("uv", new wr(g, 2))
            }

            function Ml(e, t, n, r, i, o) {
                ii.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: o
                }, this.fromBufferGeometry(new Tl(e, t, n, r, i, o)), this.mergeVertices()
            }

            function Tl(e, t, n, r, i, o) {
                Ir.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: o
                }, e = e || .5, t = t || 1, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
                var a, s, l, c = [],
                    u = [],
                    h = [],
                    d = [],
                    p = e,
                    f = (t - e) / (r = void 0 !== r ? Math.max(1, r) : 1),
                    m = new Ot,
                    v = new Lt;
                for (s = 0; s <= r; s++) {
                    for (l = 0; l <= n; l++) a = i + l / n * o, m.x = p * Math.cos(a), m.y = p * Math.sin(a), u.push(m.x, m.y, m.z), h.push(0, 0, 1), v.x = (m.x / t + 1) / 2, v.y = (m.y / t + 1) / 2, d.push(v.x, v.y);
                    p += f
                }
                for (s = 0; s < r; s++) {
                    var g = s * (n + 1);
                    for (l = 0; l < n; l++) {
                        var y = a = l + g,
                            x = a + n + 1,
                            b = a + n + 2,
                            _ = a + 1;
                        c.push(y, x, _), c.push(x, b, _)
                    }
                }
                this.setIndex(c), this.setAttribute("position", new wr(u, 3)), this.setAttribute("normal", new wr(h, 3)), this.setAttribute("uv", new wr(d, 2))
            }

            function El(e, t, n, r) {
                ii.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: r
                }, this.fromBufferGeometry(new Cl(e, t, n, r)), this.mergeVertices()
            }

            function Cl(e, t, n, r) {
                Ir.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: r
                }, t = Math.floor(t) || 12, n = n || 0, r = r || 2 * Math.PI, r = Ct.clamp(r, 0, 2 * Math.PI);
                var i, o, a, s = [],
                    l = [],
                    c = [],
                    u = 1 / t,
                    h = new Ot,
                    d = new Lt;
                for (o = 0; o <= t; o++) {
                    var p = n + o * u * r,
                        f = Math.sin(p),
                        m = Math.cos(p);
                    for (a = 0; a <= e.length - 1; a++) h.x = e[a].x * f, h.y = e[a].y, h.z = e[a].x * m, l.push(h.x, h.y, h.z), d.x = o / t, d.y = a / (e.length - 1), c.push(d.x, d.y)
                }
                for (o = 0; o < t; o++)
                    for (a = 0; a < e.length - 1; a++) {
                        var v = i = a + o * e.length,
                            g = i + e.length,
                            y = i + e.length + 1,
                            x = i + 1;
                        s.push(v, g, x), s.push(g, y, x)
                    }
                if (this.setIndex(s), this.setAttribute("position", new wr(l, 3)), this.setAttribute("uv", new wr(c, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
                    var b = this.attributes.normal.array,
                        _ = new Ot,
                        w = new Ot,
                        S = new Ot;
                    for (i = t * e.length * 3, a = o = 0; o < e.length; o++, a += 3) _.x = b[a + 0], _.y = b[a + 1], _.z = b[a + 2], w.x = b[i + a + 0], w.y = b[i + a + 1], w.z = b[i + a + 2], S.addVectors(_, w).normalize(), b[a + 0] = b[i + a + 0] = S.x, b[a + 1] = b[i + a + 1] = S.y, b[a + 2] = b[i + a + 2] = S.z
                }
            }

            function Ll(e, t) {
                ii.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
                    shapes: e,
                    curveSegments: t
                }, this.fromBufferGeometry(new Al(e, t)), this.mergeVertices()
            }

            function Al(e, f) {
                Ir.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: e,
                    curveSegments: f
                }, f = f || 12;
                var m = [],
                    v = [],
                    g = [],
                    y = [],
                    t = 0,
                    x = 0;
                if (!1 === Array.isArray(e)) r(e);
                else
                    for (var n = 0; n < e.length; n++) r(e[n]), this.addGroup(t, x, n), t += x, x = 0;

                function r(e) {
                    var t, n, r, i = v.length / 3,
                        o = e.extractPoints(f),
                        a = o.shape,
                        s = o.holes;
                    for (!1 === pl.isClockWise(a) && (a = a.reverse()), t = 0, n = s.length; t < n; t++) r = s[t], !0 === pl.isClockWise(r) && (s[t] = r.reverse());
                    var l = pl.triangulateShape(a, s);
                    for (t = 0, n = s.length; t < n; t++) r = s[t], a = a.concat(r);
                    for (t = 0, n = a.length; t < n; t++) {
                        var c = a[t];
                        v.push(c.x, c.y, 0), g.push(0, 0, 1), y.push(c.x, c.y)
                    }
                    for (t = 0, n = l.length; t < n; t++) {
                        var u = l[t],
                            h = u[0] + i,
                            d = u[1] + i,
                            p = u[2] + i;
                        m.push(h, d, p), x += 3
                    }
                }
                this.setIndex(m), this.setAttribute("position", new wr(v, 3)), this.setAttribute("normal", new wr(g, 3)), this.setAttribute("uv", new wr(y, 2))
            }

            function Rl(e, t) {
                if (t.shapes = [], Array.isArray(e))
                    for (var n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.shapes.push(i.uuid)
                    } else t.shapes.push(e.uuid);
                return t
            }

            function Pl(e, t) {
                Ir.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: t
                }, t = void 0 !== t ? t : 1;
                var n, r, i, o, a = [],
                    s = Math.cos(Ct.DEG2RAD * t),
                    l = [0, 0],
                    c = {},
                    u = ["a", "b", "c"];
                e.isBufferGeometry ? (o = new ii).fromBufferGeometry(e) : o = e.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var h = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], v = 0; v < 3; v++) n = m[u[v]], r = m[u[(v + 1) % 3]], l[0] = Math.min(n, r), l[1] = Math.max(n, r), void 0 === c[i = l[0] + "," + l[1]] ? c[i] = {
                        index1: l[0],
                        index2: l[1],
                        face1: p,
                        face2: void 0
                    } : c[i].face2 = p;
                for (i in c) {
                    var g = c[i];
                    if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
                        var y = h[g.index1];
                        a.push(y.x, y.y, y.z), y = h[g.index2], a.push(y.x, y.y, y.z)
                    }
                }
                this.setAttribute("position", new wr(a, 3))
            }

            function Ol(e, t, n, r, i, o, a, s) {
                ii.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new Il(e, t, n, r, i, o, a, s)), this.mergeVertices()
            }

            function Il(g, y, x, b, _, e, w, S) {
                Ir.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: g,
                    radiusBottom: y,
                    height: x,
                    radialSegments: b,
                    heightSegments: _,
                    openEnded: e,
                    thetaStart: w,
                    thetaLength: S
                };
                var M = this;
                g = void 0 !== g ? g : 1, y = void 0 !== y ? y : 1, x = x || 1, b = Math.floor(b) || 8, _ = Math.floor(_) || 1, e = void 0 !== e && e, w = void 0 !== w ? w : 0, S = void 0 !== S ? S : 2 * Math.PI;
                var T = [],
                    E = [],
                    C = [],
                    L = [],
                    A = 0,
                    R = [],
                    P = x / 2,
                    O = 0;

                function t(e) {
                    var t, n, r, i = new Lt,
                        o = new Ot,
                        a = 0,
                        s = !0 === e ? g : y,
                        l = !0 === e ? 1 : -1;
                    for (n = A, t = 1; t <= b; t++) E.push(0, P * l, 0), C.push(0, l, 0), L.push(.5, .5), A++;
                    for (r = A, t = 0; t <= b; t++) {
                        var c = t / b * S + w,
                            u = Math.cos(c),
                            h = Math.sin(c);
                        o.x = s * h, o.y = P * l, o.z = s * u, E.push(o.x, o.y, o.z), C.push(0, l, 0), i.x = .5 * u + .5, i.y = .5 * h * l + .5, L.push(i.x, i.y), A++
                    }
                    for (t = 0; t < b; t++) {
                        var d = n + t,
                            p = r + t;
                        !0 === e ? T.push(p, p + 1, d) : T.push(p + 1, p, d), a += 3
                    }
                    M.addGroup(O, a, !0 === e ? 1 : 2), O += a
                }! function() {
                    var e, t, n = new Ot,
                        r = new Ot,
                        i = 0,
                        o = (y - g) / x;
                    for (t = 0; t <= _; t++) {
                        var a = [],
                            s = t / _,
                            l = s * (y - g) + g;
                        for (e = 0; e <= b; e++) {
                            var c = e / b,
                                u = c * S + w,
                                h = Math.sin(u),
                                d = Math.cos(u);
                            r.x = l * h, r.y = -s * x + P, r.z = l * d, E.push(r.x, r.y, r.z), n.set(h, o, d).normalize(), C.push(n.x, n.y, n.z), L.push(c, 1 - s), a.push(A++)
                        }
                        R.push(a)
                    }
                    for (e = 0; e < b; e++)
                        for (t = 0; t < _; t++) {
                            var p = R[t][e],
                                f = R[t + 1][e],
                                m = R[t + 1][e + 1],
                                v = R[t][e + 1];
                            T.push(p, f, v), T.push(f, m, v), i += 6
                        }
                    M.addGroup(O, i, 0), O += i
                }(), !1 === e && (0 < g && t(!0), 0 < y && t(!1)), this.setIndex(T), this.setAttribute("position", new wr(E, 3)), this.setAttribute("normal", new wr(C, 3)), this.setAttribute("uv", new wr(L, 2))
            }

            function Dl(e, t, n, r, i, o, a) {
                Ol.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Nl(e, t, n, r, i, o, a) {
                Il.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function kl(e, t, n, r) {
                ii.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: r
                }, this.fromBufferGeometry(new zl(e, t, n, r)), this.mergeVertices()
            }

            function zl(e, t, n, r) {
                Ir.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: r
                }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var i, o, a = [],
                    s = [],
                    l = [],
                    c = [],
                    u = new Ot,
                    h = new Lt;
                for (s.push(0, 0, 0), l.push(0, 0, 1), c.push(.5, .5), o = 0, i = 3; o <= t; o++, i += 3) {
                    var d = n + o / t * r;
                    u.x = e * Math.cos(d), u.y = e * Math.sin(d), s.push(u.x, u.y, u.z), l.push(0, 0, 1), h.x = (s[i] / e + 1) / 2, h.y = (s[i + 1] / e + 1) / 2, c.push(h.x, h.y)
                }
                for (i = 1; i <= t; i++) a.push(i, i + 1, 0);
                this.setIndex(a), this.setAttribute("position", new wr(s, 3)), this.setAttribute("normal", new wr(l, 3)), this.setAttribute("uv", new wr(c, 2))
            }(bl.prototype = Object.create(ii.prototype)).constructor = bl, (_l.prototype = Object.create(gl.prototype)).constructor = _l, (wl.prototype = Object.create(ii.prototype)).constructor = wl, (Sl.prototype = Object.create(Ir.prototype)).constructor = Sl, (Ml.prototype = Object.create(ii.prototype)).constructor = Ml, (Tl.prototype = Object.create(Ir.prototype)).constructor = Tl, (El.prototype = Object.create(ii.prototype)).constructor = El, (Cl.prototype = Object.create(Ir.prototype)).constructor = Cl, ((Ll.prototype = Object.create(ii.prototype)).constructor = Ll).prototype.toJSON = function() {
                var e = ii.prototype.toJSON.call(this);
                return Rl(this.parameters.shapes, e)
            }, ((Al.prototype = Object.create(Ir.prototype)).constructor = Al).prototype.toJSON = function() {
                var e = Ir.prototype.toJSON.call(this);
                return Rl(this.parameters.shapes, e)
            }, (Pl.prototype = Object.create(Ir.prototype)).constructor = Pl, (Ol.prototype = Object.create(ii.prototype)).constructor = Ol, (Il.prototype = Object.create(Ir.prototype)).constructor = Il, (Dl.prototype = Object.create(Ol.prototype)).constructor = Dl, (Nl.prototype = Object.create(Il.prototype)).constructor = Nl, (kl.prototype = Object.create(ii.prototype)).constructor = kl, (zl.prototype = Object.create(Ir.prototype)).constructor = zl;
            var Fl = Object.freeze({
                __proto__: null,
                WireframeGeometry: Cs,
                ParametricGeometry: Ls,
                ParametricBufferGeometry: As,
                TetrahedronGeometry: Os,
                TetrahedronBufferGeometry: Is,
                OctahedronGeometry: Ds,
                OctahedronBufferGeometry: Ns,
                IcosahedronGeometry: ks,
                IcosahedronBufferGeometry: zs,
                DodecahedronGeometry: Fs,
                DodecahedronBufferGeometry: Bs,
                PolyhedronGeometry: Rs,
                PolyhedronBufferGeometry: Ps,
                TubeGeometry: Us,
                TubeBufferGeometry: Hs,
                TorusKnotGeometry: Gs,
                TorusKnotBufferGeometry: Vs,
                TorusGeometry: Ws,
                TorusBufferGeometry: js,
                TextGeometry: bl,
                TextBufferGeometry: _l,
                SphereGeometry: wl,
                SphereBufferGeometry: Sl,
                RingGeometry: Ml,
                RingBufferGeometry: Tl,
                PlaneGeometry: Ei,
                PlaneBufferGeometry: Ci,
                LatheGeometry: El,
                LatheBufferGeometry: Cl,
                ShapeGeometry: Ll,
                ShapeBufferGeometry: Al,
                ExtrudeGeometry: vl,
                ExtrudeBufferGeometry: gl,
                EdgesGeometry: Pl,
                ConeGeometry: Dl,
                ConeBufferGeometry: Nl,
                CylinderGeometry: Ol,
                CylinderBufferGeometry: Il,
                CircleGeometry: kl,
                CircleBufferGeometry: zl,
                BoxGeometry: oi,
                BoxBufferGeometry: ai
            });

            function Bl(e) {
                hr.call(this), this.type = "ShadowMaterial", this.color = new or(0), this.transparent = !0, this.setValues(e)
            }

            function Ul(e) {
                di.call(this, e), this.type = "RawShaderMaterial"
            }

            function Hl(e) {
                hr.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new or(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new or(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yt, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function Gl(e) {
                Hl.call(this), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearcoat = 0, this.clearcoatRoughness = 0, this.sheen = null, this.clearcoatNormalScale = new Lt(1, 1), this.clearcoatNormalMap = null, this.transparency = 0, this.setValues(e)
            }

            function Vl(e) {
                hr.call(this), this.type = "MeshPhongMaterial", this.color = new or(16777215), this.specular = new or(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new or(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yt, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = F, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function Wl(e) {
                hr.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new or(16777215), this.specular = new or(1118481), this.shininess = 30, this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new or(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yt, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function jl(e) {
                hr.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yt, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function ql(e) {
                hr.call(this), this.type = "MeshLambertMaterial", this.color = new or(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new or(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = F, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function Xl(e) {
                hr.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new or(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yt, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function Yl(e) {
                os.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
            }((Bl.prototype = Object.create(hr.prototype)).constructor = Bl).prototype.isShadowMaterial = !0, Bl.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.color.copy(e.color), this
            }, ((Ul.prototype = Object.create(di.prototype)).constructor = Ul).prototype.isRawShaderMaterial = !0, ((Hl.prototype = Object.create(hr.prototype)).constructor = Hl).prototype.isMeshStandardMaterial = !0, Hl.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((Gl.prototype = Object.create(Hl.prototype)).constructor = Gl).prototype.isMeshPhysicalMaterial = !0, Gl.prototype.copy = function(e) {
                return Hl.prototype.copy.call(this, e), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.reflectivity = e.reflectivity, this.clearcoat = e.clearcoat, this.clearcoatRoughness = e.clearcoatRoughness, e.sheen ? this.sheen = (this.sheen || new or).copy(e.sheen) : this.sheen = null, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.transparency = e.transparency, this
            }, ((Vl.prototype = Object.create(hr.prototype)).constructor = Vl).prototype.isMeshPhongMaterial = !0, Vl.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((Wl.prototype = Object.create(hr.prototype)).constructor = Wl).prototype.isMeshToonMaterial = !0, Wl.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((jl.prototype = Object.create(hr.prototype)).constructor = jl).prototype.isMeshNormalMaterial = !0, jl.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((ql.prototype = Object.create(hr.prototype)).constructor = ql).prototype.isMeshLambertMaterial = !0, ql.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((Xl.prototype = Object.create(hr.prototype)).constructor = Xl).prototype.isMeshMatcapMaterial = !0, Xl.prototype.copy = function(e) {
                return hr.prototype.copy.call(this, e), this.defines = {
                    MATCAP: ""
                }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, ((Yl.prototype = Object.create(os.prototype)).constructor = Yl).prototype.isLineDashedMaterial = !0, Yl.prototype.copy = function(e) {
                return os.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
            };
            var Zl = Object.freeze({
                    __proto__: null,
                    ShadowMaterial: Bl,
                    SpriteMaterial: Pa,
                    RawShaderMaterial: Ul,
                    ShaderMaterial: di,
                    PointsMaterial: vs,
                    MeshPhysicalMaterial: Gl,
                    MeshStandardMaterial: Hl,
                    MeshPhongMaterial: Vl,
                    MeshToonMaterial: Wl,
                    MeshNormalMaterial: jl,
                    MeshLambertMaterial: ql,
                    MeshDepthMaterial: ha,
                    MeshDistanceMaterial: da,
                    MeshBasicMaterial: dr,
                    MeshMatcapMaterial: Xl,
                    LineDashedMaterial: Yl,
                    LineBasicMaterial: os,
                    Material: hr
                }),
                Kl = {
                    arraySlice: function(e, t, n) {
                        return Kl.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                    },
                    convertArray: function(e, t, n) {
                        return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                    },
                    isTypedArray: function(e) {
                        return ArrayBuffer.isView(e) && !(e instanceof DataView)
                    },
                    getKeyframeOrder: function(n) {
                        for (var e = n.length, t = new Array(e), r = 0; r !== e; ++r) t[r] = r;
                        return t.sort(function(e, t) {
                            return n[e] - n[t]
                        }), t
                    },
                    sortedArray: function(e, t, n) {
                        for (var r = e.length, i = new e.constructor(r), o = 0, a = 0; a !== r; ++o)
                            for (var s = n[o] * t, l = 0; l !== t; ++l) i[a++] = e[s + l];
                        return i
                    },
                    flattenJSON: function(e, t, n, r) {
                        for (var i = 1, o = e[0]; void 0 !== o && void 0 === o[r];) o = e[i++];
                        if (void 0 !== o) {
                            var a = o[r];
                            if (void 0 !== a)
                                if (Array.isArray(a))
                                    for (; void 0 !== (a = o[r]) && (t.push(o.time), n.push.apply(n, a)), void 0 !== (o = e[i++]););
                                else if (void 0 !== a.toArray)
                                for (; void 0 !== (a = o[r]) && (t.push(o.time), a.toArray(n, n.length)), void 0 !== (o = e[i++]););
                            else
                                for (; void 0 !== (a = o[r]) && (t.push(o.time), n.push(a)), void 0 !== (o = e[i++]););
                        }
                    },
                    subclip: function(e, t, n, r, i) {
                        i = i || 30;
                        var o = e.clone();
                        o.name = t;
                        for (var a = [], s = 0; s < o.tracks.length; ++s) {
                            for (var l = o.tracks[s], c = l.getValueSize(), u = [], h = [], d = 0; d < l.times.length; ++d) {
                                var p = l.times[d] * i;
                                if (!(p < n || r <= p)) {
                                    u.push(l.times[d]);
                                    for (var f = 0; f < c; ++f) h.push(l.values[d * c + f])
                                }
                            }
                            0 !== u.length && (l.times = Kl.convertArray(u, l.times.constructor), l.values = Kl.convertArray(h, l.values.constructor), a.push(l))
                        }
                        o.tracks = a;
                        var m = 1 / 0;
                        for (s = 0; s < o.tracks.length; ++s) m > o.tracks[s].times[0] && (m = o.tracks[s].times[0]);
                        for (s = 0; s < o.tracks.length; ++s) o.tracks[s].shift(-1 * m);
                        return o.resetDuration(), o
                    }
                };

            function Jl(e, t, n, r) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n
            }

            function Ql(e, t, n, r) {
                Jl.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function $l(e, t, n, r) {
                Jl.call(this, e, t, n, r)
            }

            function ec(e, t, n, r) {
                Jl.call(this, e, t, n, r)
            }

            function tc(e, t, n, r) {
                if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = Kl.convertArray(t, this.TimeBufferType), this.values = Kl.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
            }

            function nc(e, t, n) {
                tc.call(this, e, t, n)
            }

            function rc(e, t, n, r) {
                tc.call(this, e, t, n, r)
            }

            function ic(e, t, n, r) {
                tc.call(this, e, t, n, r)
            }

            function oc(e, t, n, r) {
                Jl.call(this, e, t, n, r)
            }

            function ac(e, t, n, r) {
                tc.call(this, e, t, n, r)
            }

            function sc(e, t, n, r) {
                tc.call(this, e, t, n, r)
            }

            function lc(e, t, n, r) {
                tc.call(this, e, t, n, r)
            }

            function cc(e, t, n) {
                this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = Ct.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function uc(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var t = function(e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return ic;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return lc;
                        case "color":
                            return rc;
                        case "quaternion":
                            return ac;
                        case "bool":
                        case "boolean":
                            return nc;
                        case "string":
                            return sc
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    var n = [],
                        r = [];
                    Kl.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }
            Object.assign(Jl.prototype, {
                evaluate: function(e) {
                    var t = this.parameterPositions,
                        n = this._cachedIndex,
                        r = t[n],
                        i = t[n - 1];
                    e: {
                        t: {
                            var o;
                            n: {
                                r: if (!(e < r)) {
                                    for (var a = n + 2;;) {
                                        if (void 0 === r) {
                                            if (e < i) break r;
                                            return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i)
                                        }
                                        if (n === a) break;
                                        if (i = r, e < (r = t[++n])) break t
                                    }
                                    o = t.length;
                                    break n
                                }if (i <= e) break e;
                                var s = t[1];e < s && (n = 2, i = s);
                                for (a = n - 2;;) {
                                    if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                                    if (n === a) break;
                                    if (r = i, (i = t[--n - 1]) <= e) break t
                                }
                                o = n,
                                n = 0
                            }
                            for (; n < o;) {
                                var l = n + o >>> 1;
                                e < t[l] ? o = l : n = 1 + l
                            }
                            if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                            if (void 0 === r) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, e)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, e, r)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(e) {
                    for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, o = 0; o !== r; ++o) t[o] = n[i + o];
                    return t
                },
                interpolate_: function() {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function() {}
            }), Object.assign(Jl.prototype, {
                beforeStart_: Jl.prototype.copySampleValue_,
                afterEnd_: Jl.prototype.copySampleValue_
            }), Ql.prototype = Object.assign(Object.create(Jl.prototype), {
                constructor: Ql,
                DefaultSettings_: {
                    endingStart: 2400,
                    endingEnd: 2400
                },
                intervalChanged_: function(e, t, n) {
                    var r = this.parameterPositions,
                        i = e - 2,
                        o = e + 1,
                        a = r[i],
                        s = r[o];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case 2401:
                            i = e, a = 2 * t - n;
                            break;
                        case 2402:
                            a = t + r[i = r.length - 2] - r[i + 1];
                            break;
                        default:
                            i = e, a = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case 2401:
                            o = e, s = 2 * n - t;
                            break;
                        case 2402:
                            s = n + r[o = 1] - r[0];
                            break;
                        default:
                            o = e - 1, s = t
                    }
                    var l = .5 * (n - t),
                        c = this.valueSize;
                    this._weightPrev = l / (t - a), this._weightNext = l / (s - n), this._offsetPrev = i * c, this._offsetNext = o * c
                },
                interpolate_: function(e, t, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, l = s - a, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - t) / (r - t), f = p * p, m = f * p, v = -h * m + 2 * h * f - h * p, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f, b = 0; b !== a; ++b) i[b] = v * o[c + b] + g * o[l + b] + y * o[s + b] + x * o[u + b];
                    return i
                }
            }), $l.prototype = Object.assign(Object.create(Jl.prototype), {
                constructor: $l,
                interpolate_: function(e, t, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, l = s - a, c = (n - t) / (r - t), u = 1 - c, h = 0; h !== a; ++h) i[h] = o[l + h] * u + o[s + h] * c;
                    return i
                }
            }), ec.prototype = Object.assign(Object.create(Jl.prototype), {
                constructor: ec,
                interpolate_: function(e) {
                    return this.copySampleValue_(e - 1)
                }
            }), Object.assign(tc, {
                toJSON: function(e) {
                    var t, n = e.constructor;
                    if (void 0 !== n.toJSON) t = n.toJSON(e);
                    else {
                        t = {
                            name: e.name,
                            times: Kl.convertArray(e.times, Array),
                            values: Kl.convertArray(e.values, Array)
                        };
                        var r = e.getInterpolation();
                        r !== e.DefaultInterpolation && (t.interpolation = r)
                    }
                    return t.type = e.ValueTypeName, t
                }
            }), Object.assign(tc.prototype, {
                constructor: tc,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodDiscrete: function(e) {
                    return new ec(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodLinear: function(e) {
                    return new $l(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: function(e) {
                    return new Ql(this.times, this.values, this.getValueSize(), e)
                },
                setInterpolation: function(e) {
                    var t;
                    switch (e) {
                        case 2300:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case 2301:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 !== t) return this.createInterpolant = t, this;
                    var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation) throw new Error(n);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", n), this
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return 2300;
                        case this.InterpolantFactoryMethodLinear:
                            return 2301;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(e) {
                    if (0 !== e)
                        for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
                    return this
                },
                scale: function(e) {
                    if (1 !== e)
                        for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
                    return this
                },
                trim: function(e, t) {
                    for (var n = this.times, r = n.length, i = 0, o = r - 1; i !== r && n[i] < e;) ++i;
                    for (; - 1 !== o && n[o] > t;) --o;
                    if (++o, 0 !== i || o !== r) {
                        o <= i && (i = (o = Math.max(o, 1)) - 1);
                        var a = this.getValueSize();
                        this.times = Kl.arraySlice(n, i, o), this.values = Kl.arraySlice(this.values, i * a, o * a)
                    }
                    return this
                },
                validate: function() {
                    var e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    var n = this.times,
                        r = this.values,
                        i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    for (var o = null, a = 0; a !== i; a++) {
                        var s = n[a];
                        if ("number" == typeof s && isNaN(s)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), e = !1;
                            break
                        }
                        if (null !== o && s < o) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), e = !1;
                            break
                        }
                        o = s
                    }
                    if (void 0 !== r && Kl.isTypedArray(r)) {
                        a = 0;
                        for (var l = r.length; a !== l; ++a) {
                            var c = r[a];
                            if (isNaN(c)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
                                break
                            }
                        }
                    }
                    return e
                },
                optimize: function() {
                    for (var e = this.times, t = this.values, n = this.getValueSize(), r = 2302 === this.getInterpolation(), i = 1, o = e.length - 1, a = 1; a < o; ++a) {
                        var s = !1,
                            l = e[a];
                        if (l !== e[a + 1] && (1 !== a || l !== l[0]))
                            if (r) s = !0;
                            else
                                for (var c = a * n, u = c - n, h = c + n, d = 0; d !== n; ++d) {
                                    var p = t[c + d];
                                    if (p !== t[u + d] || p !== t[h + d]) {
                                        s = !0;
                                        break
                                    }
                                }
                            if (s) {
                                if (a !== i) {
                                    e[i] = e[a];
                                    var f = a * n,
                                        m = i * n;
                                    for (d = 0; d !== n; ++d) t[m + d] = t[f + d]
                                }++i
                            }
                    }
                    if (0 < o) {
                        e[i] = e[o];
                        for (f = o * n, m = i * n, d = 0; d !== n; ++d) t[m + d] = t[f + d];
                        ++i
                    }
                    return i !== e.length && (this.times = Kl.arraySlice(e, 0, i), this.values = Kl.arraySlice(t, 0, i * n)), this
                },
                clone: function() {
                    var e = Kl.arraySlice(this.times, 0),
                        t = Kl.arraySlice(this.values, 0),
                        n = new this.constructor(this.name, e, t);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }), nc.prototype = Object.assign(Object.create(tc.prototype), {
                constructor: nc,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), rc.prototype = Object.assign(Object.create(tc.prototype), {
                constructor: rc,
                ValueTypeName: "color"
            }), ic.prototype = Object.assign(Object.create(tc.prototype), {
                constructor: ic,
                ValueTypeName: "number"
            }), oc.prototype = Object.assign(Object.create(Jl.prototype), {
                constructor: oc,
                interpolate_: function(e, t, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, l = (n - t) / (r - t), c = s + a; s !== c; s += 4) At.slerpFlat(i, 0, o, s - a, o, s, l);
                    return i
                }
            }), ac.prototype = Object.assign(Object.create(tc.prototype), {
                constructor: ac,
                ValueTypeName: "quaternion",
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodLinear: function(e) {
                    return new oc(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), sc.prototype = Object.assign(Object.create(tc.prototype), {
                constructor: sc,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), lc.prototype = Object.assign(Object.create(tc.prototype), {
                constructor: lc,
                ValueTypeName: "vector"
            }), Object.assign(cc, {
                parse: function(e) {
                    for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, o = n.length; i !== o; ++i) t.push(uc(n[i]).scale(r));
                    return new cc(e.name, e.duration, t)
                },
                toJSON: function(e) {
                    for (var t = [], n = e.tracks, r = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid
                        }, i = 0, o = n.length; i !== o; ++i) t.push(tc.toJSON(n[i]));
                    return r
                },
                CreateFromMorphTargetSequence: function(e, t, n, r) {
                    for (var i = t.length, o = [], a = 0; a < i; a++) {
                        var s = [],
                            l = [];
                        s.push((a + i - 1) % i, a, (a + 1) % i), l.push(0, 1, 0);
                        var c = Kl.getKeyframeOrder(s);
                        s = Kl.sortedArray(s, 1, c), l = Kl.sortedArray(l, 1, c), r || 0 !== s[0] || (s.push(i), l.push(l[0])), o.push(new ic(".morphTargetInfluences[" + t[a].name + "]", s, l).scale(1 / n))
                    }
                    return new cc(e, -1, o)
                },
                findByName: function(e, t) {
                    var n = e;
                    if (!Array.isArray(e)) {
                        var r = e;
                        n = r.geometry && r.geometry.animations || r.animations
                    }
                    for (var i = 0; i < n.length; i++)
                        if (n[i].name === t) return n[i];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(e, t, n) {
                    for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                        var s = e[o],
                            l = s.name.match(i);
                        if (l && 1 < l.length) {
                            var c = r[h = l[1]];
                            c || (r[h] = c = []), c.push(s)
                        }
                    }
                    var u = [];
                    for (var h in r) u.push(cc.CreateFromMorphTargetSequence(h, r[h], t, n));
                    return u
                },
                parseAnimation: function(e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    for (var n = function(e, t, n, r, i) {
                            if (0 !== n.length) {
                                var o = [],
                                    a = [];
                                Kl.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new e(t, o, a))
                            }
                        }, r = [], i = e.name || "default", o = e.length || -1, a = e.fps || 30, s = e.hierarchy || [], l = 0; l < s.length; l++) {
                        var c = s[l].keys;
                        if (c && 0 !== c.length)
                            if (c[0].morphTargets) {
                                for (var u = {}, h = 0; h < c.length; h++)
                                    if (c[h].morphTargets)
                                        for (var d = 0; d < c[h].morphTargets.length; d++) u[c[h].morphTargets[d]] = -1;
                                for (var p in u) {
                                    var f = [],
                                        m = [];
                                    for (d = 0; d !== c[h].morphTargets.length; ++d) {
                                        var v = c[h];
                                        f.push(v.time), m.push(v.morphTarget === p ? 1 : 0)
                                    }
                                    r.push(new ic(".morphTargetInfluence[" + p + "]", f, m))
                                }
                                o = u.length * (a || 1)
                            } else {
                                var g = ".bones[" + t[l].name + "]";
                                n(lc, g + ".position", c, "pos", r), n(ac, g + ".quaternion", c, "rot", r), n(lc, g + ".scale", c, "scl", r)
                            }
                    }
                    return 0 === r.length ? null : new cc(i, o, r)
                }
            }), Object.assign(cc.prototype, {
                resetDuration: function() {
                    for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                        var r = this.tracks[t];
                        e = Math.max(e, r.times[r.times.length - 1])
                    }
                    return this.duration = e, this
                },
                trim: function() {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                },
                validate: function() {
                    for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                },
                optimize: function() {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                },
                clone: function() {
                    for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new cc(this.name, this.duration, e)
                }
            });
            var hc = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function(e) {
                    if (!1 !== this.enabled) return this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function dc(e, t, n) {
                var r = this,
                    i = !1,
                    o = 0,
                    a = 0,
                    s = void 0,
                    l = [];
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                    a++, !1 === i && void 0 !== r.onStart && r.onStart(e, o, a), i = !0
                }, this.itemEnd = function(e) {
                    o++, void 0 !== r.onProgress && r.onProgress(e, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function(e) {
                    void 0 !== r.onError && r.onError(e)
                }, this.resolveURL = function(e) {
                    return s ? s(e) : e
                }, this.setURLModifier = function(e) {
                    return s = e, this
                }, this.addHandler = function(e, t) {
                    return l.push(e, t), this
                }, this.removeHandler = function(e) {
                    var t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2), this
                }, this.getHandler = function(e) {
                    for (var t = 0, n = l.length; t < n; t += 2) {
                        var r = l[t],
                            i = l[t + 1];
                        if (r.global && (r.lastIndex = 0), r.test(e)) return i
                    }
                    return null
                }
            }
            var pc = new dc;

            function fc(e) {
                this.manager = void 0 !== e ? e : pc, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = ""
            }
            Object.assign(fc.prototype, {
                load: function() {},
                parse: function() {},
                setCrossOrigin: function(e) {
                    return this.crossOrigin = e, this
                },
                setPath: function(e) {
                    return this.path = e, this
                },
                setResourcePath: function(e) {
                    return this.resourcePath = e, this
                }
            });
            var mc = {};

            function vc(e) {
                fc.call(this, e)
            }

            function gc(e) {
                fc.call(this, e)
            }

            function yc(e) {
                fc.call(this, e)
            }

            function xc(e) {
                fc.call(this, e)
            }

            function bc(e) {
                fc.call(this, e)
            }

            function _c(e) {
                fc.call(this, e)
            }

            function wc(e) {
                fc.call(this, e)
            }

            function Sc() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function Mc(e, t, n, r, i, o, a, s) {
                Sc.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
            }

            function Tc(e, t, n, r, i, o) {
                Mc.call(this, e, t, n, n, r, i, o), this.type = "ArcCurve"
            }

            function Ec() {
                var i = 0,
                    o = 0,
                    a = 0,
                    s = 0;

                function c(e, t, n, r) {
                    a = -3 * (i = e) + 3 * t - 2 * (o = n) - r, s = 2 * e - 2 * t + n + r
                }
                return {
                    initCatmullRom: function(e, t, n, r, i) {
                        c(t, n, i * (n - e), i * (r - t))
                    },
                    initNonuniformCatmullRom: function(e, t, n, r, i, o, a) {
                        var s = (t - e) / i - (n - e) / (i + o) + (n - t) / o,
                            l = (n - t) / o - (r - t) / (o + a) + (r - n) / a;
                        c(t, n, s *= o, l *= o)
                    },
                    calc: function(e) {
                        var t = e * e;
                        return i + o * e + a * t + s * (t * e)
                    }
                }
            }
            vc.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: vc,
                load: function(a, e, t, n) {
                    void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
                    var s = this,
                        r = hc.get(a);
                    if (void 0 !== r) return s.manager.itemStart(a), setTimeout(function() {
                        e && e(r), s.manager.itemEnd(a)
                    }, 0), r;
                    if (void 0 === mc[a]) {
                        var i = a.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (i) {
                            var o = i[1],
                                l = !!i[2],
                                c = i[3];
                            c = decodeURIComponent(c), l && (c = atob(c));
                            try {
                                var u, h = (this.responseType || "").toLowerCase();
                                switch (h) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var d = new Uint8Array(c.length), p = 0; p < c.length; p++) d[p] = c.charCodeAt(p);
                                        u = "blob" === h ? new Blob([d.buffer], {
                                            type: o
                                        }) : d.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        u = f.parseFromString(c, o);
                                        break;
                                    case "json":
                                        u = JSON.parse(c);
                                        break;
                                    default:
                                        u = c
                                }
                                setTimeout(function() {
                                    e && e(u), s.manager.itemEnd(a)
                                }, 0)
                            } catch (e) {
                                setTimeout(function() {
                                    n && n(e), s.manager.itemError(a), s.manager.itemEnd(a)
                                }, 0)
                            }
                        } else {
                            mc[a] = [], mc[a].push({
                                onLoad: e,
                                onProgress: t,
                                onError: n
                            });
                            var m = new XMLHttpRequest;
                            for (var v in m.open("GET", a, !0), m.addEventListener("load", function(e) {
                                    var t = this.response,
                                        n = mc[a];
                                    if (delete mc[a], 200 === this.status || 0 === this.status) {
                                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), hc.add(a, t);
                                        for (var r = 0, i = n.length; r < i; r++) {
                                            (o = n[r]).onLoad && o.onLoad(t)
                                        }
                                        s.manager.itemEnd(a)
                                    } else {
                                        for (r = 0, i = n.length; r < i; r++) {
                                            var o;
                                            (o = n[r]).onError && o.onError(e)
                                        }
                                        s.manager.itemError(a), s.manager.itemEnd(a)
                                    }
                                }, !1), m.addEventListener("progress", function(e) {
                                    for (var t = mc[a], n = 0, r = t.length; n < r; n++) {
                                        var i = t[n];
                                        i.onProgress && i.onProgress(e)
                                    }
                                }, !1), m.addEventListener("error", function(e) {
                                    var t = mc[a];
                                    delete mc[a];
                                    for (var n = 0, r = t.length; n < r; n++) {
                                        var i = t[n];
                                        i.onError && i.onError(e)
                                    }
                                    s.manager.itemError(a), s.manager.itemEnd(a)
                                }, !1), m.addEventListener("abort", function(e) {
                                    var t = mc[a];
                                    delete mc[a];
                                    for (var n = 0, r = t.length; n < r; n++) {
                                        var i = t[n];
                                        i.onError && i.onError(e)
                                    }
                                    s.manager.itemError(a), s.manager.itemEnd(a)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                            m.send(null)
                        }
                        return s.manager.itemStart(a), m
                    }
                    mc[a].push({
                        onLoad: e,
                        onProgress: t,
                        onError: n
                    })
                },
                setResponseType: function(e) {
                    return this.responseType = e, this
                },
                setWithCredentials: function(e) {
                    return this.withCredentials = e, this
                },
                setMimeType: function(e) {
                    return this.mimeType = e, this
                },
                setRequestHeader: function(e) {
                    return this.requestHeader = e, this
                }
            }), gc.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: gc,
                load: function(e, t, n, r) {
                    var i = this,
                        o = new vc(i.manager);
                    o.setPath(i.path), o.load(e, function(e) {
                        t(i.parse(JSON.parse(e)))
                    }, n, r)
                },
                parse: function(e) {
                    for (var t = [], n = 0; n < e.length; n++) {
                        var r = cc.parse(e[n]);
                        t.push(r)
                    }
                    return t
                }
            }), yc.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: yc,
                load: function(e, o, t, r) {
                    var a = this,
                        s = [],
                        l = new Ms;
                    l.image = s;
                    var i = new vc(this.manager);

                    function n(n) {
                        i.load(e[n], function(e) {
                            var t = a.parse(e, !0);
                            s[n] = {
                                width: t.width,
                                height: t.height,
                                format: t.format,
                                mipmaps: t.mipmaps
                            }, 6 === (c += 1) && (1 === t.mipmapCount && (l.minFilter = He), l.format = t.format, l.needsUpdate = !0, o && o(l))
                        }, t, r)
                    }
                    if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(e))
                        for (var c = 0, u = 0, h = e.length; u < h; ++u) n(u);
                    else i.load(e, function(e) {
                        var t = a.parse(e, !0);
                        if (t.isCubemap)
                            for (var n = t.mipmaps.length / t.mipmapCount, r = 0; r < n; r++) {
                                s[r] = {
                                    mipmaps: []
                                };
                                for (var i = 0; i < t.mipmapCount; i++) s[r].mipmaps.push(t.mipmaps[r * t.mipmapCount + i]), s[r].format = t.format, s[r].width = t.width, s[r].height = t.height
                            } else l.image.width = t.width, l.image.height = t.height, l.mipmaps = t.mipmaps;
                        1 === t.mipmapCount && (l.minFilter = He), l.format = t.format, l.needsUpdate = !0, o && o(l)
                    }, t, r);
                    return l
                }
            }), xc.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: xc,
                load: function(e, n, t, r) {
                    var i = this,
                        o = new gi,
                        a = new vc(this.manager);
                    return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(e, function(e) {
                        var t = i.parse(e);
                        t && (void 0 !== t.image ? o.image = t.image : void 0 !== t.data && (o.image.width = t.width, o.image.height = t.height, o.image.data = t.data), o.wrapS = void 0 !== t.wrapS ? t.wrapS : ke, o.wrapT = void 0 !== t.wrapT ? t.wrapT : ke, o.magFilter = void 0 !== t.magFilter ? t.magFilter : He, o.minFilter = void 0 !== t.minFilter ? t.minFilter : He, o.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (o.format = t.format), void 0 !== t.type && (o.type = t.type), void 0 !== t.mipmaps && (o.mipmaps = t.mipmaps, o.minFilter = Ve), 1 === t.mipmapCount && (o.minFilter = He), o.needsUpdate = !0, n && n(o, t))
                    }, t, r), o
                }
            }), bc.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: bc,
                load: function(t, e, n, r) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var i = this,
                        o = hc.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function() {
                        e && e(o), i.manager.itemEnd(t)
                    }, 0), o;
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", l, !1), hc.add(t, this), e && e(this), i.manager.itemEnd(t)
                    }

                    function l(e) {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", l, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                    }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(t), a.src = t, a
                }
            }), _c.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: _c,
                load: function(e, n, t, r) {
                    var i = new Bi,
                        o = new bc(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;

                    function s(t) {
                        o.load(e[t], function(e) {
                            i.images[t] = e, 6 === ++a && (i.needsUpdate = !0, n && n(i))
                        }, void 0, r)
                    }
                    for (var l = 0; l < e.length; ++l) s(l);
                    return i
                }
            }), wc.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: wc,
                load: function(n, r, e, t) {
                    var i = new Ft,
                        o = new bc(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(n, function(e) {
                        i.image = e;
                        var t = 0 < n.search(/\.jpe?g($|\?)/i) || 0 === n.search(/^data\:image\/jpeg/);
                        i.format = t ? Ke : Je, i.needsUpdate = !0, void 0 !== r && r(i)
                    }, e, t), i
                }
            }), Object.assign(Sc.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(e, t) {
                    var n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                },
                getPoints: function(e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                },
                getSpacedPoints: function(e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                },
                getLength: function() {
                    var e = this.getLengths();
                    return e[e.length - 1]
                },
                getLengths: function(e) {
                    if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var t, n, r = [],
                        i = this.getPoint(0),
                        o = 0;
                    for (r.push(0), n = 1; n <= e; n++) o += (t = this.getPoint(n / e)).distanceTo(i), r.push(o), i = t;
                    return this.cacheArcLengths = r
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(e, t) {
                    var n, r = this.getLengths(),
                        i = 0,
                        o = r.length;
                    n = t || e * r[o - 1];
                    for (var a, s = 0, l = o - 1; s <= l;)
                        if ((a = r[i = Math.floor(s + (l - s) / 2)] - n) < 0) s = i + 1;
                        else {
                            if (!(0 < a)) {
                                l = i;
                                break
                            }
                            l = i - 1
                        }
                    if (r[i = l] === n) return i / (o - 1);
                    var c = r[i];
                    return (i + (n - c) / (r[i + 1] - c)) / (o - 1)
                },
                getTangent: function(e) {
                    var t = e - 1e-4,
                        n = e + 1e-4;
                    t < 0 && (t = 0), 1 < n && (n = 1);
                    var r = this.getPoint(t);
                    return this.getPoint(n).clone().sub(r).normalize()
                },
                getTangentAt: function(e) {
                    var t = this.getUtoTmapping(e);
                    return this.getTangent(t)
                },
                computeFrenetFrames: function(e, t) {
                    var n, r, i, o = new Ot,
                        a = [],
                        s = [],
                        l = [],
                        c = new Ot,
                        u = new Zt;
                    for (n = 0; n <= e; n++) r = n / e, a[n] = this.getTangentAt(r), a[n].normalize();
                    s[0] = new Ot, l[0] = new Ot;
                    var h = Number.MAX_VALUE,
                        d = Math.abs(a[0].x),
                        p = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (d <= h && (h = d, o.set(1, 0, 0)), p <= h && (h = p, o.set(0, 1, 0)), f <= h && o.set(0, 0, 1), c.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], c), l[0].crossVectors(a[0], s[0]), n = 1; n <= e; n++) s[n] = s[n - 1].clone(), l[n] = l[n - 1].clone(), c.crossVectors(a[n - 1], a[n]), c.length() > Number.EPSILON && (c.normalize(), i = Math.acos(Ct.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(u.makeRotationAxis(c, i))), l[n].crossVectors(a[n], s[n]);
                    if (!0 === t)
                        for (i = Math.acos(Ct.clamp(s[0].dot(s[e]), -1, 1)), i /= e, 0 < a[0].dot(c.crossVectors(s[0], s[e])) && (i = -i), n = 1; n <= e; n++) s[n].applyMatrix4(u.makeRotationAxis(a[n], i * n)), l[n].crossVectors(a[n], s[n]);
                    return {
                        tangents: a,
                        normals: s,
                        binormals: l
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                },
                toJSON: function() {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                },
                fromJSON: function(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }), ((Mc.prototype = Object.create(Sc.prototype)).constructor = Mc).prototype.isEllipseCurve = !0, Mc.prototype.getPoint = function(e, t) {
                for (var n = t || new Lt, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
                for (; r < i;) i -= r;
                i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
                var a = this.aStartAngle + e * i,
                    s = this.aX + this.xRadius * Math.cos(a),
                    l = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var c = Math.cos(this.aRotation),
                        u = Math.sin(this.aRotation),
                        h = s - this.aX,
                        d = l - this.aY;
                    s = h * c - d * u + this.aX, l = h * u + d * c + this.aY
                }
                return n.set(s, l)
            }, Mc.prototype.copy = function(e) {
                return Sc.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, Mc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
            }, Mc.prototype.fromJSON = function(e) {
                return Sc.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, ((Tc.prototype = Object.create(Mc.prototype)).constructor = Tc).prototype.isArcCurve = !0;
            var Cc = new Ot,
                Lc = new Ec,
                Ac = new Ec,
                Rc = new Ec;

            function Pc(e, t, n, r) {
                Sc.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = r || .5
            }

            function Oc(e, t, n, r, i) {
                var o = .5 * (r - t),
                    a = .5 * (i - n),
                    s = e * e;
                return (2 * n - 2 * r + o + a) * (e * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * e + n
            }

            function Ic(e, t, n, r) {
                return function(e, t) {
                    var n = 1 - e;
                    return n * n * t
                }(e, t) + function(e, t) {
                    return 2 * (1 - e) * e * t
                }(e, n) + function(e, t) {
                    return e * e * t
                }(e, r)
            }

            function Dc(e, t, n, r, i) {
                return function(e, t) {
                    var n = 1 - e;
                    return n * n * n * t
                }(e, t) + function(e, t) {
                    var n = 1 - e;
                    return 3 * n * n * e * t
                }(e, n) + function(e, t) {
                    return 3 * (1 - e) * e * e * t
                }(e, r) + function(e, t) {
                    return e * e * e * t
                }(e, i)
            }

            function Nc(e, t, n, r) {
                Sc.call(this), this.type = "CubicBezierCurve", this.v0 = e || new Lt, this.v1 = t || new Lt, this.v2 = n || new Lt, this.v3 = r || new Lt
            }

            function kc(e, t, n, r) {
                Sc.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new Ot, this.v1 = t || new Ot, this.v2 = n || new Ot, this.v3 = r || new Ot
            }

            function zc(e, t) {
                Sc.call(this), this.type = "LineCurve", this.v1 = e || new Lt, this.v2 = t || new Lt
            }

            function Fc(e, t) {
                Sc.call(this), this.type = "LineCurve3", this.v1 = e || new Ot, this.v2 = t || new Ot
            }

            function Bc(e, t, n) {
                Sc.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new Lt, this.v1 = t || new Lt, this.v2 = n || new Lt
            }

            function Uc(e, t, n) {
                Sc.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new Ot, this.v1 = t || new Ot, this.v2 = n || new Ot
            }

            function Hc(e) {
                Sc.call(this), this.type = "SplineCurve", this.points = e || []
            }((Pc.prototype = Object.create(Sc.prototype)).constructor = Pc).prototype.isCatmullRomCurve3 = !0, Pc.prototype.getPoint = function(e, t) {
                var n, r, i, o, a = t || new Ot,
                    s = this.points,
                    l = s.length,
                    c = (l - (this.closed ? 0 : 1)) * e,
                    u = Math.floor(c),
                    h = c - u;
                if (this.closed ? u += 0 < u ? 0 : (Math.floor(Math.abs(u) / l) + 1) * l : 0 === h && u === l - 1 && (u = l - 2, h = 1), n = this.closed || 0 < u ? s[(u - 1) % l] : (Cc.subVectors(s[0], s[1]).add(s[0]), Cc), r = s[u % l], i = s[(u + 1) % l], o = this.closed || u + 2 < l ? s[(u + 2) % l] : (Cc.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]), Cc), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var d = "chordal" === this.curveType ? .5 : .25,
                        p = Math.pow(n.distanceToSquared(r), d),
                        f = Math.pow(r.distanceToSquared(i), d),
                        m = Math.pow(i.distanceToSquared(o), d);
                    f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), Lc.initNonuniformCatmullRom(n.x, r.x, i.x, o.x, p, f, m), Ac.initNonuniformCatmullRom(n.y, r.y, i.y, o.y, p, f, m), Rc.initNonuniformCatmullRom(n.z, r.z, i.z, o.z, p, f, m)
                } else "catmullrom" === this.curveType && (Lc.initCatmullRom(n.x, r.x, i.x, o.x, this.tension), Ac.initCatmullRom(n.y, r.y, i.y, o.y, this.tension), Rc.initCatmullRom(n.z, r.z, i.z, o.z, this.tension));
                return a.set(Lc.calc(h), Ac.calc(h), Rc.calc(h)), a
            }, Pc.prototype.copy = function(e) {
                Sc.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push(r.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, Pc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var r = this.points[t];
                    e.points.push(r.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }, Pc.prototype.fromJSON = function(e) {
                Sc.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push((new Ot).fromArray(r))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, ((Nc.prototype = Object.create(Sc.prototype)).constructor = Nc).prototype.isCubicBezierCurve = !0, Nc.prototype.getPoint = function(e, t) {
                var n = t || new Lt,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(Dc(e, r.x, i.x, o.x, a.x), Dc(e, r.y, i.y, o.y, a.y)), n
            }, Nc.prototype.copy = function(e) {
                return Sc.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, Nc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, Nc.prototype.fromJSON = function(e) {
                return Sc.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, ((kc.prototype = Object.create(Sc.prototype)).constructor = kc).prototype.isCubicBezierCurve3 = !0, kc.prototype.getPoint = function(e, t) {
                var n = t || new Ot,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(Dc(e, r.x, i.x, o.x, a.x), Dc(e, r.y, i.y, o.y, a.y), Dc(e, r.z, i.z, o.z, a.z)), n
            }, kc.prototype.copy = function(e) {
                return Sc.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, kc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, kc.prototype.fromJSON = function(e) {
                return Sc.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, ((zc.prototype = Object.create(Sc.prototype)).constructor = zc).prototype.isLineCurve = !0, zc.prototype.getPoint = function(e, t) {
                var n = t || new Lt;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }, zc.prototype.getPointAt = function(e, t) {
                return this.getPoint(e, t)
            }, zc.prototype.getTangent = function() {
                return this.v2.clone().sub(this.v1).normalize()
            }, zc.prototype.copy = function(e) {
                return Sc.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, zc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, zc.prototype.fromJSON = function(e) {
                return Sc.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ((Fc.prototype = Object.create(Sc.prototype)).constructor = Fc).prototype.isLineCurve3 = !0, Fc.prototype.getPoint = function(e, t) {
                var n = t || new Ot;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }, Fc.prototype.getPointAt = function(e, t) {
                return this.getPoint(e, t)
            }, Fc.prototype.copy = function(e) {
                return Sc.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, Fc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, Fc.prototype.fromJSON = function(e) {
                return Sc.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ((Bc.prototype = Object.create(Sc.prototype)).constructor = Bc).prototype.isQuadraticBezierCurve = !0, Bc.prototype.getPoint = function(e, t) {
                var n = t || new Lt,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(Ic(e, r.x, i.x, o.x), Ic(e, r.y, i.y, o.y)), n
            }, Bc.prototype.copy = function(e) {
                return Sc.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, Bc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, Bc.prototype.fromJSON = function(e) {
                return Sc.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ((Uc.prototype = Object.create(Sc.prototype)).constructor = Uc).prototype.isQuadraticBezierCurve3 = !0, Uc.prototype.getPoint = function(e, t) {
                var n = t || new Ot,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(Ic(e, r.x, i.x, o.x), Ic(e, r.y, i.y, o.y), Ic(e, r.z, i.z, o.z)), n
            }, Uc.prototype.copy = function(e) {
                return Sc.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, Uc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, Uc.prototype.fromJSON = function(e) {
                return Sc.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ((Hc.prototype = Object.create(Sc.prototype)).constructor = Hc).prototype.isSplineCurve = !0, Hc.prototype.getPoint = function(e, t) {
                var n = t || new Lt,
                    r = this.points,
                    i = (r.length - 1) * e,
                    o = Math.floor(i),
                    a = i - o,
                    s = r[0 === o ? o : o - 1],
                    l = r[o],
                    c = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    u = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return n.set(Oc(a, s.x, l.x, c.x, u.x), Oc(a, s.y, l.y, c.y, u.y)), n
            }, Hc.prototype.copy = function(e) {
                Sc.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push(r.clone())
                }
                return this
            }, Hc.prototype.toJSON = function() {
                var e = Sc.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var r = this.points[t];
                    e.points.push(r.toArray())
                }
                return e
            }, Hc.prototype.fromJSON = function(e) {
                Sc.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push((new Lt).fromArray(r))
                }
                return this
            };
            var Gc = Object.freeze({
                __proto__: null,
                ArcCurve: Tc,
                CatmullRomCurve3: Pc,
                CubicBezierCurve: Nc,
                CubicBezierCurve3: kc,
                EllipseCurve: Mc,
                LineCurve: zc,
                LineCurve3: Fc,
                QuadraticBezierCurve: Bc,
                QuadraticBezierCurve3: Uc,
                SplineCurve: Hc
            });

            function Vc() {
                Sc.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function Wc(e) {
                Vc.call(this), this.type = "Path", this.currentPoint = new Lt, e && this.setFromPoints(e)
            }

            function jc(e) {
                Wc.call(this, e), this.uuid = Ct.generateUUID(), this.type = "Shape", this.holes = []
            }

            function qc(e, t) {
                fn.call(this), this.type = "Light", this.color = new or(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
            }

            function Xc(e, t, n) {
                qc.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(fn.DefaultUp), this.updateMatrix(), this.groundColor = new or(t)
            }

            function Yc(e) {
                this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new Lt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Zt, this._frustum = new bi, this._frameExtents = new Lt(1, 1), this._viewportCount = 1, this._viewports = [new Bt(0, 0, 1, 1)]
            }

            function Zc() {
                Yc.call(this, new fi(50, 1, .5, 500))
            }

            function Kc(e, t, n, r, i, o) {
                qc.call(this, e, t), this.type = "SpotLight", this.position.copy(fn.DefaultUp), this.updateMatrix(), this.target = new fn, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(e) {
                        this.intensity = e / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Zc
            }

            function Jc() {
                Yc.call(this, new fi(90, 1, .5, 500)), this._frameExtents = new Lt(4, 2), this._viewportCount = 6, this._viewports = [new Bt(2, 1, 1, 1), new Bt(0, 1, 1, 1), new Bt(3, 1, 1, 1), new Bt(1, 1, 1, 1), new Bt(3, 0, 1, 1), new Bt(1, 0, 1, 1)], this._cubeDirections = [new Ot(1, 0, 0), new Ot(-1, 0, 0), new Ot(0, 0, 1), new Ot(0, 0, -1), new Ot(0, 1, 0), new Ot(0, -1, 0)], this._cubeUps = [new Ot(0, 1, 0), new Ot(0, 1, 0), new Ot(0, 1, 0), new Ot(0, 1, 0), new Ot(0, 0, 1), new Ot(0, 0, -1)]
            }

            function Qc(e, t, n, r) {
                qc.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new Jc
            }

            function $c(e, t, n, r, i, o) {
                pi.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
            }

            function eu() {
                Yc.call(this, new $c(-5, 5, 5, -5, .5, 500))
            }

            function tu(e, t) {
                qc.call(this, e, t), this.type = "DirectionalLight", this.position.copy(fn.DefaultUp), this.updateMatrix(), this.target = new fn, this.shadow = new eu
            }

            function nu(e, t) {
                qc.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
            }

            function ru(e, t, n, r) {
                qc.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
            }

            function iu(e) {
                fc.call(this, e), this.textures = {}
            }
            Vc.prototype = Object.assign(Object.create(Sc.prototype), {
                constructor: Vc,
                add: function(e) {
                    this.curves.push(e)
                },
                closePath: function() {
                    var e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new zc(t, e))
                },
                getPoint: function(e) {
                    for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                        if (n[r] >= t) {
                            var i = n[r] - t,
                                o = this.curves[r],
                                a = o.getLength(),
                                s = 0 === a ? 0 : 1 - i / a;
                            return o.getPointAt(s)
                        }
                        r++
                    }
                    return null
                },
                getLength: function() {
                    var e = this.getCurveLengths();
                    return e[e.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
                    return this.cacheLengths = e
                },
                getSpacedPoints: function(e) {
                    void 0 === e && (e = 40);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                },
                getPoints: function(e) {
                    e = e || 12;
                    for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)
                        for (var o = i[r], a = o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), l = 0; l < s.length; l++) {
                            var c = s[l];
                            t && t.equals(c) || (n.push(c), t = c)
                        }
                    return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function(e) {
                    Sc.prototype.copy.call(this, e), this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var r = e.curves[t];
                        this.curves.push(r.clone())
                    }
                    return this.autoClose = e.autoClose, this
                },
                toJSON: function() {
                    var e = Sc.prototype.toJSON.call(this);
                    e.autoClose = this.autoClose, e.curves = [];
                    for (var t = 0, n = this.curves.length; t < n; t++) {
                        var r = this.curves[t];
                        e.curves.push(r.toJSON())
                    }
                    return e
                },
                fromJSON: function(e) {
                    Sc.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var r = e.curves[t];
                        this.curves.push((new Gc[r.type]).fromJSON(r))
                    }
                    return this
                }
            }), Wc.prototype = Object.assign(Object.create(Vc.prototype), {
                constructor: Wc,
                setFromPoints: function(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                    return this
                },
                moveTo: function(e, t) {
                    return this.currentPoint.set(e, t), this
                },
                lineTo: function(e, t) {
                    var n = new zc(this.currentPoint.clone(), new Lt(e, t));
                    return this.curves.push(n), this.currentPoint.set(e, t), this
                },
                quadraticCurveTo: function(e, t, n, r) {
                    var i = new Bc(this.currentPoint.clone(), new Lt(e, t), new Lt(n, r));
                    return this.curves.push(i), this.currentPoint.set(n, r), this
                },
                bezierCurveTo: function(e, t, n, r, i, o) {
                    var a = new Nc(this.currentPoint.clone(), new Lt(e, t), new Lt(n, r), new Lt(i, o));
                    return this.curves.push(a), this.currentPoint.set(i, o), this
                },
                splineThru: function(e) {
                    var t = new Hc([this.currentPoint.clone()].concat(e));
                    return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
                },
                arc: function(e, t, n, r, i, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    return this.absarc(e + a, t + s, n, r, i, o), this
                },
                absarc: function(e, t, n, r, i, o) {
                    return this.absellipse(e, t, n, n, r, i, o), this
                },
                ellipse: function(e, t, n, r, i, o, a, s) {
                    var l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absellipse(e + l, t + c, n, r, i, o, a, s), this
                },
                absellipse: function(e, t, n, r, i, o, a, s) {
                    var l = new Mc(e, t, n, r, i, o, a, s);
                    if (0 < this.curves.length) {
                        var c = l.getPoint(0);
                        c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
                    }
                    this.curves.push(l);
                    var u = l.getPoint(1);
                    return this.currentPoint.copy(u), this
                },
                copy: function(e) {
                    return Vc.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
                },
                toJSON: function() {
                    var e = Vc.prototype.toJSON.call(this);
                    return e.currentPoint = this.currentPoint.toArray(), e
                },
                fromJSON: function(e) {
                    return Vc.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }), jc.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: jc,
                getPointsHoles: function(e) {
                    for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                },
                extractPoints: function(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                },
                copy: function(e) {
                    Wc.prototype.copy.call(this, e), this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var r = e.holes[t];
                        this.holes.push(r.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var e = Wc.prototype.toJSON.call(this);
                    e.uuid = this.uuid, e.holes = [];
                    for (var t = 0, n = this.holes.length; t < n; t++) {
                        var r = this.holes[t];
                        e.holes.push(r.toJSON())
                    }
                    return e
                },
                fromJSON: function(e) {
                    Wc.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var r = e.holes[t];
                        this.holes.push((new Wc).fromJSON(r))
                    }
                    return this
                }
            }), qc.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: qc,
                isLight: !0,
                copy: function(e) {
                    return fn.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
                },
                toJSON: function(e) {
                    var t = fn.prototype.toJSON.call(this, e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }), Xc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Xc,
                isHemisphereLight: !0,
                copy: function(e) {
                    return qc.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
                }
            }), Object.assign(Yc.prototype, {
                _projScreenMatrix: new Zt,
                _lightPositionWorld: new Ot,
                _lookTarget: new Ot,
                getViewportCount: function() {
                    return this._viewportCount
                },
                getFrustum: function() {
                    return this._frustum
                },
                updateMatrices: function(e) {
                    var t = this.camera,
                        n = this.matrix,
                        r = this._projScreenMatrix,
                        i = this._lookTarget,
                        o = this._lightPositionWorld;
                    o.setFromMatrixPosition(e.matrixWorld), t.position.copy(o), i.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(i), t.updateMatrixWorld(), r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
                },
                getViewport: function(e) {
                    return this._viewports[e]
                },
                getFrameExtents: function() {
                    return this._frameExtents
                },
                copy: function(e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }), Zc.prototype = Object.assign(Object.create(Yc.prototype), {
                constructor: Zc,
                isSpotLightShadow: !0,
                updateMatrices: function(e) {
                    var t = this.camera,
                        n = 2 * Ct.RAD2DEG * e.angle,
                        r = this.mapSize.width / this.mapSize.height,
                        i = e.distance || t.far;
                    n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), Yc.prototype.updateMatrices.call(this, e)
                }
            }), Kc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Kc,
                isSpotLight: !0,
                copy: function(e) {
                    return qc.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), Jc.prototype = Object.assign(Object.create(Yc.prototype), {
                constructor: Jc,
                isPointLightShadow: !0,
                updateMatrices: function(e, t) {
                    void 0 === t && (t = 0);
                    var n = this.camera,
                        r = this.matrix,
                        i = this._lightPositionWorld,
                        o = this._lookTarget,
                        a = this._projScreenMatrix;
                    i.setFromMatrixPosition(e.matrixWorld), n.position.copy(i), o.copy(n.position), o.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(o), n.updateMatrixWorld(), r.makeTranslation(-i.x, -i.y, -i.z), a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromMatrix(a)
                }
            }), Qc.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Qc,
                isPointLight: !0,
                copy: function(e) {
                    return qc.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }), $c.prototype = Object.assign(Object.create(pi.prototype), {
                constructor: $c,
                isOrthographicCamera: !0,
                copy: function(e, t) {
                    return pi.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                },
                setViewOffset: function(e, t, n, r, i, o) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        r = (this.top + this.bottom) / 2,
                        i = n - e,
                        o = n + e,
                        a = r + t,
                        s = r - t;
                    if (null !== this.view && this.view.enabled) {
                        var l = this.zoom / (this.view.width / this.view.fullWidth),
                            c = this.zoom / (this.view.height / this.view.fullHeight),
                            u = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        o = (i += u * (this.view.offsetX / l)) + u * (this.view.width / l), s = (a -= h * (this.view.offsetY / c)) - h * (this.view.height / c)
                    }
                    this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(e) {
                    var t = fn.prototype.toJSON.call(this, e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }), eu.prototype = Object.assign(Object.create(Yc.prototype), {
                constructor: eu,
                isDirectionalLightShadow: !0,
                updateMatrices: function(e) {
                    Yc.prototype.updateMatrices.call(this, e)
                }
            }), tu.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: tu,
                isDirectionalLight: !0,
                copy: function(e) {
                    return qc.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), nu.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: nu,
                isAmbientLight: !0
            }), ru.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: ru,
                isRectAreaLight: !0,
                copy: function(e) {
                    return qc.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
                },
                toJSON: function(e) {
                    var t = qc.prototype.toJSON.call(this, e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }), iu.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: iu,
                load: function(e, t, n, r) {
                    var i = this,
                        o = new vc(i.manager);
                    o.setPath(i.path), o.load(e, function(e) {
                        t(i.parse(JSON.parse(e)))
                    }, n, r)
                },
                parse: function(e) {
                    var t = this.textures;

                    function n(e) {
                        return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                    }
                    var r = new Zl[e.type];
                    if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = (new or).setHex(e.sheen)), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.vertexColors && (r.vertexColors = e.vertexColors), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (r.morphNormals = e.morphNormals), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.uniforms)
                        for (var i in e.uniforms) {
                            var o = e.uniforms[i];
                            switch (r.uniforms[i] = {}, o.type) {
                                case "t":
                                    r.uniforms[i].value = n(o.value);
                                    break;
                                case "c":
                                    r.uniforms[i].value = (new or).setHex(o.value);
                                    break;
                                case "v2":
                                    r.uniforms[i].value = (new Lt).fromArray(o.value);
                                    break;
                                case "v3":
                                    r.uniforms[i].value = (new Ot).fromArray(o.value);
                                    break;
                                case "v4":
                                    r.uniforms[i].value = (new Bt).fromArray(o.value);
                                    break;
                                case "m3":
                                    r.uniforms[i].value = (new Nt).fromArray(o.value);
                                case "m4":
                                    r.uniforms[i].value = (new Zt).fromArray(o.value);
                                    break;
                                default:
                                    r.uniforms[i].value = o.value
                            }
                        }
                    if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                        for (var a in e.extensions) r.extensions[a] = e.extensions[a];
                    if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap), r.transparent = !0), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                        var s = e.normalScale;
                        !1 === Array.isArray(s) && (s = [s, s]), r.normalScale = (new Lt).fromArray(s)
                    }
                    return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new Lt).fromArray(e.clearcoatNormalScale)), r
                },
                setTextures: function(e) {
                    return this.textures = e, this
                }
            });
            var ou = {
                decodeText: function(e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (e) {
                        return t
                    }
                },
                extractUrlBase: function(e) {
                    var t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.substr(0, t + 1)
                }
            };

            function au() {
                Ir.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function su(e, t, n, r) {
                "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), fr.call(this, e, t, n), this.meshPerAttribute = r || 1
            }

            function lu(e) {
                fc.call(this, e)
            }
            au.prototype = Object.assign(Object.create(Ir.prototype), {
                constructor: au,
                isInstancedBufferGeometry: !0,
                copy: function(e) {
                    return Ir.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var e = Ir.prototype.toJSON.call(this);
                    return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
                }
            }), su.prototype = Object.assign(Object.create(fr.prototype), {
                constructor: su,
                isInstancedBufferAttribute: !0,
                copy: function(e) {
                    return fr.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                },
                toJSON: function() {
                    var e = fr.prototype.toJSON.call(this);
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                }
            }), lu.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: lu,
                load: function(e, t, n, r) {
                    var i = this,
                        o = new vc(i.manager);
                    o.setPath(i.path), o.load(e, function(e) {
                        t(i.parse(JSON.parse(e)))
                    }, n, r)
                },
                parse: function(e) {
                    var t = e.isInstancedBufferGeometry ? new au : new Ir,
                        n = e.data.index;
                    if (void 0 !== n) {
                        var r = new cu[n.type](n.array);
                        t.setIndex(new fr(r, 1))
                    }
                    var i = e.data.attributes;
                    for (var o in i) {
                        var a = i[o],
                            s = (r = new cu[a.type](a.array), new(a.isInstancedBufferAttribute ? su : fr)(r, a.itemSize, a.normalized));
                        void 0 !== a.name && (s.name = a.name), t.setAttribute(o, s)
                    }
                    var l = e.data.morphAttributes;
                    if (l)
                        for (var o in l) {
                            for (var c = l[o], u = [], h = 0, d = c.length; h < d; h++) {
                                a = c[h], s = new fr(r = new cu[a.type](a.array), a.itemSize, a.normalized);
                                void 0 !== a.name && (s.name = a.name), u.push(s)
                            }
                            t.morphAttributes[o] = u
                        }
                    e.data.morphTargetsRelative && (t.morphTargetsRelative = !0);
                    var p = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== p) {
                        h = 0;
                        for (var f = p.length; h !== f; ++h) {
                            var m = p[h];
                            t.addGroup(m.start, m.count, m.materialIndex)
                        }
                    }
                    var v = e.data.boundingSphere;
                    if (void 0 !== v) {
                        var g = new Ot;
                        void 0 !== v.center && g.fromArray(v.center), t.boundingSphere = new On(g, v.radius)
                    }
                    return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
                }
            });
            var cu = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function uu(e) {
                fc.call(this, e)
            }
            uu.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: uu,
                load: function(r, i, e, o) {
                    var a = this,
                        t = "" === this.path ? ou.extractUrlBase(r) : this.path;
                    this.resourcePath = this.resourcePath || t;
                    var n = new vc(a.manager);
                    n.setPath(this.path), n.load(r, function(e) {
                        var t = null;
                        try {
                            t = JSON.parse(e)
                        } catch (e) {
                            return void 0 !== o && o(e), void console.error("THREE:ObjectLoader: Can't parse " + r + ".", e.message)
                        }
                        var n = t.metadata;
                        void 0 !== n && void 0 !== n.type && "geometry" !== n.type.toLowerCase() ? a.parse(t, i) : console.error("THREE.ObjectLoader: Can't load " + r)
                    }, e, o)
                },
                parse: function(e, t) {
                    var n = this.parseShape(e.shapes),
                        r = this.parseGeometries(e.geometries, n),
                        i = this.parseImages(e.images, function() {
                            void 0 !== t && t(s)
                        }),
                        o = this.parseTextures(e.textures, i),
                        a = this.parseMaterials(e.materials, o),
                        s = this.parseObject(e.object, r, a);
                    return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
                },
                parseShape: function(e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var n = 0, r = e.length; n < r; n++) {
                            var i = (new jc).fromJSON(e[n]);
                            t[i.uuid] = i
                        }
                    return t
                },
                parseGeometries: function(e, t) {
                    var n = {};
                    if (void 0 !== e)
                        for (var r = new lu, i = 0, o = e.length; i < o; i++) {
                            var a, s = e[i];
                            switch (s.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    a = new Fl[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    a = new Fl[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    a = new Fl[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    a = new Fl[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    a = new Fl[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    a = new Fl[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    a = new Fl[s.type](s.radius, s.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    a = new Fl[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    a = new Fl[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    a = new Fl[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    a = new Fl[s.type]((new Gc[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    a = new Fl[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    a = new Fl[s.type](s.vertices, s.indices, s.radius, s.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var l = [], c = 0, u = s.shapes.length; c < u; c++) {
                                        var h = t[s.shapes[c]];
                                        l.push(h)
                                    }
                                    a = new Fl[s.type](l, s.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (l = [], c = 0, u = s.shapes.length; c < u; c++) {
                                        h = t[s.shapes[c]];
                                        l.push(h)
                                    }
                                    var d = s.options.extrudePath;
                                    void 0 !== d && (s.options.extrudePath = (new Gc[d.type]).fromJSON(d)), a = new Fl[s.type](l, s.options);
                                    break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    a = r.parse(s);
                                    break;
                                case "Geometry":
                                    if ("THREE" in window && "LegacyJSONLoader" in THREE) a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry;
                                    else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                    continue
                            }
                            a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), n[s.uuid] = a
                        }
                    return n
                },
                parseMaterials: function(e, t) {
                    var n = {},
                        r = {};
                    if (void 0 !== e) {
                        var i = new iu;
                        i.setTextures(t);
                        for (var o = 0, a = e.length; o < a; o++) {
                            var s = e[o];
                            if ("MultiMaterial" === s.type) {
                                for (var l = [], c = 0; c < s.materials.length; c++) {
                                    var u = s.materials[c];
                                    void 0 === n[u.uuid] && (n[u.uuid] = i.parse(u)), l.push(n[u.uuid])
                                }
                                r[s.uuid] = l
                            } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                        }
                    }
                    return r
                },
                parseAnimations: function(e) {
                    for (var t = [], n = 0; n < e.length; n++) {
                        var r = e[n],
                            i = cc.parse(r);
                        void 0 !== r.uuid && (i.uuid = r.uuid), t.push(i)
                    }
                    return t
                },
                parseImages: function(e, t) {
                    var n = this,
                        r = {};

                    function i(e) {
                        return n.manager.itemStart(e), o.load(e, function() {
                            n.manager.itemEnd(e)
                        }, void 0, function() {
                            n.manager.itemError(e), n.manager.itemEnd(e)
                        })
                    }
                    if (void 0 !== e && 0 < e.length) {
                        var o = new bc(new dc(t));
                        o.setCrossOrigin(this.crossOrigin);
                        for (var a = 0, s = e.length; a < s; a++) {
                            var l = e[a],
                                c = l.url;
                            if (Array.isArray(c)) {
                                r[l.uuid] = [];
                                for (var u = 0, h = c.length; u < h; u++) {
                                    var d = c[u],
                                        p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
                                    r[l.uuid].push(i(p))
                                }
                            } else {
                                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.resourcePath + l.url;
                                r[l.uuid] = i(p)
                            }
                        }
                    }
                    return r
                },
                parseTextures: function(e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    var r = {};
                    if (void 0 !== e)
                        for (var i = 0, o = e.length; i < o; i++) {
                            var a, s = e[i];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(t[s.image]) ? new Bi(t[s.image]) : new Ft(t[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, du)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], pu), a.wrapT = n(s.wrap[1], pu)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, fu)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, fu)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), r[s.uuid] = a
                        }
                    return r
                },
                parseObject: function(e, t, o) {
                    var n;

                    function r(e) {
                        return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                    }

                    function i(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                for (var t = [], n = 0, r = e.length; n < r; n++) {
                                    var i = e[n];
                                    void 0 === o[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(o[i])
                                }
                                return t
                            }
                            return void 0 === o[e] && console.warn("THREE.ObjectLoader: Undefined material", e), o[e]
                        }
                    }
                    switch (e.type) {
                        case "Scene":
                            n = new mn, void 0 !== e.background && Number.isInteger(e.background) && (n.background = new or(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new Ea(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new Ta(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            n = new fi(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (n.focus = e.focus), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset), void 0 !== e.view && (n.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            n = new $c(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.view && (n.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            n = new nu(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            n = new tu(e.color, e.intensity);
                            break;
                        case "PointLight":
                            n = new Qc(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            n = new ru(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            n = new Kc(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            n = new Xc(e.color, e.groundColor, e.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var a = r(e.geometry),
                                s = i(e.material);
                            n = a.bones && 0 < a.bones.length ? new Za(a, s) : new Jr(a, s);
                            break;
                        case "InstancedMesh":
                            a = r(e.geometry), s = i(e.material);
                            var l = e.count,
                                c = e.instanceMatrix;
                            (n = new is(a, s, l)).instanceMatrix = new fr(new Float32Array(c.array), 16);
                            break;
                        case "LOD":
                            n = new Ya;
                            break;
                        case "Line":
                            n = new hs(r(e.geometry), i(e.material), e.mode);
                            break;
                        case "LineLoop":
                            n = new ms(r(e.geometry), i(e.material));
                            break;
                        case "LineSegments":
                            n = new fs(r(e.geometry), i(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            n = new _s(r(e.geometry), i(e.material));
                            break;
                        case "Sprite":
                            n = new Wa(i(e.material));
                            break;
                        case "Group":
                            n = new wa;
                            break;
                        default:
                            n = new fn
                    }
                    if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.castShadow && (n.castShadow = e.castShadow), void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.layers && (n.layers.mask = e.layers), void 0 !== e.children)
                        for (var u = e.children, h = 0; h < u.length; h++) n.add(this.parseObject(u[h], t, o));
                    if ("LOD" === e.type) {
                        void 0 !== e.autoUpdate && (n.autoUpdate = e.autoUpdate);
                        for (var d = e.levels, p = 0; p < d.length; p++) {
                            var f = d[p],
                                m = n.getObjectByProperty("uuid", f.object);
                            void 0 !== m && n.addLevel(m, f.distance)
                        }
                    }
                    return n
                }
            });
            var hu, du = {
                    UVMapping: 300,
                    CubeReflectionMapping: q,
                    CubeRefractionMapping: X,
                    EquirectangularReflectionMapping: Re,
                    EquirectangularRefractionMapping: Pe,
                    SphericalReflectionMapping: Oe,
                    CubeUVReflectionMapping: Ie,
                    CubeUVRefractionMapping: De
                },
                pu = {
                    RepeatWrapping: Ne,
                    ClampToEdgeWrapping: ke,
                    MirroredRepeatWrapping: ze
                },
                fu = {
                    NearestFilter: Fe,
                    NearestMipmapNearestFilter: Be,
                    NearestMipmapLinearFilter: Ue,
                    LinearFilter: He,
                    LinearMipmapNearestFilter: Ge,
                    LinearMipmapLinearFilter: Ve
                };

            function mu(e) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), fc.call(this, e), this.options = void 0
            }

            function vu() {
                this.type = "ShapePath", this.color = new or, this.subPaths = [], this.currentPath = null
            }

            function gu(e) {
                this.type = "Font", this.data = e
            }

            function yu(e, t, n, r, i) {
                var o = i.glyphs[e] || i.glyphs["?"];
                if (o) {
                    var a, s, l, c, u, h, d, p, f = new vu;
                    if (o.o)
                        for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g;) {
                            switch (m[v++]) {
                                case "m":
                                    a = m[v++] * t + n, s = m[v++] * t + r, f.moveTo(a, s);
                                    break;
                                case "l":
                                    a = m[v++] * t + n, s = m[v++] * t + r, f.lineTo(a, s);
                                    break;
                                case "q":
                                    l = m[v++] * t + n, c = m[v++] * t + r, u = m[v++] * t + n, h = m[v++] * t + r, f.quadraticCurveTo(u, h, l, c);
                                    break;
                                case "b":
                                    l = m[v++] * t + n, c = m[v++] * t + r, u = m[v++] * t + n, h = m[v++] * t + r, d = m[v++] * t + n, p = m[v++] * t + r, f.bezierCurveTo(u, h, d, p, l, c)
                            }
                        }
                    return {
                        offsetX: o.ha * t,
                        path: f
                    }
                }
                console.error('THREE.Font: character "' + e + '" does not exists in font family ' + i.familyName + ".")
            }

            function xu(e) {
                fc.call(this, e)
            }
            mu.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: mu,
                setOptions: function(e) {
                    return this.options = e, this
                },
                load: function(t, n, e, r) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var i = this,
                        o = hc.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function() {
                        n && n(o), i.manager.itemEnd(t)
                    }, 0), o;
                    fetch(t).then(function(e) {
                        return e.blob()
                    }).then(function(e) {
                        return void 0 === i.options ? createImageBitmap(e) : createImageBitmap(e, i.options)
                    }).then(function(e) {
                        hc.add(t, e), n && n(e), i.manager.itemEnd(t)
                    }).catch(function(e) {
                        r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                    }), i.manager.itemStart(t)
                }
            }), Object.assign(vu.prototype, {
                moveTo: function(e, t) {
                    return this.currentPath = new Wc, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
                },
                lineTo: function(e, t) {
                    return this.currentPath.lineTo(e, t), this
                },
                quadraticCurveTo: function(e, t, n, r) {
                    return this.currentPath.quadraticCurveTo(e, t, n, r), this
                },
                bezierCurveTo: function(e, t, n, r, i, o) {
                    return this.currentPath.bezierCurveTo(e, t, n, r, i, o), this
                },
                splineThru: function(e) {
                    return this.currentPath.splineThru(e), this
                },
                toShapes: function(e, t) {
                    function n(e) {
                        for (var t = [], n = 0, r = e.length; n < r; n++) {
                            var i = e[n],
                                o = new jc;
                            o.curves = i.curves, t.push(o)
                        }
                        return t
                    }

                    function r(e, t) {
                        for (var n = t.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                            var a = t[i],
                                s = t[o],
                                l = s.x - a.x,
                                c = s.y - a.y;
                            if (Math.abs(c) > Number.EPSILON) {
                                if (c < 0 && (a = t[o], l = -l, s = t[i], c = -c), e.y < a.y || e.y > s.y) continue;
                                if (e.y === a.y) {
                                    if (e.x === a.x) return !0
                                } else {
                                    var u = c * (e.x - a.x) - l * (e.y - a.y);
                                    if (0 == u) return !0;
                                    if (u < 0) continue;
                                    r = !r
                                }
                            } else {
                                if (e.y !== a.y) continue;
                                if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x) return !0
                            }
                        }
                        return r
                    }
                    var i = pl.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === t) return n(o);
                    var a, s, l, c = [];
                    if (1 === o.length) return s = o[0], (l = new jc).curves = s.curves, c.push(l), c;
                    var u = !i(o[0].getPoints());
                    u = e ? !u : u;
                    var h, d, p = [],
                        f = [],
                        m = [],
                        v = 0;
                    f[v] = void 0, m[v] = [];
                    for (var g = 0, y = o.length; g < y; g++) a = i(h = (s = o[g]).getPoints()), (a = e ? !a : a) ? (!u && f[v] && v++, f[v] = {
                        s: new jc,
                        p: h
                    }, f[v].s.curves = s.curves, u && v++, m[v] = []) : m[v].push({
                        h: s,
                        p: h[0]
                    });
                    if (!f[0]) return n(o);
                    if (1 < f.length) {
                        for (var x = !1, b = [], _ = 0, w = f.length; _ < w; _++) p[_] = [];
                        for (_ = 0, w = f.length; _ < w; _++)
                            for (var S = m[_], M = 0; M < S.length; M++) {
                                for (var T = S[M], E = !0, C = 0; C < f.length; C++) r(T.p, f[C].p) && (_ !== C && b.push({
                                    froms: _,
                                    tos: C,
                                    hole: M
                                }), E ? (E = !1, p[C].push(T)) : x = !0);
                                E && p[_].push(T)
                            }
                        0 < b.length && (x || (m = p))
                    }
                    g = 0;
                    for (var L = f.length; g < L; g++) {
                        l = f[g].s, c.push(l);
                        for (var A = 0, R = (d = m[g]).length; A < R; A++) l.holes.push(d[A].h)
                    }
                    return c
                }
            }), Object.assign(gu.prototype, {
                isFont: !0,
                generateShapes: function(e, t) {
                    void 0 === t && (t = 100);
                    for (var n = [], r = function(e, t, n) {
                            for (var r = Array.from ? Array.from(e) : String(e).split(""), i = t / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, a = [], s = 0, l = 0, c = 0; c < r.length; c++) {
                                var u = r[c];
                                if ("\n" === u) s = 0, l -= o;
                                else {
                                    var h = yu(u, i, s, l, n);
                                    s += h.offsetX, a.push(h.path)
                                }
                            }
                            return a
                        }(e, t, this.data), i = 0, o = r.length; i < o; i++) Array.prototype.push.apply(n, r[i].toShapes());
                    return n
                }
            }), xu.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: xu,
                load: function(e, r, t, n) {
                    var i = this,
                        o = new vc(this.manager);
                    o.setPath(this.path), o.load(e, function(t) {
                        var n;
                        try {
                            n = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var e = i.parse(n);
                        r && r(e)
                    }, t, n)
                },
                parse: function(e) {
                    return new gu(e)
                }
            });
            var bu = {
                getContext: function() {
                    return void 0 === hu && (hu = new(window.AudioContext || window.webkitAudioContext)), hu
                },
                setContext: function(e) {
                    hu = e
                }
            };

            function _u(e) {
                fc.call(this, e)
            }

            function wu() {
                this.coefficients = [];
                for (var e = 0; e < 9; e++) this.coefficients.push(new Ot)
            }

            function Su(e, t) {
                qc.call(this, void 0, t), this.sh = void 0 !== e ? e : new wu
            }

            function Mu(e, t, n) {
                Su.call(this, void 0, n);
                var r = (new or).set(e),
                    i = (new or).set(t),
                    o = new Ot(r.r, r.g, r.b),
                    a = new Ot(i.r, i.g, i.b),
                    s = Math.sqrt(Math.PI),
                    l = s * Math.sqrt(.75);
                this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(l)
            }

            function Tu(e, t) {
                Su.call(this, void 0, t);
                var n = (new or).set(e);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
            _u.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: _u,
                load: function(e, n, t, r) {
                    var i = new vc(this.manager);
                    i.setResponseType("arraybuffer"), i.setPath(this.path), i.load(e, function(e) {
                        var t = e.slice(0);
                        bu.getContext().decodeAudioData(t, function(e) {
                            n(e)
                        })
                    }, t, r)
                }
            }), Object.assign(wu.prototype, {
                isSphericalHarmonics3: !0,
                set: function(e) {
                    for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this
                },
                zero: function() {
                    for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                    return this
                },
                getAt: function(e, t) {
                    var n = e.x,
                        r = e.y,
                        i = e.z,
                        o = this.coefficients;
                    return t.copy(o[0]).multiplyScalar(.282095), t.addScale(o[1], .488603 * r), t.addScale(o[2], .488603 * i), t.addScale(o[3], .488603 * n), t.addScale(o[4], n * r * 1.092548), t.addScale(o[5], r * i * 1.092548), t.addScale(o[6], .315392 * (3 * i * i - 1)), t.addScale(o[7], n * i * 1.092548), t.addScale(o[8], .546274 * (n * n - r * r)), t
                },
                getIrradianceAt: function(e, t) {
                    var n = e.x,
                        r = e.y,
                        i = e.z,
                        o = this.coefficients;
                    return t.copy(o[0]).multiplyScalar(.886227), t.addScale(o[1], 1.023328 * r), t.addScale(o[2], 1.023328 * i), t.addScale(o[3], 1.023328 * n), t.addScale(o[4], .858086 * n * r), t.addScale(o[5], .858086 * r * i), t.addScale(o[6], .743125 * i * i - .247708), t.addScale(o[7], .858086 * n * i), t.addScale(o[8], .429043 * (n * n - r * r)), t
                },
                add: function(e) {
                    for (var t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                    return this
                },
                scale: function(e) {
                    for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                    return this
                },
                lerp: function(e, t) {
                    for (var n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                    return this
                },
                equals: function(e) {
                    for (var t = 0; t < 9; t++)
                        if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                    return !0
                },
                copy: function(e) {
                    return this.set(e.coefficients)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                fromArray: function(e, t) {
                    void 0 === t && (t = 0);
                    for (var n = this.coefficients, r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
                    return this
                },
                toArray: function(e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    for (var n = this.coefficients, r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
                    return e
                }
            }), Object.assign(wu, {
                getBasisAt: function(e, t) {
                    var n = e.x,
                        r = e.y,
                        i = e.z;
                    t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
                }
            }), Su.prototype = Object.assign(Object.create(qc.prototype), {
                constructor: Su,
                isLightProbe: !0,
                copy: function(e) {
                    return qc.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
                },
                toJSON: function(e) {
                    return qc.prototype.toJSON.call(this, e)
                }
            }), Mu.prototype = Object.assign(Object.create(Su.prototype), {
                constructor: Mu,
                isHemisphereLightProbe: !0,
                copy: function(e) {
                    return Su.prototype.copy.call(this, e), this
                },
                toJSON: function(e) {
                    return Su.prototype.toJSON.call(this, e)
                }
            }), Tu.prototype = Object.assign(Object.create(Su.prototype), {
                constructor: Tu,
                isAmbientLightProbe: !0,
                copy: function(e) {
                    return Su.prototype.copy.call(this, e), this
                },
                toJSON: function(e) {
                    return Su.prototype.toJSON.call(this, e)
                }
            });
            var Eu = new Zt,
                Cu = new Zt;

            function Lu() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new fi, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new fi, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }

            function Au(e) {
                this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            Object.assign(Lu.prototype, {
                update: function(e) {
                    var t = this._cache;
                    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                        t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
                        var n, r, i = e.projectionMatrix.clone(),
                            o = t.eyeSep / 2,
                            a = o * t.near / t.focus,
                            s = t.near * Math.tan(Ct.DEG2RAD * t.fov * .5) / t.zoom;
                        Cu.elements[12] = -o, Eu.elements[12] = o, n = -s * t.aspect + a, r = s * t.aspect + a, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraL.projectionMatrix.copy(i), n = -s * t.aspect - a, r = s * t.aspect - a, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraR.projectionMatrix.copy(i)
                    }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Cu), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Eu)
                }
            }), Object.assign(Au.prototype, {
                start: function() {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var t = ("undefined" == typeof performance ? Date : performance).now();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            });
            var Ru = new Ot,
                Pu = new At,
                Ou = new Ot,
                Iu = new Ot;

            function Du() {
                fn.call(this), this.type = "AudioListener", this.context = bu.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Au
            }

            function Nu(e) {
                fn.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._pausedAt = 0, this.filters = []
            }
            Du.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: Du,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                },
                updateMatrixWorld: function(e) {
                    fn.prototype.updateMatrixWorld.call(this, e);
                    var t = this.context.listener,
                        n = this.up;
                    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Ru, Pu, Ou), Iu.set(0, 0, -1).applyQuaternion(Pu), t.positionX) {
                        var r = this.context.currentTime + this.timeDelta;
                        t.positionX.linearRampToValueAtTime(Ru.x, r), t.positionY.linearRampToValueAtTime(Ru.y, r), t.positionZ.linearRampToValueAtTime(Ru.z, r), t.forwardX.linearRampToValueAtTime(Iu.x, r), t.forwardY.linearRampToValueAtTime(Iu.y, r), t.forwardZ.linearRampToValueAtTime(Iu.z, r), t.upX.linearRampToValueAtTime(n.x, r), t.upY.linearRampToValueAtTime(n.y, r), t.upZ.linearRampToValueAtTime(n.z, r)
                    } else t.setPosition(Ru.x, Ru.y, Ru.z), t.setOrientation(Iu.x, Iu.y, Iu.z, n.x, n.y, n.z)
                }
            }), Nu.prototype = Object.assign(Object.create(fn.prototype), {
                constructor: Nu,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                },
                setMediaElementSource: function(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                },
                setMediaStreamSource: function(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                },
                setBuffer: function(e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function(e) {
                    if (void 0 === e && (e = 0), !0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            this._startedAt = this.context.currentTime + e;
                            var t = this.context.createBufferSource();
                            return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._pausedAt + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate, this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    if (!1 !== this.hasPlaybackControl) return this._pausedAt = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (0 < this.filters.length) {
                        this.source.connect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (0 < this.filters.length) {
                        this.source.disconnect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(e) {
                    return e = e || [], !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
                },
                setDetune: function(e) {
                    if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                },
                getDetune: function() {
                    return this.detune
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(e) {
                    return this.setFilters(e ? [e] : [])
                },
                setPlaybackRate: function(e) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function(e) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                setLoopStart: function(e) {
                    return this.loopStart = e, this
                },
                setLoopEnd: function(e) {
                    return this.loopEnd = e, this
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            });
            var ku = new Ot,
                zu = new At,
                Fu = new Ot,
                Bu = new Ot;

            function Uu(e) {
                Nu.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
            }

            function Hu(e, t) {
                this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
            }

            function Gu(e, t, n) {
                this.binding = e, this.valueSize = n;
                var r, i = Float64Array;
                switch (t) {
                    case "quaternion":
                        r = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        i = Array, r = this._select;
                        break;
                    default:
                        r = this._lerp
                }
                this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
            Uu.prototype = Object.assign(Object.create(Nu.prototype), {
                constructor: Uu,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(e) {
                    return this.panner.refDistance = e, this
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(e) {
                    return this.panner.rolloffFactor = e, this
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(e) {
                    return this.panner.distanceModel = e, this
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(e) {
                    return this.panner.maxDistance = e, this
                },
                setDirectionalCone: function(e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                },
                updateMatrixWorld: function(e) {
                    if (fn.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                        this.matrixWorld.decompose(ku, zu, Fu), Bu.set(0, 0, 1).applyQuaternion(zu);
                        var t = this.panner;
                        if (t.positionX) {
                            var n = this.context.currentTime + this.listener.timeDelta;
                            t.positionX.linearRampToValueAtTime(ku.x, n), t.positionY.linearRampToValueAtTime(ku.y, n), t.positionZ.linearRampToValueAtTime(ku.z, n), t.orientationX.linearRampToValueAtTime(Bu.x, n), t.orientationY.linearRampToValueAtTime(Bu.y, n), t.orientationZ.linearRampToValueAtTime(Bu.z, n)
                        } else t.setPosition(ku.x, ku.y, ku.z), t.setOrientation(Bu.x, Bu.y, Bu.z)
                    }
                }
            }), Object.assign(Hu.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function() {
                    for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }), Object.assign(Gu.prototype, {
                accumulate: function(e, t) {
                    var n = this.buffer,
                        r = this.valueSize,
                        i = e * r + r,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== r; ++a) n[i + a] = n[a];
                        o = t
                    } else {
                        var s = t / (o += t);
                        this._mixBufferRegion(n, i, 0, s, r)
                    }
                    this.cumulativeWeight = o
                },
                apply: function(e) {
                    var t = this.valueSize,
                        n = this.buffer,
                        r = e * t + t,
                        i = this.cumulativeWeight,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, i < 1) {
                        var a = 3 * t;
                        this._mixBufferRegion(n, r, a, 1 - i, t)
                    }
                    for (var s = t, l = t + t; s !== l; ++s)
                        if (n[s] !== n[s + t]) {
                            o.setValue(n, r);
                            break
                        }
                },
                saveOriginalState: function() {
                    var e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        r = 3 * n;
                    e.getValue(t, r);
                    for (var i = n, o = r; i !== o; ++i) t[i] = t[r + i % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                },
                _select: function(e, t, n, r, i) {
                    if (.5 <= r)
                        for (var o = 0; o !== i; ++o) e[t + o] = e[n + o]
                },
                _slerp: function(e, t, n, r) {
                    At.slerpFlat(e, t, e, t, e, n, r)
                },
                _lerp: function(e, t, n, r, i) {
                    for (var o = 1 - r, a = 0; a !== i; ++a) {
                        var s = t + a;
                        e[s] = e[s] * o + e[n + a] * r
                    }
                }
            });
            var Vu = "\\[\\]\\.:\\/",
                Wu = new RegExp("[" + Vu + "]", "g"),
                ju = "[^" + Vu + "]",
                qu = "[^" + Vu.replace("\\.", "") + "]",
                Xu = /((?:WC+[\/:])*)/.source.replace("WC", ju),
                Yu = /(WCOD+)?/.source.replace("WCOD", qu),
                Zu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ju),
                Ku = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ju),
                Ju = new RegExp("^" + Xu + Yu + Zu + Ku + "$"),
                Qu = ["material", "materials", "bones"];

            function $u(e, t, n) {
                var r = n || eh.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, r)
            }

            function eh(e, t, n) {
                this.path = t, this.parsedPath = n || eh.parseTrackName(t), this.node = eh.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
            }

            function th() {
                this.uuid = Ct.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var e = {};
                this._indicesByUUID = e;
                for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var r = this;
                this.stats = {
                    objects: {get total() {
                            return r._objects.length
                        },
                        get inUse() {
                            return this.total - r.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return r._bindings.length
                    }
                }
            }

            function nh(e, t, n) {
                this._mixer = e, this._clip = t, this._localRoot = n || null;
                for (var r = t.tracks, i = r.length, o = new Array(i), a = {
                        endingStart: 2400,
                        endingEnd: 2400
                    }, s = 0; s !== i; ++s) {
                    var l = r[s].createInterpolant(null);
                    (o[s] = l).settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function rh(e) {
                this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function ih(e) {
                "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
            }

            function oh(e, t, n) {
                Ca.call(this, e, t), this.meshPerAttribute = n || 1
            }

            function ah(e, t, n, r) {
                this.ray = new Un(e, t), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function sh(e, t) {
                return e.distance - t.distance
            }

            function lh(e, t, n, r) {
                if (!1 !== e.visible && (e.raycast(t, n), !0 === r))
                    for (var i = e.children, o = 0, a = i.length; o < a; o++) lh(i[o], t, n, !0)
            }

            function ch(e, t, n) {
                return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
            }

            function uh(e, t, n) {
                return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
            }
            Object.assign($u.prototype, {
                getValue: function(e, t) {
                    this.bind();
                    var n = this._targetGroup.nCachedObjects_,
                        r = this._bindings[n];
                    void 0 !== r && r.getValue(e, t)
                },
                setValue: function(e, t) {
                    for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
                },
                bind: function() {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                },
                unbind: function() {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }), Object.assign(eh, {
                Composite: $u,
                create: function(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new eh.Composite(e, t, n) : new eh(e, t, n)
                },
                sanitizeNodeName: function(e) {
                    return e.replace(/\s/g, "_").replace(Wu, "")
                },
                parseTrackName: function(e) {
                    var t = Ju.exec(e);
                    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    var n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        var i = n.nodeName.substring(r + 1); - 1 !== Qu.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                },
                findNode: function(e, i) {
                    if (!i || "" === i || "root" === i || "." === i || -1 === i || i === e.name || i === e.uuid) return e;
                    if (e.skeleton) {
                        var t = e.skeleton.getBoneByName(i);
                        if (void 0 !== t) return t
                    }
                    if (e.children) {
                        var o = function(e) {
                                for (var t = 0; t < e.length; t++) {
                                    var n = e[t];
                                    if (n.name === i || n.uuid === i) return n;
                                    var r = o(n.children);
                                    if (r) return r
                                }
                                return null
                            },
                            n = o(e.children);
                        if (n) return n
                    }
                    return null
                }
            }), Object.assign(eh.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(e, t) {
                    e[t] = this.node[this.propertyName]
                }, function(e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
                }, function(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }, function(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(e, t) {
                        this.targetObject[this.propertyName] = e[t]
                    }, function(e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(e, t) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                    }, function(e, t) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                        this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t]
                    }, function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(e, t) {
                        this.resolvedProperty.fromArray(e, t)
                    }, function(e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function(e, t) {
                    this.bind(), this.getValue(e, t)
                },
                setValue: function(e, t) {
                    this.bind(), this.setValue(e, t)
                },
                bind: function() {
                    var e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        r = t.propertyName,
                        i = t.propertyIndex;
                    if (e || (e = eh.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                        if (n) {
                            var o = t.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    e = e.material.materials;
                                    break;
                                case "bones":
                                    if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    e = e.skeleton.bones;
                                    for (var a = 0; a < e.length; a++)
                                        if (e[a].name === o) {
                                            o = a;
                                            break
                                        }
                                    break;
                                default:
                                    if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    e = e[n]
                            }
                            if (void 0 !== o) {
                                if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                e = e[o]
                            }
                        }
                        var s = e[r];
                        if (void 0 !== s) {
                            var l = this.Versioning.None;
                            void 0 !== (this.targetObject = e).needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                            var c = this.BindingType.Direct;
                            if (void 0 !== i) {
                                if ("morphTargetInfluences" === r) {
                                    if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (e.geometry.isBufferGeometry) {
                                        if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                        for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                            if (e.geometry.morphAttributes.position[a].name === i) {
                                                i = a;
                                                break
                                            }
                                    } else {
                                        if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                        for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                            if (e.geometry.morphTargets[a].name === i) {
                                                i = a;
                                                break
                                            }
                                    }
                                }
                                c = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                            this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
                        } else {
                            var u = t.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + r + " but it wasn't found.", e)
                        }
                    } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(eh.prototype, {
                _getValue_unbound: eh.prototype.getValue,
                _setValue_unbound: eh.prototype.setValue
            }), Object.assign(th.prototype, {
                isAnimationObjectGroup: !0,
                add: function() {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = void 0, c = 0, u = arguments.length; c !== u; ++c) {
                        var h = arguments[c],
                            d = h.uuid,
                            p = r[d];
                        if (void 0 === p) {
                            p = t++, r[d] = p, e.push(h);
                            for (var f = 0, m = s; f !== m; ++f) a[f].push(new eh(h, i[f], o[f]))
                        } else if (p < n) {
                            l = e[p];
                            var v = --n,
                                g = e[v];
                            e[r[g.uuid] = p] = g, e[r[d] = v] = h;
                            for (f = 0, m = s; f !== m; ++f) {
                                var y = a[f],
                                    x = y[v],
                                    b = y[p];
                                y[p] = x, void 0 === b && (b = new eh(h, i[f], o[f])), y[v] = b
                            }
                        } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = n
                },
                remove: function() {
                    for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, o = 0, a = arguments.length; o !== a; ++o) {
                        var s = arguments[o],
                            l = s.uuid,
                            c = n[l];
                        if (void 0 !== c && t <= c) {
                            var u = t++,
                                h = e[u];
                            e[n[h.uuid] = c] = h, e[n[l] = u] = s;
                            for (var d = 0, p = i; d !== p; ++d) {
                                var f = r[d],
                                    m = f[u],
                                    v = f[c];
                                f[c] = m, f[u] = v
                            }
                        }
                    }
                    this.nCachedObjects_ = t
                },
                uncache: function() {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                        var l = arguments[a].uuid,
                            c = r[l];
                        if (void 0 !== c)
                            if (delete r[l], c < n) {
                                var u = --n,
                                    h = e[u],
                                    d = e[g = --t];
                                e[r[h.uuid] = c] = h, e[r[d.uuid] = u] = d, e.pop();
                                for (var p = 0, f = o; p !== f; ++p) {
                                    var m = (y = i[p])[u],
                                        v = y[g];
                                    y[c] = m, y[u] = v, y.pop()
                                }
                            } else {
                                var g;
                                e[r[(d = e[g = --t]).uuid] = c] = d, e.pop();
                                for (p = 0, f = o; p !== f; ++p) {
                                    var y;
                                    (y = i[p])[c] = y[g], y.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = n
                },
                subscribe_: function(e, t) {
                    var n = this._bindingsIndicesByPath,
                        r = n[e],
                        i = this._bindings;
                    if (void 0 !== r) return i[r];
                    var o = this._paths,
                        a = this._parsedPaths,
                        s = this._objects,
                        l = s.length,
                        c = this.nCachedObjects_,
                        u = new Array(l);
                    r = i.length, n[e] = r, o.push(e), a.push(t), i.push(u);
                    for (var h = c, d = s.length; h !== d; ++h) {
                        var p = s[h];
                        u[h] = new eh(p, e, t)
                    }
                    return u
                },
                unsubscribe_: function(e) {
                    var t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        var r = this._paths,
                            i = this._parsedPaths,
                            o = this._bindings,
                            a = o.length - 1,
                            s = o[a];
                        o[t[e[a]] = n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                    }
                }
            }), Object.assign(nh.prototype, {
                play: function() {
                    return this._mixer._activateAction(this), this
                },
                stop: function() {
                    return this._mixer._deactivateAction(this), this.reset()
                },
                reset: function() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                },
                isRunning: function() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function() {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function(e) {
                    return this._startTime = e, this
                },
                setLoop: function(e, t) {
                    return this.loop = e, this.repetitions = t, this
                },
                setEffectiveWeight: function(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                },
                getEffectiveWeight: function() {
                    return this._effectiveWeight
                },
                fadeIn: function(e) {
                    return this._scheduleFading(e, 0, 1)
                },
                fadeOut: function(e) {
                    return this._scheduleFading(e, 1, 0)
                },
                crossFadeFrom: function(e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        var r = this._clip.duration,
                            i = e._clip.duration,
                            o = i / r,
                            a = r / i;
                        e.warp(1, o, t), this.warp(a, 1, t)
                    }
                    return this
                },
                crossFadeTo: function(e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                },
                stopFading: function() {
                    var e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                setEffectiveTimeScale: function(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                },
                getEffectiveTimeScale: function() {
                    return this._effectiveTimeScale
                },
                setDuration: function(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                },
                syncWith: function(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                },
                halt: function(e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                },
                warp: function(e, t, n) {
                    var r = this._mixer,
                        i = r.time,
                        o = this._timeScaleInterpolant,
                        a = this.timeScale;
                    null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    var s = o.parameterPositions,
                        l = o.sampleValues;
                    return s[0] = i, s[1] = i + n, l[0] = e / a, l[1] = t / a, this
                },
                stopWarping: function() {
                    var e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                getMixer: function() {
                    return this._mixer
                },
                getClip: function() {
                    return this._clip
                },
                getRoot: function() {
                    return this._localRoot || this._mixer._root
                },
                _update: function(e, t, n, r) {
                    if (this.enabled) {
                        var i = this._startTime;
                        if (null !== i) {
                            var o = (e - i) * n;
                            if (o < 0 || 0 === n) return;
                            this._startTime = null, t = n * o
                        }
                        t *= this._updateTimeScale(e);
                        var a = this._updateTime(t),
                            s = this._updateWeight(e);
                        if (0 < s)
                            for (var l = this._interpolants, c = this._propertyBindings, u = 0, h = l.length; u !== h; ++u) l[u].evaluate(a), c[u].accumulate(r, s)
                    } else this._updateWeight(e)
                },
                _updateWeight: function(e) {
                    var t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        var n = this._weightInterpolant;
                        if (null !== n) {
                            var r = n.evaluate(e)[0];
                            t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t
                },
                _updateTimeScale: function(e) {
                    var t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        var n = this._timeScaleInterpolant;
                        if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                    return this._effectiveTimeScale = t
                },
                _updateTime: function(e) {
                    var t = this.time + e,
                        n = this._clip.duration,
                        r = this.loop,
                        i = this._loopCount,
                        o = 2202 === r;
                    if (0 === e) return -1 === i ? t : o && 1 == (1 & i) ? n - t : t;
                    if (2200 === r) {
                        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: {
                            if (n <= t) t = n;
                            else {
                                if (!(t < 0)) {
                                    this.time = t;
                                    break e
                                }
                                t = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === i && (0 <= e ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), n <= t || t < 0) {
                            var a = Math.floor(t / n);
                            t -= n * a, i += Math.abs(a);
                            var s = this.repetitions - i;
                            if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = 0 < e ? n : 0, this.time = t, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: 0 < e ? 1 : -1
                            });
                            else {
                                if (1 == s) {
                                    var l = e < 0;
                                    this._setEndings(l, !l, o)
                                } else this._setEndings(!1, !1, o);
                                this._loopCount = i, this.time = t, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: a
                                })
                            }
                        } else this.time = t;
                        if (o && 1 == (1 & i)) return n - t
                    }
                    return t
                },
                _setEndings: function(e, t, n) {
                    var r = this._interpolantSettings;
                    n ? (r.endingStart = 2401, r.endingEnd = 2401) : (r.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, r.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
                },
                _scheduleFading: function(e, t, n) {
                    var r = this._mixer,
                        i = r.time,
                        o = this._weightInterpolant;
                    null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                    var a = o.parameterPositions,
                        s = o.sampleValues;
                    return a[0] = i, s[0] = t, a[1] = i + e, s[1] = n, this
                }
            }), rh.prototype = Object.assign(Object.create(Mt.prototype), {
                constructor: rh,
                _bindAction: function(e, t) {
                    var n = e._localRoot || this._root,
                        r = e._clip.tracks,
                        i = r.length,
                        o = e._propertyBindings,
                        a = e._interpolants,
                        s = n.uuid,
                        l = this._bindingsByRootAndName,
                        c = l[s];
                    void 0 === c && (c = {}, l[s] = c);
                    for (var u = 0; u !== i; ++u) {
                        var h = r[u],
                            d = h.name,
                            p = c[d];
                        if (void 0 !== p) o[u] = p;
                        else {
                            if (void 0 !== (p = o[u])) {
                                null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                continue
                            }
                            var f = t && t._propertyBindings[u].binding.parsedPath;
                            ++(p = new Gu(eh.create(n, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), o[u] = p
                        }
                        a[u].resultBuffer = p.buffer
                    }
                },
                _activateAction: function(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            var t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                r = this._actionsByClip[n];
                            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        for (var i = e._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                            var s = i[o];
                            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                },
                _deactivateAction: function(e) {
                    if (this._isActiveAction(e)) {
                        for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                            var i = t[n];
                            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                        }
                        this._takeBackAction(e)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var e = this;
                    this.stats = {
                        actions: {get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(e) {
                    var t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                },
                _addInactiveAction: function(e, t, n) {
                    var r = this._actions,
                        i = this._actionsByClip,
                        o = i[t];
                    if (void 0 === o) o = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, i[t] = o;
                    else {
                        var a = o.knownActions;
                        e._byClipCacheIndex = a.length, a.push(e)
                    }
                    e._cacheIndex = r.length, r.push(e), o.actionByRoot[n] = e
                },
                _removeInactiveAction: function(e) {
                    var t = this._actions,
                        n = t[t.length - 1],
                        r = e._cacheIndex;
                    t[n._cacheIndex = r] = n, t.pop(), e._cacheIndex = null;
                    var i = e._clip.uuid,
                        o = this._actionsByClip,
                        a = o[i],
                        s = a.knownActions,
                        l = s[s.length - 1],
                        c = e._byClipCacheIndex;
                    s[l._byClipCacheIndex = c] = l, s.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(e)
                },
                _removeInactiveBindingsForAction: function(e) {
                    for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                        var i = t[n];
                        0 == --i.referenceCount && this._removeInactiveBinding(i)
                    }
                },
                _lendAction: function(e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        r = this._nActiveActions++,
                        i = t[r];
                    t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
                },
                _takeBackAction: function(e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        r = --this._nActiveActions,
                        i = t[r];
                    t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
                },
                _addInactiveBinding: function(e, t, n) {
                    var r = this._bindingsByRootAndName,
                        i = r[t],
                        o = this._bindings;
                    void 0 === i && (i = {}, r[t] = i), (i[n] = e)._cacheIndex = o.length, o.push(e)
                },
                _removeInactiveBinding: function(e) {
                    var t = this._bindings,
                        n = e.binding,
                        r = n.rootNode.uuid,
                        i = n.path,
                        o = this._bindingsByRootAndName,
                        a = o[r],
                        s = t[t.length - 1],
                        l = e._cacheIndex;
                    t[s._cacheIndex = l] = s, t.pop(), delete a[i], 0 === Object.keys(a).length && delete o[r]
                },
                _lendBinding: function(e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        r = this._nActiveBindings++,
                        i = t[r];
                    t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
                },
                _takeBackBinding: function(e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        r = --this._nActiveBindings,
                        i = t[r];
                    t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
                },
                _lendControlInterpolant: function() {
                    var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t];
                    return void 0 === n && (e[(n = new $l(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t] = n), n
                },
                _takeBackControlInterpolant: function(e) {
                    var t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        i = t[r];
                    t[e.__cacheIndex = r] = e, t[i.__cacheIndex = n] = i
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(e, t) {
                    var n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? cc.findByName(n, e) : e,
                        o = null !== i ? i.uuid : e,
                        a = this._actionsByClip[o],
                        s = null;
                    if (void 0 !== a) {
                        var l = a.actionByRoot[r];
                        if (void 0 !== l) return l;
                        s = a.knownActions[0], null === i && (i = s._clip)
                    }
                    if (null === i) return null;
                    var c = new nh(this, i, t);
                    return this._bindAction(c, s), this._addInactiveAction(c, o, r), c
                },
                existingAction: function(e, t) {
                    var n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? cc.findByName(n, e) : e,
                        o = i ? i.uuid : e,
                        a = this._actionsByClip[o];
                    return void 0 !== a && a.actionByRoot[r] || null
                },
                stopAllAction: function() {
                    var e = this._actions,
                        t = this._nActiveActions,
                        n = this._bindings,
                        r = this._nActiveBindings;
                    this._nActiveActions = 0;
                    for (var i = this._nActiveBindings = 0; i !== t; ++i) e[i].reset();
                    for (i = 0; i !== r; ++i) n[i].useCount = 0;
                    return this
                },
                update: function(e) {
                    e *= this.timeScale;
                    for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                        t[a]._update(r, e, i, o)
                    }
                    var s = this._bindings,
                        l = this._nActiveBindings;
                    for (a = 0; a !== l; ++a) s[a].apply(o);
                    return this
                },
                setTime: function(e) {
                    for (var t = this.time = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                    return this.update(e)
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(e) {
                    var t = this._actions,
                        n = e.uuid,
                        r = this._actionsByClip,
                        i = r[n];
                    if (void 0 !== i) {
                        for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                            var l = o[a];
                            this._deactivateAction(l);
                            var c = l._cacheIndex,
                                u = t[t.length - 1];
                            l._cacheIndex = null, l._byClipCacheIndex = null, t[u._cacheIndex = c] = u, t.pop(), this._removeInactiveBindingsForAction(l)
                        }
                        delete r[n]
                    }
                },
                uncacheRoot: function(e) {
                    var t = e.uuid,
                        n = this._actionsByClip;
                    for (var r in n) {
                        var i = n[r].actionByRoot[t];
                        void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                    var o = this._bindingsByRootAndName[t];
                    if (void 0 !== o)
                        for (var a in o) {
                            var s = o[a];
                            s.restoreOriginalState(), this._removeInactiveBinding(s)
                        }
                },
                uncacheAction: function(e, t) {
                    var n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }), ih.prototype.clone = function() {
                return new ih(void 0 === this.value.clone ? this.value : this.value.clone())
            }, oh.prototype = Object.assign(Object.create(Ca.prototype), {
                constructor: oh,
                isInstancedInterleavedBuffer: !0,
                copy: function(e) {
                    return Ca.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                }
            }), Object.assign(ah.prototype, {
                linePrecision: 1,
                set: function(e, t) {
                    this.ray.set(e, t)
                },
                setFromCamera: function(e, t) {
                    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(e, t, n) {
                    var r = n || [];
                    return lh(e, this, r, t), r.sort(sh), r
                },
                intersectObjects: function(e, t, n) {
                    var r = n || [];
                    if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
                    for (var i = 0, o = e.length; i < o; i++) lh(e[i], this, r, t);
                    return r.sort(sh), r
                }
            }), Object.assign(ch.prototype, {
                set: function(e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                },
                makeSafe: function() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                },
                setFromVector3: function(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                },
                setFromCartesianCoords: function(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Ct.clamp(t / this.radius, -1, 1))), this
                }
            }), Object.assign(uh.prototype, {
                set: function(e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                },
                setFromVector3: function(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                },
                setFromCartesianCoords: function(e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
            });
            var hh = new Lt;

            function dh(e, t) {
                this.min = void 0 !== e ? e : new Lt(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Lt(-1 / 0, -1 / 0)
            }
            Object.assign(dh.prototype, {
                set: function(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromPoints: function(e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function(e, t) {
                    var n = hh.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function(e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new Lt), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new Lt), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function(e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function(e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                containsPoint: function(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                },
                containsBox: function(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                },
                getParameter: function(e, t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new Lt), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                },
                clampPoint: function(e, t) {
                    return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new Lt), t.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function(e) {
                    return hh.copy(e).clamp(this.min, this.max).sub(e).length()
                },
                intersect: function(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                },
                union: function(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                translate: function(e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            });
            var ph = new Ot,
                fh = new Ot;

            function mh(e, t) {
                this.start = void 0 !== e ? e : new Ot, this.end = void 0 !== t ? t : new Ot
            }

            function vh(e) {
                fn.call(this), this.material = e, this.render = function() {}
            }
            Object.assign(mh.prototype, {
                set: function(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                },
                getCenter: function(e) {
                    return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new Ot), e.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(e) {
                    return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new Ot), e.subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(e, t) {
                    return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new Ot), this.delta(t).multiplyScalar(e).add(this.start)
                },
                closestPointToPointParameter: function(e, t) {
                    ph.subVectors(e, this.start), fh.subVectors(this.end, this.start);
                    var n = fh.dot(fh),
                        r = fh.dot(ph) / n;
                    return t && (r = Ct.clamp(r, 0, 1)), r
                },
                closestPointToPoint: function(e, t, n) {
                    var r = this.closestPointToPointParameter(e, t);
                    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Ot), this.delta(n).multiplyScalar(r).add(this.start)
                },
                applyMatrix4: function(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                },
                equals: function(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
            }), ((vh.prototype = Object.create(fn.prototype)).constructor = vh).prototype.isImmediateRenderObject = !0;
            var gh = new Ot;

            function yh(e, t) {
                fn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                for (var n = new Ir, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++, o++) {
                    var a = i / 32 * Math.PI * 2,
                        s = o / 32 * Math.PI * 2;
                    r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                n.setAttribute("position", new wr(r, 3));
                var l = new os({
                    fog: !1
                });
                this.cone = new fs(n, l), this.add(this.cone), this.update()
            }((yh.prototype = Object.create(fn.prototype)).constructor = yh).prototype.dispose = function() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, yh.prototype.update = function() {
                this.light.updateMatrixWorld();
                var e = this.light.distance ? this.light.distance : 1e3,
                    t = e * Math.tan(this.light.angle);
                this.cone.scale.set(t, t, e), gh.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(gh), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            };
            var xh = new Ot,
                bh = new Zt,
                _h = new Zt;

            function wh(e) {
                for (var t = function e(t) {
                        var n = [];
                        t && t.isBone && n.push(t);
                        for (var r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                        return n
                    }(e), n = new Ir, r = [], i = [], o = new or(0, 0, 1), a = new or(0, 1, 0), s = 0; s < t.length; s++) {
                    var l = t[s];
                    l.parent && l.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
                }
                n.setAttribute("position", new wr(r, 3)), n.setAttribute("color", new wr(i, 3));
                var c = new os({
                    vertexColors: g,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                fs.call(this, n, c), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }

            function Sh(e, t, n) {
                this.light = e, this.light.updateMatrixWorld(), this.color = n;
                var r = new Sl(t, 4, 2),
                    i = new dr({
                        wireframe: !0,
                        fog: !1
                    });
                Jr.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }((wh.prototype = Object.create(fs.prototype)).constructor = wh).prototype.updateMatrixWorld = function(e) {
                var t = this.bones,
                    n = this.geometry,
                    r = n.getAttribute("position");
                _h.getInverse(this.root.matrixWorld);
                for (var i = 0, o = 0; i < t.length; i++) {
                    var a = t[i];
                    a.parent && a.parent.isBone && (bh.multiplyMatrices(_h, a.matrixWorld), xh.setFromMatrixPosition(bh), r.setXYZ(o, xh.x, xh.y, xh.z), bh.multiplyMatrices(_h, a.parent.matrixWorld), xh.setFromMatrixPosition(bh), r.setXYZ(o + 1, xh.x, xh.y, xh.z), o += 2)
                }
                n.getAttribute("position").needsUpdate = !0, fn.prototype.updateMatrixWorld.call(this, e)
            }, ((Sh.prototype = Object.create(Jr.prototype)).constructor = Sh).prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, Sh.prototype.update = function() {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            };
            var Mh = new Ot,
                Th = new or,
                Eh = new or;

            function Ch(e, t, n) {
                fn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var r = new Ns(t);
                r.rotateY(.5 * Math.PI), this.material = new dr({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = g);
                var i = r.getAttribute("position"),
                    o = new Float32Array(3 * i.count);
                r.setAttribute("color", new fr(o, 3)), this.add(new Jr(r, this.material)), this.update()
            }

            function Lh(e, t, n, r) {
                e = e || 10, t = t || 10, n = new or(void 0 !== n ? n : 4473924), r = new or(void 0 !== r ? r : 8947848);
                for (var i = t / 2, o = e / t, a = e / 2, s = [], l = [], c = 0, u = 0, h = -a; c <= t; c++, h += o) {
                    s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                    var d = c === i ? n : r;
                    d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3
                }
                var p = new Ir;
                p.setAttribute("position", new wr(s, 3)), p.setAttribute("color", new wr(l, 3));
                var f = new os({
                    vertexColors: g
                });
                fs.call(this, p, f)
            }

            function Ah(e, t, n, r, i, o) {
                e = e || 10, t = t || 16, n = n || 8, r = r || 64, i = new or(void 0 !== i ? i : 4473924), o = new or(void 0 !== o ? o : 8947848);
                var a, s, l, c, u, h, d, p = [],
                    f = [];
                for (c = 0; c <= t; c++) l = c / t * (2 * Math.PI), a = Math.sin(l) * e, s = Math.cos(l) * e, p.push(0, 0, 0), p.push(a, 0, s), d = 1 & c ? i : o, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
                for (c = 0; c <= n; c++)
                    for (d = 1 & c ? i : o, h = e - e / n * c, u = 0; u < r; u++) l = u / r * (2 * Math.PI), a = Math.sin(l) * h, s = Math.cos(l) * h, p.push(a, 0, s), f.push(d.r, d.g, d.b), l = (u + 1) / r * (2 * Math.PI), a = Math.sin(l) * h, s = Math.cos(l) * h, p.push(a, 0, s), f.push(d.r, d.g, d.b);
                var m = new Ir;
                m.setAttribute("position", new wr(p, 3)), m.setAttribute("color", new wr(f, 3));
                var v = new os({
                    vertexColors: g
                });
                fs.call(this, m, v)
            }((Ch.prototype = Object.create(fn.prototype)).constructor = Ch).prototype.dispose = function() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, Ch.prototype.update = function() {
                var e = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var t = e.geometry.getAttribute("color");
                    Th.copy(this.light.color), Eh.copy(this.light.groundColor);
                    for (var n = 0, r = t.count; n < r; n++) {
                        var i = n < r / 2 ? Th : Eh;
                        t.setXYZ(n, i.r, i.g, i.b)
                    }
                    t.needsUpdate = !0
                }
                e.lookAt(Mh.setFromMatrixPosition(this.light.matrixWorld).negate())
            }, Lh.prototype = Object.assign(Object.create(fs.prototype), {
                constructor: Lh,
                copy: function(e) {
                    return fs.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), (Ah.prototype = Object.create(fs.prototype)).constructor = Ah;
            var Rh = new Ot,
                Ph = new Ot,
                Oh = new Ot;

            function Ih(e, t, n) {
                fn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
                var r = new Ir;
                r.setAttribute("position", new wr([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                var i = new os({
                    fog: !1
                });
                this.lightPlane = new hs(r, i), this.add(this.lightPlane), (r = new Ir).setAttribute("position", new wr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new hs(r, i), this.add(this.targetLine), this.update()
            }((Ih.prototype = Object.create(fn.prototype)).constructor = Ih).prototype.dispose = function() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, Ih.prototype.update = function() {
                Rh.setFromMatrixPosition(this.light.matrixWorld), Ph.setFromMatrixPosition(this.light.target.matrixWorld), Oh.subVectors(Ph, Rh), this.lightPlane.lookAt(Ph), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Ph), this.targetLine.scale.z = Oh.length()
            };
            var Dh = new Ot,
                Nh = new pi;

            function kh(e) {
                var t = new Ir,
                    n = new os({
                        color: 16777215,
                        vertexColors: 1
                    }),
                    r = [],
                    i = [],
                    o = {},
                    a = new or(16755200),
                    s = new or(16711680),
                    l = new or(43775),
                    c = new or(16777215),
                    u = new or(3355443);

                function h(e, t, n) {
                    d(e, n), d(t, n)
                }

                function d(e, t) {
                    r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === o[e] && (o[e] = []), o[e].push(r.length / 3 - 1)
                }
                h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", l), h("u2", "u3", l), h("u3", "u1", l), h("c", "t", c), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), t.setAttribute("position", new wr(r, 3)), t.setAttribute("color", new wr(i, 3)), fs.call(this, t, n), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }

            function zh(e, t, n, r, i, o, a) {
                Dh.set(i, o, a).unproject(r);
                var s = t[e];
                if (void 0 !== s)
                    for (var l = n.getAttribute("position"), c = 0, u = s.length; c < u; c++) l.setXYZ(s[c], Dh.x, Dh.y, Dh.z)
            }((kh.prototype = Object.create(fs.prototype)).constructor = kh).prototype.update = function() {
                var e = this.geometry,
                    t = this.pointMap;
                Nh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), zh("c", t, e, Nh, 0, 0, -1), zh("t", t, e, Nh, 0, 0, 1), zh("n1", t, e, Nh, -1, -1, -1), zh("n2", t, e, Nh, 1, -1, -1), zh("n3", t, e, Nh, -1, 1, -1), zh("n4", t, e, Nh, 1, 1, -1), zh("f1", t, e, Nh, -1, -1, 1), zh("f2", t, e, Nh, 1, -1, 1), zh("f3", t, e, Nh, -1, 1, 1), zh("f4", t, e, Nh, 1, 1, 1), zh("u1", t, e, Nh, .7, 1.1, -1), zh("u2", t, e, Nh, -.7, 1.1, -1), zh("u3", t, e, Nh, 0, 2, -1), zh("cf1", t, e, Nh, -1, 0, 1), zh("cf2", t, e, Nh, 1, 0, 1), zh("cf3", t, e, Nh, 0, -1, 1), zh("cf4", t, e, Nh, 0, 1, 1), zh("cn1", t, e, Nh, -1, 0, -1), zh("cn2", t, e, Nh, 1, 0, -1), zh("cn3", t, e, Nh, 0, -1, -1), zh("cn4", t, e, Nh, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
            };
            var Fh = new An;

            function Bh(e, t) {
                this.object = e, void 0 === t && (t = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Float32Array(24),
                    i = new Ir;
                i.setIndex(new fr(n, 1)), i.setAttribute("position", new fr(r, 3)), fs.call(this, i, new os({
                    color: t
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Uh(e, t) {
                this.type = "Box3Helper", this.box = e, t = t || 16776960;
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Ir;
                r.setIndex(new fr(n, 1)), r.setAttribute("position", new wr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), fs.call(this, r, new os({
                    color: t
                })), this.geometry.computeBoundingSphere()
            }

            function Hh(e, t, n) {
                this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
                var r = void 0 !== n ? n : 16776960,
                    i = new Ir;
                i.setAttribute("position", new wr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), hs.call(this, i, new os({
                    color: r
                }));
                var o = new Ir;
                o.setAttribute("position", new wr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Jr(o, new dr({
                    color: r,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }((Bh.prototype = Object.create(fs.prototype)).constructor = Bh).prototype.update = function(e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Fh.setFromObject(this.object), !Fh.isEmpty()) {
                    var t = Fh.min,
                        n = Fh.max,
                        r = this.geometry.attributes.position,
                        i = r.array;
                    i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }, Bh.prototype.setFromObject = function(e) {
                return this.object = e, this.update(), this
            }, Bh.prototype.copy = function(e) {
                return fs.prototype.copy.call(this, e), this.object = e.object, this
            }, Bh.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, ((Uh.prototype = Object.create(fs.prototype)).constructor = Uh).prototype.updateMatrixWorld = function(e) {
                var t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), fn.prototype.updateMatrixWorld.call(this, e))
            }, ((Hh.prototype = Object.create(hs.prototype)).constructor = Hh).prototype.updateMatrixWorld = function(e) {
                var t = -this.plane.constant;
                Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? Me : P, this.lookAt(this.plane.normal), fn.prototype.updateMatrixWorld.call(this, e)
            };
            var Gh, Vh, Wh = new Ot;

            function jh(e, t, n, r, i, o) {
                fn.call(this), void 0 === e && (e = new Ot(0, 0, 1)), void 0 === t && (t = new Ot(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === i && (i = .2 * n), void 0 === o && (o = .2 * i), void 0 === Gh && ((Gh = new Ir).setAttribute("position", new wr([0, 0, 0, 0, 1, 0], 3)), (Vh = new Il(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new hs(Gh, new os({
                    color: r
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Jr(Vh, new dr({
                    color: r
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, o)
            }

            function qh(e) {
                var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    n = new Ir;
                n.setAttribute("position", new wr(t, 3)), n.setAttribute("color", new wr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var r = new os({
                    vertexColors: g
                });
                fs.call(this, n, r)
            }((jh.prototype = Object.create(fn.prototype)).constructor = jh).prototype.setDirection = function(e) {
                if (.99999 < e.y) this.quaternion.set(0, 0, 0, 1);
                else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                else {
                    Wh.set(e.z, 0, -e.x).normalize();
                    var t = Math.acos(e.y);
                    this.quaternion.setFromAxisAngle(Wh, t)
                }
            }, jh.prototype.setLength = function(e, t, n) {
                void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
            }, jh.prototype.setColor = function(e) {
                this.line.material.color.set(e), this.cone.material.color.set(e)
            }, jh.prototype.copy = function(e) {
                return fn.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
            }, jh.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, (qh.prototype = Object.create(fs.prototype)).constructor = qh;
            var Xh = 4,
                Yh = 8,
                Zh = Math.pow(2, Yh),
                Kh = [.125, .215, .35, .446, .526, .582],
                Jh = Yh - Xh + 1 + Kh.length,
                Qh = 20,
                $h = {};
            $h[ut] = 0, $h[t] = 1, $h[ht] = 2, $h[pt] = 3, $h[ft] = 4, $h[mt] = 5, $h[n] = 6;
            var ed, td, nd, rd, id = new $c,
                od = (ed = Qh, td = new Float32Array(ed), nd = new Ot(0, 1, 0), (rd = new Ul({
                    defines: {
                        n: ed
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: td
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        mipInt: {
                            value: 0
                        },
                        poleAxis: {
                            value: nd
                        },
                        inputEncoding: {
                            value: $h[ut]
                        },
                        outputEncoding: {
                            value: $h[ut]
                        }
                    },
                    vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
                    fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfor (int dir = -1; dir < 2; dir += 2) {\n\t\t\tif (i == 0 && dir == 1)\n\t\t\t\tcontinue;\n\t\t\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\t\t\tif (all(equal(axis, vec3(0.0))))\n\t\t\t\taxis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\n\t\t\taxis = normalize(axis);\n\t\t\tfloat theta = dTheta * float(dir * i);\n\t\t\tfloat cosTheta = cos(theta);\n\t\t\t// Rodrigues' axis-angle rotation\n\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t\t\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\tweights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\n\t\t}\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
                    blending: Q,
                    depthTest: !1,
                    depthWrite: !1
                })).type = "SphericalGaussianBlur", rd),
                ad = null,
                sd = null,
                ld = function() {
                    for (var e = [], t = [], n = [], r = Yh, i = 0; i < Jh; i++) {
                        var o = Math.pow(2, r);
                        t.push(o);
                        var a = 1 / o;
                        Yh - Xh < i ? a = Kh[i - Yh + Xh - 1] : 0 == i && (a = 0), n.push(a);
                        for (var s = 1 / (o - 1), l = -s / 2, c = 1 + s / 2, u = [l, l, c, l, c, c, l, l, c, c, l, c], h = new Float32Array(108), d = new Float32Array(72), p = new Float32Array(36), f = 0; f < 6; f++) {
                            var m = f % 3 * 2 / 3 - 1,
                                v = 2 < f ? 0 : -1,
                                g = [m, v, 0, m + 2 / 3, v, 0, m + 2 / 3, 1 + v, 0, m, v, 0, m + 2 / 3, 1 + v, 0, m, 1 + v, 0];
                            h.set(g, 18 * f), d.set(u, 12 * f);
                            var y = [f, f, f, f, f, f];
                            p.set(y, 6 * f)
                        }
                        var x = new Ir;
                        x.setAttribute("position", new fr(h, 3)), x.setAttribute("uv", new fr(d, 2)), x.setAttribute("faceIndex", new fr(p, 1)), e.push(x), Xh < r && r--
                    }
                    return {
                        _lodPlanes: e,
                        _sizeLods: t,
                        _sigmas: n
                    }
                }(),
                cd = ld._lodPlanes,
                ud = ld._sizeLods,
                hd = ld._sigmas,
                dd = null,
                pd = null,
                fd = (1 + Math.sqrt(5)) / 2,
                md = 1 / fd,
                vd = [new Ot(1, 1, 1), new Ot(-1, 1, 1), new Ot(1, 1, -1), new Ot(-1, 1, -1), new Ot(0, fd, md), new Ot(0, fd, -md), new Ot(md, 0, fd), new Ot(-md, 0, fd), new Ot(fd, md, 0), new Ot(-fd, md, 0)];

            function gd(e) {
                pd = e, bd(od)
            }

            function yd(e) {
                var t = {
                        magFilter: Fe,
                        minFilter: Fe,
                        generateMipmaps: !1,
                        type: e ? e.type : We,
                        format: e ? e.format : r,
                        encoding: e ? e.encoding : ht,
                        depthBuffer: !1,
                        stencilBuffer: !1
                    },
                    n = _d(t);
                return n.depthBuffer = !e, dd = _d(t), n
            }

            function xd() {
                dd.dispose(), pd.setRenderTarget(null);
                var e = pd.getSize(new Lt);
                pd.setViewport(0, 0, e.x, e.y)
            }

            function bd(e) {
                var t = new mn;
                t.add(new Jr(cd[0], e)), pd.compile(t, id)
            }

            function _d(e) {
                var t = new Ut(3 * Zh, 3 * Zh, e);
                return t.texture.mapping = Ie, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
            }

            function wd(e, t, n, r) {
                var i = 1 / pd.getPixelRatio();
                e *= i, t *= i, n *= i, r *= i, pd.setViewport(e, t, n, r), pd.setScissor(e, t, n, r)
            }

            function Sd(e) {
                var t = pd.autoClear;
                pd.autoClear = !1;
                for (var n = 1; n < Jh; n++) {
                    Md(e, n - 1, n, Math.sqrt(hd[n] * hd[n] - hd[n - 1] * hd[n - 1]), vd[(n - 1) % vd.length])
                }
                pd.autoClear = t
            }

            function Md(e, t, n, r, i) {
                Td(e, dd, t, n, r, "latitudinal", i), Td(dd, e, n, n, r, "longitudinal", i)
            }

            function Td(e, t, n, r, i, o, a) {
                "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
                var s = new mn;
                s.add(new Jr(cd[r], od));
                var l = od.uniforms,
                    c = ud[n] - 1,
                    u = isFinite(i) ? Math.PI / (2 * c) : 2 * Math.PI / (2 * Qh - 1),
                    h = i / u,
                    d = isFinite(i) ? 1 + Math.floor(3 * h) : Qh;
                Qh < d && console.warn("sigmaRadians, " + i + ", is too large and will clip, as it requested " + d + " samples when the maximum is set to " + Qh);
                for (var p = [], f = 0, m = 0; m < Qh; ++m) {
                    var v = m / h,
                        g = Math.exp(-v * v / 2);
                    p.push(g), 0 == m ? f += g : m < d && (f += 2 * g)
                }
                for (m = 0; m < p.length; m++) p[m] = p[m] / f;
                l.envMap.value = e.texture, l.samples.value = d, l.weights.value = p, l.latitudinal.value = "latitudinal" === o, a && (l.poleAxis.value = a), l.dTheta.value = u, l.mipInt.value = Yh - n, l.inputEncoding.value = $h[e.texture.encoding], l.outputEncoding.value = $h[e.texture.encoding];
                var y = ud[r],
                    x = (v = 3 * Math.max(0, Zh - 2 * y), (0 === r ? 0 : 2 * Zh) + 2 * y * (Yh - Xh < r ? r - Yh + Xh : 0));
                pd.setRenderTarget(t), wd(v, x, 3 * y, 2 * y), pd.render(s, id)
            }

            function Ed() {
                var e = new Ul({
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        texelSize: {
                            value: new Lt(1, 1)
                        },
                        inputEncoding: {
                            value: $h[ut]
                        },
                        outputEncoding: {
                            value: $h[ut]
                        }
                    },
                    vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
                    fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
                    blending: Q,
                    depthTest: !1,
                    depthWrite: !1
                });
                return e.type = "EquirectangularToCubeUV", e
            }

            function Cd() {
                var e = new Ul({
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        inputEncoding: {
                            value: $h[ut]
                        },
                        outputEncoding: {
                            value: $h[ut]
                        }
                    },
                    vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
                    fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
                    blending: Q,
                    depthTest: !1,
                    depthWrite: !1
                });
                return e.type = "CubemapToCubeUV", e
            }
            gd.prototype = {
                constructor: gd,
                fromScene: function(e, t, n, r) {
                    void 0 === t && (t = 0), void 0 === n && (n = .1), void 0 === r && (r = 100);
                    var i = yd();
                    return function(e, t, n, r) {
                        var i = new fi(90, 1, t, n),
                            o = [1, 1, 1, 1, -1, 1],
                            a = [1, 1, -1, -1, -1, 1],
                            s = pd.outputEncoding,
                            l = pd.toneMapping,
                            c = pd.toneMappingExposure,
                            u = pd.getClearColor(),
                            h = pd.getClearAlpha();
                        pd.toneMapping = Ae, pd.toneMappingExposure = 1, pd.outputEncoding = ut, e.scale.z *= -1;
                        var d = e.background;
                        if (d && d.isColor) {
                            d.convertSRGBToLinear();
                            var p = Math.max(d.r, d.g, d.b),
                                f = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127);
                            d = d.multiplyScalar(Math.pow(2, -f));
                            var m = (f + 128) / 255;
                            pd.setClearColor(d, m), e.background = null
                        }
                        pd.setRenderTarget(r);
                        for (var v = 0; v < 6; v++) {
                            var g = v % 3;
                            0 == g ? (i.up.set(0, o[v], 0), i.lookAt(a[v], 0, 0)) : 1 == g ? (i.up.set(0, 0, o[v]), i.lookAt(0, a[v], 0)) : (i.up.set(0, o[v], 0), i.lookAt(0, 0, a[v])), wd(g * Zh, 2 < v ? Zh : 0, Zh, Zh), pd.render(e, i)
                        }
                        pd.toneMapping = l, pd.toneMappingExposure = c, pd.outputEncoding = s, pd.setClearColor(u, h), e.scale.z *= -1
                    }(e, n, r, i), 0 < t && Md(i, 0, 0, t), Sd(i), xd(), i.scissorTest = !1, i
                },
                fromEquirectangular: function(e) {
                    return e.magFilter = Fe, e.minFilter = Fe, e.generateMipmaps = !1, this.fromCubemap(e)
                },
                fromCubemap: function(e) {
                    var t = yd(e);
                    return function(e, t) {
                        var n = new mn;
                        e.isCubeTexture ? null == sd && (sd = Cd()) : null == ad && (ad = Ed());
                        var r = e.isCubeTexture ? sd : ad;
                        n.add(new Jr(cd[0], r));
                        var i = r.uniforms;
                        (i.envMap.value = e).isCubeTexture || i.texelSize.value.set(1 / e.image.width, 1 / e.image.height);
                        i.inputEncoding.value = $h[e.encoding], i.outputEncoding.value = $h[e.encoding], pd.setRenderTarget(t), wd(0, 0, 3 * Zh, 2 * Zh), pd.render(n, id)
                    }(e, t), Sd(t), xd(), t.scissorTest = !1, t
                },
                compileCubemapShader: function() {
                    null == sd && bd(sd = Cd())
                },
                compileEquirectangularShader: function() {
                    null == ad && bd(ad = Ed())
                },
                dispose: function() {
                    od.dispose(), null != sd && sd.dispose(), null != ad && ad.dispose();
                    for (var e = 0; e < cd.length; e++) cd[e].dispose()
                }
            };

            function Ld(e) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Pc.call(this, e), this.type = "catmullrom", this.closed = !0
            }

            function Ad(e) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Pc.call(this, e), this.type = "catmullrom"
            }

            function Rd(e) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Pc.call(this, e), this.type = "catmullrom"
            }
            Sc.create = function(e, t) {
                return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Sc.prototype), (e.prototype.constructor = e).prototype.getPoint = t, e
            }, Object.assign(Vc.prototype, {
                createPointsGeometry: function(e) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getPoints(e);
                    return this.createGeometry(t)
                },
                createSpacedPointsGeometry: function(e) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getSpacedPoints(e);
                    return this.createGeometry(t)
                },
                createGeometry: function(e) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var t = new ii, n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.vertices.push(new Ot(i.x, i.y, i.z || 0))
                    }
                    return t
                }
            }), Object.assign(Wc.prototype, {
                fromPoints: function(e) {
                    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
                }
            }), Ld.prototype = Object.create(Pc.prototype), Ad.prototype = Object.create(Pc.prototype), Rd.prototype = Object.create(Pc.prototype), Object.assign(Rd.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), Lh.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, wh.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(fc.prototype, {
                extractUrlBase: function(e) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ou.extractUrlBase(e)
                }
            }), fc.Handlers = {
                add: function() {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function() {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            }, Object.assign(uu.prototype, {
                setTexturePath: function(e) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
                }
            }), Object.assign(dh.prototype, {
                center: function(e) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(e) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                size: function(e) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
                }
            }), Object.assign(An.prototype, {
                center: function(e) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(e) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                isIntersectionSphere: function(e) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                },
                size: function(e) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
                }
            }), mh.prototype.center = function(e) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, Object.assign(Ct, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(e) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ct.floorPowerOfTwo(e)
                },
                nextPowerOfTwo: function(e) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ct.ceilPowerOfTwo(e)
                }
            }), Object.assign(Nt.prototype, {
                flattenToArrayOffset: function(e, t) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                },
                multiplyVector3: function(e) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function(e) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(Zt.prototype, {
                extractPosition: function(e) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
                },
                flattenToArrayOffset: function(e, t) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                },
                getPosition: function() {
                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Ot).setFromMatrixColumn(this, 3)
                },
                setRotationFromQuaternion: function(e) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(e) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector4: function(e) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(e) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
                },
                crossVector: function(e) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(e) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(e, t, n, r, i, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, o)
                }
            }), Wn.prototype.isIntersectionLine = function(e) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
            }, At.prototype.multiplyVector3 = function(e) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
            }, Object.assign(Un.prototype, {
                isIntersectionBox: function(e) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                isIntersectionPlane: function(e) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
                },
                isIntersectionSphere: function(e) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                }
            }), Object.assign(tr.prototype, {
                area: function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function(e, t) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
                },
                midpoint: function(e) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
                },
                normal: function(e) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
                },
                plane: function(e) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
                }
            }), Object.assign(tr, {
                barycoordFromPoint: function(e, t, n, r, i) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), tr.getBarycoord(e, t, n, r, i)
                },
                normal: function(e, t, n, r) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), tr.getNormal(e, t, n, r)
                }
            }), Object.assign(jc.prototype, {
                extractAllPoints: function(e) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
                },
                extrude: function(e) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new vl(this, e)
                },
                makeGeometry: function(e) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ll(this, e)
                }
            }), Object.assign(Lt.prototype, {
                fromAttribute: function(e, t, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function(e) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Ot.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(e) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
                },
                getScaleFromMatrix: function(e) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
                },
                getColumnFromMatrix: function(e, t) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
                },
                applyProjection: function(e) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
                },
                fromAttribute: function(e, t, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function(e) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Bt.prototype, {
                fromAttribute: function(e, t, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(ii.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(fn.prototype, {
                getChildByName: function(e) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(e, t) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(fn.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(e) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.assign(Jr.prototype, {
                setDrawMode: function() {
                    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }), Object.defineProperties(Jr.prototype, {
                drawMode: {
                    get: function() {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                    },
                    set: function() {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }), Object.defineProperties(Ya.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(Qa.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Za.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(Sc.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(e) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
                }
            }), fi.prototype.setLens = function(e, t) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
            }, Object.defineProperties(qc.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                    }
                },
                shadowCameraLeft: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                    }
                },
                shadowCameraRight: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                    }
                },
                shadowCameraTop: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                    }
                },
                shadowCameraBottom: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                    }
                },
                shadowCameraNear: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                    }
                },
                shadowCameraFar: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                    }
                },
                shadowMapHeight: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                    }
                }
            }), Object.defineProperties(fr.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === St
                    },
                    set: function() {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(St)
                    }
                }
            }), Object.assign(fr.prototype, {
                setDynamic: function(e) {
                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? St : wt), this
                },
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                },
                setArray: function() {
                    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }
            }), Object.assign(Ir.prototype, {
                addIndex: function(e) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
                },
                addAttribute: function(e, t) {
                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new fr(t, arguments[2])))
                },
                addDrawCall: function(e, t, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                },
                removeAttribute: function(e) {
                    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
                }
            }), Object.defineProperties(Ir.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.defineProperties(Ca.prototype, {
                dynamic: {
                    get: function() {
                        return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === St
                    },
                    set: function(e) {
                        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e)
                    }
                }
            }), Object.assign(Ca.prototype, {
                setDynamic: function(e) {
                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? St : wt), this
                },
                setArray: function() {
                    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }
            }), Object.assign(gl.prototype, {
                getArrays: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(ih.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(hr.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new or
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
                    }
                },
                stencilMask: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function(e) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
                    }
                }
            }), Object.defineProperties(Vl.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(di.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(e) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                    }
                }
            }), Object.assign(Ma.prototype, {
                clearTarget: function(e, t, n, r) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r)
                },
                animate: function(e) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
                },
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(e) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                },
                allocTextureUnit: function() {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                },
                setTexture: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                },
                setTexture2D: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                },
                setTextureCube: function() {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                },
                getActiveMipMapLevel: function() {
                    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
                }
            }), Object.defineProperties(Ma.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                },
                vr: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                    }
                },
                gammaInput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                    }
                },
                gammaOutput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? t : ut
                    }
                }
            }), Object.defineProperties(ma.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(vi.prototype, {
                activeCubeFace: {
                    set: function() {
                        console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
                    }
                },
                activeMipMapLevel: {
                    set: function() {
                        console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
                    }
                }
            }), Object.defineProperties(Ut.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                    }
                }
            }), Object.defineProperties(Nu.prototype, {
                load: {
                    value: function(e) {
                        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                        var t = this;
                        return (new _u).load(e, function(e) {
                            t.setBuffer(e)
                        }), this
                    }
                },
                startTime: {
                    set: function() {
                        console.warn("THREE.Audio: .startTime is now .play( delay ).")
                    }
                }
            }), Hu.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, mi.prototype.updateCubeMap = function(e, t) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
            };
            var Pd = {
                merge: function(e, t, n) {
                    var r;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
                },
                center: function(e) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
                }
            };
            kt.crossOrigin = void 0, kt.loadTexture = function(e, t, n, r) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var i = new wc;
                i.setCrossOrigin(this.crossOrigin);
                var o = i.load(e, n, void 0, r);
                return t && (o.mapping = t), o
            }, kt.loadTextureCube = function(e, t, n, r) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var i = new _c;
                i.setCrossOrigin(this.crossOrigin);
                var o = i.load(e, n, void 0, r);
                return t && (o.mapping = t), o
            }, kt.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, kt.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            var Od = {
                createMultiMaterialObject: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: "112"
                }
            })), e.ACESFilmicToneMapping = j, e.AddEquation = ie, e.AddOperation = U, e.AdditiveBlending = ee, e.AlphaFormat = h, e.AlwaysDepth = _e, e.AlwaysStencilFunc = _t, e.AmbientLight = nu, e.AmbientLightProbe = Tu, e.AnimationClip = cc, e.AnimationLoader = gc, e.AnimationMixer = rh, e.AnimationObjectGroup = th, e.AnimationUtils = Kl, e.ArcCurve = Tc, e.ArrayCamera = _a, e.ArrowHelper = jh, e.Audio = Nu, e.AudioAnalyser = Hu, e.AudioContext = bu, e.AudioListener = Du, e.AudioLoader = _u, e.AxesHelper = qh, e.AxisHelper = function(e) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new qh(e)
            }, e.BackSide = Me, e.BasicDepthPacking = vt, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(e) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new xc(e)
            }, e.Bone = $a, e.BooleanKeyframeTrack = nc, e.BoundingBoxHelper = function(e, t) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Bh(e, t)
            }, e.Box2 = dh, e.Box3 = An, e.Box3Helper = Uh, e.BoxBufferGeometry = ai, e.BoxGeometry = oi, e.BoxHelper = Bh, e.BufferAttribute = fr, e.BufferGeometry = Ir, e.BufferGeometryLoader = lu, e.ByteType = i, e.Cache = hc, e.Camera = pi, e.CameraHelper = kh, e.CanvasRenderer = function() {
                console.error("THREE.CanvasRenderer has been removed")
            }, e.CanvasTexture = Ts, e.CatmullRomCurve3 = Pc, e.CineonToneMapping = W, e.CircleBufferGeometry = zl, e.CircleGeometry = kl, e.ClampToEdgeWrapping = ke, e.Clock = Au, e.ClosedSplineCurve3 = Ld, e.Color = or, e.ColorKeyframeTrack = rc, e.CompressedTexture = Ms, e.CompressedTextureLoader = yc, e.ConeBufferGeometry = Nl, e.ConeGeometry = Dl, e.CubeCamera = mi, e.CubeGeometry = oi, e.CubeReflectionMapping = q, e.CubeRefractionMapping = X, e.CubeTexture = Bi, e.CubeTextureLoader = _c, e.CubeUVReflectionMapping = Ie, e.CubeUVRefractionMapping = De, e.CubicBezierCurve = Nc, e.CubicBezierCurve3 = kc, e.CubicInterpolant = Ql, e.CullFaceBack = Z, e.CullFaceFront = K, e.CullFaceFrontBack = 3, e.CullFaceNone = Y, e.Curve = Sc, e.CurvePath = Vc, e.CustomBlending = re, e.CylinderBufferGeometry = Il, e.CylinderGeometry = Ol, e.Cylindrical = uh, e.DataTexture = gi, e.DataTexture2DArray = Ui, e.DataTexture3D = Hi, e.DataTextureLoader = xc, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = pc, e.DepthFormat = Qe, e.DepthStencilFormat = $e, e.DepthTexture = Es, e.DirectionalLight = tu, e.DirectionalLightHelper = Ih, e.DirectionalLightShadow = eu, e.DiscreteInterpolant = ec, e.DodecahedronBufferGeometry = Bs, e.DodecahedronGeometry = Fs, e.DoubleSide = J, e.DstAlphaFactor = me, e.DstColorFactor = ge, e.DynamicBufferAttribute = function(e, t) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new fr(e, t).setDynamic(!0)
            }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = St, e.DynamicReadUsage = 35049, e.EdgesGeometry = Pl, e.EdgesHelper = function(e, t) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new fs(new Pl(e.geometry), new os({
                    color: void 0 !== t ? t : 16777215
                }))
            }, e.EllipseCurve = Mc, e.EqualDepth = Te, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = Re, e.EquirectangularRefractionMapping = Pe, e.Euler = Qt, e.EventDispatcher = Mt, e.ExtrudeBufferGeometry = gl, e.ExtrudeGeometry = vl, e.Face3 = cr, e.Face4 = function(e, t, n, r, i, o, a) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new cr(e, t, n, i, o, a)
            }, e.FaceColors = 1, e.FileLoader = vc, e.FlatShading = 1, e.Float32Attribute = function(e, t) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new wr(e, t)
            }, e.Float32BufferAttribute = wr, e.Float64Attribute = function(e, t) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Sr(e, t)
            }, e.Float64BufferAttribute = Sr, e.FloatType = Xe, e.Fog = Ea, e.FogExp2 = Ta, e.Font = gu, e.FontLoader = xu, e.FrontFaceDirectionCCW = 1, e.FrontFaceDirectionCW = 0, e.FrontSide = P, e.Frustum = bi, e.GammaEncoding = n, e.Geometry = ii, e.GeometryUtils = Pd, e.GreaterDepth = Ce, e.GreaterEqualDepth = Ee, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = Lh, e.Group = wa, e.HalfFloatType = Ye, e.HemisphereLight = Xc, e.HemisphereLightHelper = Ch, e.HemisphereLightProbe = Mu, e.IcosahedronBufferGeometry = zs, e.IcosahedronGeometry = ks, e.ImageBitmapLoader = mu, e.ImageLoader = bc, e.ImageUtils = kt, e.ImmediateRenderObject = vh, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = su, e.InstancedBufferGeometry = au, e.InstancedInterleavedBuffer = oh, e.InstancedMesh = is, e.Int16Attribute = function(e, t) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new yr(e, t)
            }, e.Int16BufferAttribute = yr, e.Int32Attribute = function(e, t) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new br(e, t)
            }, e.Int32BufferAttribute = br, e.Int8Attribute = function(e, t) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new mr(e, t)
            }, e.Int8BufferAttribute = mr, e.IntType = s, e.InterleavedBuffer = Ca, e.InterleavedBufferAttribute = Ra, e.Interpolant = Jl, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.InvertStencilOp = 5386, e.JSONLoader = function() {
                console.error("THREE.JSONLoader has been removed.")
            }, e.KeepStencilOp = bt, e.KeyframeTrack = tc, e.LOD = Ya, e.LatheBufferGeometry = Cl, e.LatheGeometry = El, e.Layers = $t, e.LensFlare = function() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }, e.LessDepth = we, e.LessEqualDepth = Se, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = qc, e.LightProbe = Su, e.LightShadow = Yc, e.Line = hs, e.Line3 = mh, e.LineBasicMaterial = os, e.LineCurve = zc, e.LineCurve3 = Fc, e.LineDashedMaterial = Yl, e.LineLoop = ms, e.LinePieces = 1, e.LineSegments = fs, e.LineStrip = 0, e.LinearEncoding = ut, e.LinearFilter = He, e.LinearInterpolant = $l, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = Ve, e.LinearMipmapNearestFilter = Ge, e.LinearToneMapping = Ae, e.Loader = fc, e.LoaderUtils = ou, e.LoadingManager = dc, e.LogLuvEncoding = dt, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = p, e.LuminanceFormat = d, e.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2
            }, e.Material = hr, e.MaterialLoader = iu, e.Math = Ct, e.Matrix3 = Nt, e.Matrix4 = Zt, e.MaxEquation = le, e.Mesh = Jr, e.MeshBasicMaterial = dr, e.MeshDepthMaterial = ha, e.MeshDistanceMaterial = da, e.MeshFaceMaterial = function(e) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
            }, e.MeshLambertMaterial = ql, e.MeshMatcapMaterial = Xl, e.MeshNormalMaterial = jl, e.MeshPhongMaterial = Vl, e.MeshPhysicalMaterial = Gl, e.MeshStandardMaterial = Hl, e.MeshToonMaterial = Wl, e.MinEquation = se, e.MirroredRepeatWrapping = ze, e.MixOperation = B, e.MultiMaterial = function(e) {
                return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, (e.materials = e).clone = function() {
                    return e.slice()
                }, e
            }, e.MultiplyBlending = ne, e.MultiplyOperation = F, e.NearestFilter = Fe, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = Ue, e.NearestMipmapNearestFilter = Be, e.NeverDepth = be, e.NeverStencilFunc = 512, e.NoBlending = Q, e.NoColors = a, e.NoToneMapping = H, e.NormalBlending = $, e.NotEqualDepth = Le, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = ic, e.Object3D = fn, e.ObjectLoader = uu, e.ObjectSpaceNormalMap = xt, e.OctahedronBufferGeometry = Ns, e.OctahedronGeometry = Ds, e.OneFactor = ue, e.OneMinusDstAlphaFactor = ve, e.OneMinusDstColorFactor = ye, e.OneMinusSrcAlphaFactor = fe, e.OneMinusSrcColorFactor = de, e.OrthographicCamera = $c, e.PCFShadowMap = N, e.PCFSoftShadowMap = k, e.PMREMGenerator = gd, e.ParametricBufferGeometry = As, e.ParametricGeometry = Ls, e.Particle = function(e) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Wa(e)
            }, e.ParticleBasicMaterial = function(e) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new vs(e)
            }, e.ParticleSystem = function(e, t) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new _s(e, t)
            }, e.ParticleSystemMaterial = function(e) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new vs(e)
            }, e.Path = Wc, e.PerspectiveCamera = fi, e.Plane = Wn, e.PlaneBufferGeometry = Ci, e.PlaneGeometry = Ei, e.PlaneHelper = Hh, e.PointCloud = function(e, t) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new _s(e, t)
            }, e.PointCloudMaterial = function(e) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new vs(e)
            }, e.PointLight = Qc, e.PointLightHelper = Sh, e.Points = _s, e.PointsMaterial = vs, e.PolarGridHelper = Ah, e.PolyhedronBufferGeometry = Ps, e.PolyhedronGeometry = Rs, e.PositionalAudio = Uu, e.PropertyBinding = eh, e.PropertyMixer = Gu, e.QuadraticBezierCurve = Bc, e.QuadraticBezierCurve3 = Uc, e.Quaternion = At, e.QuaternionKeyframeTrack = ac, e.QuaternionLinearInterpolant = oc, e.REVISION = "112", e.RGBADepthPacking = gt, e.RGBAFormat = Je, e.RGBAIntegerFormat = b, e.RGBA_ASTC_10x10_Format = st, e.RGBA_ASTC_10x5_Format = it, e.RGBA_ASTC_10x6_Format = ot, e.RGBA_ASTC_10x8_Format = at, e.RGBA_ASTC_12x10_Format = lt, e.RGBA_ASTC_12x12_Format = ct, e.RGBA_ASTC_4x4_Format = R, e.RGBA_ASTC_5x4_Format = O, e.RGBA_ASTC_5x5_Format = I, e.RGBA_ASTC_6x5_Format = D, e.RGBA_ASTC_6x6_Format = et, e.RGBA_ASTC_8x5_Format = tt, e.RGBA_ASTC_8x6_Format = nt, e.RGBA_ASTC_8x8_Format = rt, e.RGBA_PVRTC_2BPPV1_Format = L, e.RGBA_PVRTC_4BPPV1_Format = C, e.RGBA_S3TC_DXT1_Format = w, e.RGBA_S3TC_DXT3_Format = S, e.RGBA_S3TC_DXT5_Format = M, e.RGBDEncoding = mt, e.RGBEEncoding = ht, e.RGBEFormat = r, e.RGBFormat = Ke, e.RGBIntegerFormat = x, e.RGBM16Encoding = ft, e.RGBM7Encoding = pt, e.RGB_ETC1_Format = A, e.RGB_PVRTC_2BPPV1_Format = E, e.RGB_PVRTC_4BPPV1_Format = T, e.RGB_S3TC_DXT1_Format = _, e.RGFormat = v, e.RGIntegerFormat = y, e.RawShaderMaterial = Ul, e.Ray = Un, e.Raycaster = ah, e.RectAreaLight = ru, e.RedFormat = f, e.RedIntegerFormat = m, e.ReinhardToneMapping = G, e.RepeatWrapping = Ne, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = ae, e.RingBufferGeometry = Tl, e.RingGeometry = Ml, e.Scene = mn, e.SceneUtils = Od, e.ShaderChunk = _i, e.ShaderLib = Si, e.ShaderMaterial = di, e.ShadowMaterial = Bl, e.Shape = jc, e.ShapeBufferGeometry = Al, e.ShapeGeometry = Ll, e.ShapePath = vu, e.ShapeUtils = pl, e.ShortType = o, e.Skeleton = Qa, e.SkeletonHelper = wh, e.SkinnedMesh = Za, e.SmoothShading = 2, e.Sphere = On, e.SphereBufferGeometry = Sl, e.SphereGeometry = wl, e.Spherical = ch, e.SphericalHarmonics3 = wu, e.SphericalReflectionMapping = Oe, e.Spline = Rd, e.SplineCurve = Hc, e.SplineCurve3 = Ad, e.SpotLight = Kc, e.SpotLightHelper = yh, e.SpotLightShadow = Zc, e.Sprite = Wa, e.SpriteMaterial = Pa, e.SrcAlphaFactor = pe, e.SrcAlphaSaturateFactor = xe, e.SrcColorFactor = he, e.StaticCopyUsage = 35046, e.StaticDrawUsage = wt, e.StaticReadUsage = 35045, e.StereoCamera = Lu, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = sc, e.SubtractEquation = oe, e.SubtractiveBlending = te, e.TOUCH = {
                ROTATE: 0,
                PAN: 1,
                DOLLY_PAN: 2,
                DOLLY_ROTATE: 3
            }, e.TangentSpaceNormalMap = yt, e.TetrahedronBufferGeometry = Is, e.TetrahedronGeometry = Os, e.TextBufferGeometry = _l, e.TextGeometry = bl, e.Texture = Ft, e.TextureLoader = wc, e.TorusBufferGeometry = js, e.TorusGeometry = Ws, e.TorusKnotBufferGeometry = Vs, e.TorusKnotGeometry = Gs, e.Triangle = tr, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = Hs, e.TubeGeometry = Us, e.UVMapping = 300, e.Uint16Attribute = function(e, t) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new xr(e, t)
            }, e.Uint16BufferAttribute = xr, e.Uint32Attribute = function(e, t) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new _r(e, t)
            }, e.Uint32BufferAttribute = _r, e.Uint8Attribute = function(e, t) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new vr(e, t)
            }, e.Uint8BufferAttribute = vr, e.Uint8ClampedAttribute = function(e, t) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new gr(e, t)
            }, e.Uint8ClampedBufferAttribute = gr, e.Uncharted2ToneMapping = V, e.Uniform = ih, e.UniformsLib = wi, e.UniformsUtils = ci, e.UnsignedByteType = We, e.UnsignedInt248Type = Ze, e.UnsignedIntType = qe, e.UnsignedShort4444Type = l, e.UnsignedShort5551Type = c, e.UnsignedShort565Type = u, e.UnsignedShortType = je, e.VSMShadowMap = z, e.Vector2 = Lt, e.Vector3 = Ot, e.Vector4 = Bt, e.VectorKeyframeTrack = lc, e.Vertex = function(e, t, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Ot(e, t, n)
            }, e.VertexColors = g, e.VideoTexture = Ss, e.WebGLMultisampleRenderTarget = Ht, e.WebGLRenderTarget = Ut, e.WebGLRenderTargetCube = vi, e.WebGLRenderer = Ma, e.WebGLUtils = ya, e.WireframeGeometry = Cs, e.WireframeHelper = function(e, t) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new fs(new Cs(e.geometry), new os({
                    color: void 0 !== t ? t : 16777215
                }))
            }, e.WrapAroundEnding = 2402, e.XHRLoader = function(e) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new vc(e)
            }, e.ZeroCurvatureEnding = 2400, e.ZeroFactor = ce, e.ZeroSlopeEnding = 2401, e.ZeroStencilOp = 0, e.sRGBEncoding = t, Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, "object" == typeof n && void 0 !== t ? i(n) : "function" == typeof define && define.amd ? define(["exports"], i) : i((r = r || self).THREE = {})
    }, {}],
    58: [function(e, t, n) {
        "use strict";
        var r = e("three"),
            i = e("mout/object/mixIn"),
            o = e("./cameraPlacements");

        function a(e) {
            i(this, {
                id: "",
                type: "",
                needsApplyPosition: !1,
                needsApplyQuaternion: !1,
                position: new r.Vector3,
                quaternion: new r.Quaternion,
                opacity: 1,
                count: 0,
                fov: 60
            }, e), this.data = o[this.id], this.data && this.data.length && (this.count = this.data.length)
        }
        t.exports = a;
        var s = a.prototype;
        s.preInit = function() {}, s.init = function() {}, s.show = function() {}, s.hide = function() {}, s.reset = function() {}, s.update = function(e) {}
    }, {
        "./cameraPlacements": 64,
        "mout/object/mixIn": 32,
        three: 57
    }],
    59: [function(e, t, n) {
        "use strict";
        var r = e("../core/settings"),
            i = (e("../core/properties"), e("./CameraMode")),
            o = e("three"),
            a = e("mout/object/mixIn"),
            s = e("./OrbitControls");

        function l(e) {
            c.constructor.call(this, a({
                type: "free",
                needsApplyPosition: !0,
                needsApplyQuaternion: !0,
                fov: 45,
                controls: null,
                camera: null,
                ratio: 0
            }, e))
        }
        var c = i.prototype,
            u = l.prototype = Object.create(c);
        t.exports = l, u.init = function() {
            this.camera = new o.PerspectiveCamera, this.controls = new s(this.camera, r.canvas), this.controls.target0.set(4.1, 2, 3), this.controls.position0.set(4.1, 4, 15), this.controls.zoom0 = 1, this.controls.reset()
        }, u.show = function() {
            this.controls.enableDamping = !1, this.controls.update(0), this.controls.enableDamping = !0, this.controls.reset()
        }, u.update = function(e) {
            this.controls.update(e), this.position.copy(this.camera.position), this.quaternion.copy(this.camera.quaternion), c.update.call(this, e)
        };
        new o.Vector3
    }, {
        "../core/properties": 67,
        "../core/settings": 68,
        "./CameraMode": 58,
        "./OrbitControls": 60,
        "mout/object/mixIn": 32,
        three: 57
    }],
    60: [function(e, t, n) {
        "use strict";
        var ne = e("three");
        t.exports = ne.OrbitControls = function(e, t) {
            var n, r, i, o, a;
            this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.target = new ne.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !0, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !1, this.keys = {
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                BOTTOM: 40
            }, this.mouseButtons = {
                LEFT: ne.MOUSE.ROTATE,
                MIDDLE: ne.MOUSE.DOLLY,
                RIGHT: ne.MOUSE.PAN
            }, this.touches = {
                ONE: ne.TOUCH.ROTATE,
                TWO: ne.TOUCH.DOLLY_PAN
            }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
                return f.phi
            }, this.getAzimuthalAngle = function() {
                return f.theta
            }, this.saveState = function() {
                s.target0.copy(s.target), s.position0.copy(s.object.position), s.zoom0 = s.object.zoom
            }, this.reset = function() {
                s.target.copy(s.target0), s.object.position.copy(s.position0), s.object.zoom = s.zoom0, s.object.updateProjectionMatrix(), s.dispatchEvent(l), s.update(), d = h.NONE
            }, this.update = (n = new ne.Vector3, r = (new ne.Quaternion).setFromUnitVectors(e.up, new ne.Vector3(0, 1, 0)), i = r.clone().inverse(), o = new ne.Vector3, a = new ne.Quaternion, function() {
                var e = s.object.position;
                return n.copy(e).sub(s.target), n.applyQuaternion(r), f.setFromVector3(n), s.autoRotate && d === h.NONE && A(2 * Math.PI / 60 / 60 * s.autoRotateSpeed), s.enableDamping ? (f.theta += m.theta * s.dampingFactor, f.phi += m.phi * s.dampingFactor) : (f.theta += m.theta, f.phi += m.phi), f.theta = Math.max(s.minAzimuthAngle, Math.min(s.maxAzimuthAngle, f.theta)), f.phi = Math.max(s.minPolarAngle, Math.min(s.maxPolarAngle, f.phi)), f.makeSafe(), f.radius *= v, f.radius = Math.max(s.minDistance, Math.min(s.maxDistance, f.radius)), !0 === s.enableDamping ? s.target.addScaledVector(g, s.dampingFactor) : s.target.add(g), n.setFromSpherical(f), n.applyQuaternion(i), e.copy(s.target).add(n), s.object.lookAt(s.target), !0 === s.enableDamping ? (m.theta *= 1 - s.dampingFactor, m.phi *= 1 - s.dampingFactor, g.multiplyScalar(1 - s.dampingFactor)) : (m.set(0, 0, 0), g.set(0, 0, 0)), v = 1, !(!(y || o.distanceToSquared(s.object.position) > p || 8 * (1 - a.dot(s.object.quaternion)) > p) || (s.dispatchEvent(l), o.copy(s.object.position), a.copy(s.object.quaternion), y = !1))
            }), this.dispose = function() {
                s.domElement.removeEventListener("contextmenu", te, !1), s.domElement.removeEventListener("mousedown", X, !1), s.domElement.removeEventListener("wheel", K, !1), s.domElement.removeEventListener("touchstart", Q, !1), s.domElement.removeEventListener("touchend", ee, !1), s.domElement.removeEventListener("touchmove", $, !1), document.removeEventListener("mousemove", Y, !1), document.removeEventListener("mouseup", Z, !1), window.removeEventListener("keydown", J, !1)
            };
            var s = this,
                l = {
                    type: "change"
                },
                c = {
                    type: "start"
                },
                u = {
                    type: "end"
                },
                h = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_PAN: 4,
                    TOUCH_DOLLY_PAN: 5,
                    TOUCH_DOLLY_ROTATE: 6
                },
                d = h.NONE,
                p = 1e-6,
                f = new ne.Spherical,
                m = new ne.Spherical,
                v = 1,
                g = new ne.Vector3,
                y = !1,
                x = new ne.Vector2,
                b = new ne.Vector2,
                _ = new ne.Vector2,
                w = new ne.Vector2,
                S = new ne.Vector2,
                M = new ne.Vector2,
                T = new ne.Vector2,
                E = new ne.Vector2,
                C = new ne.Vector2;

            function L() {
                return Math.pow(.95, s.zoomSpeed)
            }

            function A(e) {
                m.theta -= e
            }

            function R(e) {
                m.phi -= e
            }
            var P, O, I, D = (P = new ne.Vector3, function(e, t) {
                    P.setFromMatrixColumn(t, 0), P.multiplyScalar(-e), g.add(P)
                }),
                N = (O = new ne.Vector3, function(e, t) {
                    !0 === s.screenSpacePanning ? O.setFromMatrixColumn(t, 1) : (O.setFromMatrixColumn(t, 0), O.crossVectors(s.object.up, O)), O.multiplyScalar(e), g.add(O)
                }),
                k = (I = new ne.Vector3, function(e, t) {
                    var n = s.domElement === document ? s.domElement.body : s.domElement;
                    if (s.object.isPerspectiveCamera) {
                        var r = s.object.position;
                        I.copy(r).sub(s.target);
                        var i = I.length();
                        i *= Math.tan(s.object.fov / 2 * Math.PI / 180), D(2 * e * i / n.clientHeight, s.object.matrix), N(2 * t * i / n.clientHeight, s.object.matrix)
                    } else s.object.isOrthographicCamera ? (D(e * (s.object.right - s.object.left) / s.object.zoom / n.clientWidth, s.object.matrix), N(t * (s.object.top - s.object.bottom) / s.object.zoom / n.clientHeight, s.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), s.enablePan = !1)
                });

            function z(e) {
                s.object.isPerspectiveCamera ? v /= e : s.object.isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom * e)), s.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1)
            }

            function F(e) {
                s.object.isPerspectiveCamera ? v *= e : s.object.isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom / e)), s.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1)
            }

            function B(e) {
                x.set(e.clientX, e.clientY)
            }

            function U(e) {
                w.set(e.clientX, e.clientY)
            }

            function H(e) {
                if (1 == e.touches.length) x.set(e.touches[0].pageX, e.touches[0].pageY);
                else {
                    var t = .5 * (e.touches[0].pageX + e.touches[1].pageX),
                        n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                    x.set(t, n)
                }
            }

            function G(e) {
                if (1 == e.touches.length) w.set(e.touches[0].pageX, e.touches[0].pageY);
                else {
                    var t = .5 * (e.touches[0].pageX + e.touches[1].pageX),
                        n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                    w.set(t, n)
                }
            }

            function V(e) {
                var t = e.touches[0].pageX - e.touches[1].pageX,
                    n = e.touches[0].pageY - e.touches[1].pageY,
                    r = Math.sqrt(t * t + n * n);
                T.set(0, r)
            }

            function W(e) {
                if (1 == e.touches.length) b.set(e.touches[0].pageX, e.touches[0].pageY);
                else {
                    var t = .5 * (e.touches[0].pageX + e.touches[1].pageX),
                        n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                    b.set(t, n)
                }
                _.subVectors(b, x).multiplyScalar(s.rotateSpeed);
                var r = s.domElement === document ? s.domElement.body : s.domElement;
                A(2 * Math.PI * _.x / r.clientHeight), R(2 * Math.PI * _.y / r.clientHeight), x.copy(b)
            }

            function j(e) {
                if (1 == e.touches.length) S.set(e.touches[0].pageX, e.touches[0].pageY);
                else {
                    var t = .5 * (e.touches[0].pageX + e.touches[1].pageX),
                        n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                    S.set(t, n)
                }
                M.subVectors(S, w).multiplyScalar(s.panSpeed), k(M.x, M.y), w.copy(S)
            }

            function q(e) {
                var t = e.touches[0].pageX - e.touches[1].pageX,
                    n = e.touches[0].pageY - e.touches[1].pageY,
                    r = Math.sqrt(t * t + n * n);
                E.set(0, r), C.set(0, Math.pow(E.y / T.y, s.zoomSpeed)), z(C.y), T.copy(E)
            }

            function X(e) {
                if (!1 !== s.enabled) {
                    switch (e.preventDefault(), s.domElement.focus ? s.domElement.focus() : window.focus(), e.button) {
                        case 0:
                            switch (s.mouseButtons.LEFT) {
                                case ne.MOUSE.ROTATE:
                                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                        if (!1 === s.enablePan) return;
                                        U(e), d = h.PAN
                                    } else {
                                        if (!1 === s.enableRotate) return;
                                        B(e), d = h.ROTATE
                                    }
                                    break;
                                case ne.MOUSE.PAN:
                                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                        if (!1 === s.enableRotate) return;
                                        B(e), d = h.ROTATE
                                    } else {
                                        if (!1 === s.enablePan) return;
                                        U(e), d = h.PAN
                                    }
                                    break;
                                default:
                                    d = h.NONE
                            }
                            break;
                        case 1:
                            switch (s.mouseButtons.MIDDLE) {
                                case ne.MOUSE.DOLLY:
                                    if (!1 === s.enableZoom) return;
                                    ! function(e) {
                                        T.set(e.clientX, e.clientY)
                                    }(e), d = h.DOLLY;
                                    break;
                                default:
                                    d = h.NONE
                            }
                            break;
                        case 2:
                            switch (s.mouseButtons.RIGHT) {
                                case ne.MOUSE.ROTATE:
                                    if (!1 === s.enableRotate) return;
                                    B(e), d = h.ROTATE;
                                    break;
                                case ne.MOUSE.PAN:
                                    if (!1 === s.enablePan) return;
                                    U(e), d = h.PAN;
                                    break;
                                default:
                                    d = h.NONE
                            }
                    }
                    d !== h.NONE && (document.addEventListener("mousemove", Y, !1), document.addEventListener("mouseup", Z, !1), s.dispatchEvent(c))
                }
            }

            function Y(e) {
                if (!1 !== s.enabled) switch (e.preventDefault(), d) {
                    case h.ROTATE:
                        if (!1 === s.enableRotate) return;
                        ! function(e) {
                            b.set(e.clientX, e.clientY), _.subVectors(b, x).multiplyScalar(s.rotateSpeed);
                            var t = s.domElement === document ? s.domElement.body : s.domElement;
                            A(2 * Math.PI * _.x / t.clientHeight), R(2 * Math.PI * _.y / t.clientHeight), x.copy(b), s.update()
                        }(e);
                        break;
                    case h.DOLLY:
                        if (!1 === s.enableZoom) return;
                        ! function(e) {
                            E.set(e.clientX, e.clientY), C.subVectors(E, T), 0 < C.y ? z(L()) : C.y < 0 && F(L()), T.copy(E), s.update()
                        }(e);
                        break;
                    case h.PAN:
                        if (!1 === s.enablePan) return;
                        ! function(e) {
                            S.set(e.clientX, e.clientY), M.subVectors(S, w).multiplyScalar(s.panSpeed), k(M.x, M.y), w.copy(S), s.update()
                        }(e)
                }
            }

            function Z(e) {
                !1 !== s.enabled && (document.removeEventListener("mousemove", Y, !1), document.removeEventListener("mouseup", Z, !1), s.dispatchEvent(u), d = h.NONE)
            }

            function K(e) {
                !1 === s.enabled || !1 === s.enableZoom || d !== h.NONE && d !== h.ROTATE || (e.preventDefault(), e.stopPropagation(), s.dispatchEvent(c), function(e) {
                    e.deltaY < 0 ? F(L()) : 0 < e.deltaY && z(L()), s.update()
                }(e), s.dispatchEvent(u))
            }

            function J(e) {
                !1 !== s.enabled && !1 !== s.enableKeys && !1 !== s.enablePan && function(e) {
                    var t = !1;
                    switch (e.keyCode) {
                        case s.keys.UP:
                            k(0, s.keyPanSpeed), t = !0;
                            break;
                        case s.keys.BOTTOM:
                            k(0, -s.keyPanSpeed), t = !0;
                            break;
                        case s.keys.LEFT:
                            k(s.keyPanSpeed, 0), t = !0;
                            break;
                        case s.keys.RIGHT:
                            k(-s.keyPanSpeed, 0), t = !0
                    }
                    t && (e.preventDefault(), s.update())
                }(e)
            }

            function Q(e) {
                if (!1 !== s.enabled) {
                    switch (e.preventDefault(), e.touches.length) {
                        case 1:
                            switch (s.touches.ONE) {
                                case ne.TOUCH.ROTATE:
                                    if (!1 === s.enableRotate) return;
                                    H(e), d = h.TOUCH_ROTATE;
                                    break;
                                case ne.TOUCH.PAN:
                                    if (!1 === s.enablePan) return;
                                    G(e), d = h.TOUCH_PAN;
                                    break;
                                default:
                                    d = h.NONE
                            }
                            break;
                        case 2:
                            switch (s.touches.TWO) {
                                case ne.TOUCH.DOLLY_PAN:
                                    if (!1 === s.enableZoom && !1 === s.enablePan) return;
                                    ! function(e) {
                                        s.enableZoom && V(e), s.enablePan && G(e)
                                    }(e), d = h.TOUCH_DOLLY_PAN;
                                    break;
                                case ne.TOUCH.DOLLY_ROTATE:
                                    if (!1 === s.enableZoom && !1 === s.enableRotate) return;
                                    ! function(e) {
                                        s.enableZoom && V(e), s.enableRotate && H(e)
                                    }(e), d = h.TOUCH_DOLLY_ROTATE;
                                    break;
                                default:
                                    d = h.NONE
                            }
                            break;
                        default:
                            d = h.NONE
                    }
                    d !== h.NONE && s.dispatchEvent(c)
                }
            }

            function $(e) {
                if (!1 !== s.enabled) switch (e.preventDefault(), e.stopPropagation(), d) {
                    case h.TOUCH_ROTATE:
                        if (!1 === s.enableRotate) return;
                        W(e), s.update();
                        break;
                    case h.TOUCH_PAN:
                        if (!1 === s.enablePan) return;
                        j(e), s.update();
                        break;
                    case h.TOUCH_DOLLY_PAN:
                        if (!1 === s.enableZoom && !1 === s.enablePan) return;
                        ! function(e) {
                            s.enableZoom && q(e), s.enablePan && j(e)
                        }(e), s.update();
                        break;
                    case h.TOUCH_DOLLY_ROTATE:
                        if (!1 === s.enableZoom && !1 === s.enableRotate) return;
                        ! function(e) {
                            s.enableZoom && q(e), s.enableRotate && W(e)
                        }(e), s.update();
                        break;
                    default:
                        d = h.NONE
                }
            }

            function ee(e) {
                !1 !== s.enabled && (s.dispatchEvent(u), d = h.NONE)
            }

            function te(e) {
                !1 !== s.enabled && e.preventDefault()
            }
            s.domElement.addEventListener("contextmenu", te, !1), s.domElement.addEventListener("mousedown", X, !1), s.domElement.addEventListener("wheel", K, !1), s.domElement.addEventListener("touchstart", Q, !1), s.domElement.addEventListener("touchend", ee, !1), s.domElement.addEventListener("touchmove", $, !1), window.addEventListener("keydown", J, !1), this.update()
        }, ne.OrbitControls.prototype = Object.create(ne.EventDispatcher.prototype), ne.OrbitControls.prototype.constructor = ne.OrbitControls, ne.MapControls = function(e, t) {
            ne.OrbitControls.call(this, e, t), this.mouseButtons.LEFT = ne.MOUSE.PAN, this.mouseButtons.RIGHT = ne.MOUSE.ROTATE, this.touches.ONE = ne.TOUCH.PAN, this.touches.TWO = ne.TOUCH.DOLLY_ROTATE
        }, ne.MapControls.prototype = Object.create(ne.EventDispatcher.prototype), ne.MapControls.prototype.constructor = ne.MapControls
    }, {
        three: 57
    }],
    61: [function(e, t, n) {
        "use strict";
        var r = e("../core/settings"),
            o = e("../core/properties"),
            i = e("./CameraMode"),
            a = e("../utils/math"),
            s = e("three"),
            l = e("min-signal"),
            c = e("mout/object/mixIn");

        function u(e) {
            h.constructor.call(this, c({
                type: "spline",
                needsApplyPosition: !0,
                needsApplyQuaternion: !0,
                splineTime: 0,
                totalDuration: 0,
                fadeDuration: 1,
                splineIndex: 0,
                splines: [],
                onAnimationStarted: new l,
                onAnimationRestarted: new l,
                onAllAnimationStarted: new l
            }, e))
        }
        var h = i.prototype,
            d = u.prototype = Object.create(h);
        t.exports = u, d.preInit = function() {
            h.preInit.call(this);
            for (var e = 0; e < this.data.length; e++) o.loader.add(r.MODEL_PATH + "cameraPath" + e + ".buf", {
                type: "xhr",
                responseType: "arraybuffer",
                weight: 5,
                onLoad: this._setSpline.bind(this, e)
            })
        }, d.init = function() {
            h.init.call(this), this.v = new s.Vector3, this.q = new s.Quaternion
        }, d._setSpline = function(e, t) {
            var n = 0,
                r = void 0,
                i = new Int16Array(t, n, 900),
                o = this.data[e].position;
            r = new Float32Array(900);
            for (var a = 0, s = 0; a < 300; a++) r[s + 0] = o[0].from + (i[s + 0] - -32768) / 65535 * o[0].delta, r[s + 1] = o[1].from + (i[s + 1] - -32768) / 65535 * o[1].delta, r[s + 2] = o[2].from + (i[s + 2] - -32768) / 65535 * o[2].delta, s += 3;
            i = r, n += 1800;
            var l = new Int16Array(t, n, 1200),
                c = this.data[e].quaternion;
            r = new Float32Array(1200);
            for (var u = 0, h = 0; u < 300; u++) r[h + 0] = c[0].from + (l[h + 0] - -32768) / 65535 * c[0].delta, r[h + 1] = c[1].from + (l[h + 1] - -32768) / 65535 * c[1].delta, r[h + 2] = c[2].from + (l[h + 2] - -32768) / 65535 * c[2].delta, r[h + 3] = c[3].from + (l[h + 3] - -32768) / 65535 * c[3].delta, h += 4;
            l = r, this.totalDuration += p, this.splines[e] = {
                positions: i,
                quaternions: l
            }
        }, d._applyTransform = function(e, t, n, r) {
            var i = this.splines[e],
                o = t * (i.positions.length / 3 - 1),
                a = Math.floor(o),
                s = Math.ceil(o),
                l = o % 1;
            this.v.fromArray(i.positions, 3 * s), this.q.fromArray(i.quaternions, 4 * s).normalize(), n.fromArray(i.positions, 3 * a).lerp(this.v, l), r.fromArray(i.quaternions, 4 * a).normalize().slerp(this.q, l)
        }, d.show = function() {
            this.splineTime = 0, this.splineIndex = -1
        }, d.restart = function() {
            this.splineIndex = 0, this.splineTime = 0, this.onAnimationRestarted.dispatch(this.splineIndex)
        }, d.update = function(e) {
            var t = this.splineIndex,
                n = !1;
            this.splineTime += e, this.splineTime >= this.totalDuration && (this.splineTime = this.splineTime % this.totalDuration, n = !0);
            this.splineIndex = Math.floor(this.splineTime / p);
            var r = this.splineTime - this.splineIndex * p,
                i = this.splineTime / p - this.splineIndex;
            this._applyTransform(this.splineIndex, i, this.position, this.quaternion), this.opacity = a.cUnMix(0, this.fadeDuration, r) * a.cUnMix(p, p - this.fadeDuration, r), h.update.call(this, e), t !== this.splineIndex && o.isHome && this.onAnimationStarted.dispatch(this.splineIndex);
            n && this.onAllAnimationStarted.dispatch()
        };
        var p = 15
    }, {
        "../core/properties": 67,
        "../core/settings": 68,
        "../utils/math": 124,
        "./CameraMode": 58,
        "min-signal": 10,
        "mout/object/mixIn": 32,
        three: 57
    }],
    62: [function(e, t, n) {
        "use strict";
        e("../core/settings"), e("../core/properties");
        var r = e("./CameraMode"),
            i = e("../utils/math"),
            o = (e("three"), e("mout/object/mixIn")),
            a = e("gsap").gsap;

        function s(e) {
            l.constructor.call(this, o({
                type: "still",
                index: 0,
                needsApplyPosition: !0,
                needsApplyQuaternion: !0,
                fov: 45,
                ratio: 0
            }, e))
        }
        var l = r.prototype,
            c = s.prototype = Object.create(l);
        t.exports = s, c.change = function(e, t) {
            if (u) return h = e, void(d = t);
            var n = this;
            u = !(h = null), e = void 0 === e ? n.index + 1 : e, e = i.loop(Math.round(e), n.count), void 0 === t && (t = 1);
            0 === (t = Math.max(t, 0)) ? (a.set(n, {
                ratio: 1
            }), u = !1) : (a.set(n, {
                ratio: 0
            }), a.to(n, t, {
                ratio: 1,
                ease: "linear",
                onUpdate: function() {.5 < n.ratio && (n.index = e)
                },
                onComplete: function() {
                    null !== h ? setTimeout(function() {
                        u = !1, n.change(h, d)
                    }, 4) : u = !1
                }
            }))
        };
        var u = !(c.update = function(e) {
                this.position.fromArray(this.data[this.index].position), this.quaternion.fromArray(this.data[this.index].quaternion), this.opacity = 2 * Math.abs(this.ratio - .5), l.update.call(this, e)
            }),
            h = null,
            d = 0
    }, {
        "../core/properties": 67,
        "../core/settings": 68,
        "../utils/math": 124,
        "./CameraMode": 58,
        gsap: 9,
        "mout/object/mixIn": 32,
        three: 57
    }],
    63: [function(e, t, s) {
        "use strict";
        e("../core/settings");
        var l = e("../core/properties"),
            n = e("../motions/BrownianMotion"),
            c = (e("../utils/math"), e("../utils/ease")),
            r = e("three"),
            i = e("min-signal"),
            u = e("../visual/screen/screen"),
            o = e("./SplineCameraMode"),
            a = e("./StillCameraMode"),
            h = e("./FreeCameraMode");
        s.preInit = function() {
            y = new n;
            var e = void 0;
            e = new o({
                id: "splines"
            }), p.push(d[e.id] = e), e.preInit(), e = new a({
                id: "wide"
            }), p.push(d[e.id] = e), e.preInit(), e = new a({
                id: "narrow"
            }), p.push(d[e.id] = e), e.preInit(), e = new h({
                id: "free"
            }), p.push(d[e.id] = e), e.preInit()
        }, s.init = function() {
            for (var e = 0, t = p.length; e < t; e++) {
                p[e].init()
            }
            w = new r.Plane, x = new r.Vector3, b = new r.Euler, _ = new r.Quaternion, l.onCanvasClicked.add(S), window.getCameraPlacement = function() {
                l.camera.position, l.camera.quaternion;
                console.log(JSON.stringify({
                    position: l.camera.position.toArray(),
                    quaternion: l.camera.quaternion.toArray()
                }, null, "\t"))
            }
        }, s.changeMode = function(e) {
            s.prevId || (s.prevId = e);
            s.currId || (s.currId = e);
            s.pendingId = e
        }, s.update = function(e) {
            if (!s.currId) return;
            var t = g;
            if (1 <= g) {
                g += f ? e / f : 1, g = 1;
                s.prevId;
                s.prevId = s.currId, s.currId, s.currId !== s.pendingId && (s.currId = s.pendingId, g = 0, d[s.prevId].hide())
            } else .5 < (g += f ? e / f : 1) && t <= .5 && d[s.currId].show();
            for (var n = 0, r = p.length; n < r; n++) {
                var i = p[n];
                i.id !== s.prevId && i.id !== s.currId || i.update(e)
            }
            var o = d[g <= .5 ? s.prevId : s.currId];
            o.needsApplyPosition && l.camera.position.copy(o.position);
            o.needsApplyQuaternion && l.camera.quaternion.copy(o.quaternion);
            l.useCameraBrowianMotion && (y.update(e), l.camera.scale.set(1, 1, 1), l.camera.updateMatrix(), l.camera.matrix.multiply(y.matrix), l.camera.matrix.decompose(l.camera.position, l.camera.quaternion, l.camera.scale));
            l.camera.translateZ(-v), b.set(l.easedMouse.y * m, -l.easedMouse.x * m, 0), _.setFromEuler(b), l.camera.quaternion.multiply(_), b.set(0, 0, -.05 * (l.easedMouse.x - l.easedMouse2.x)), _.setFromEuler(b), l.camera.quaternion.multiply(_), l.camera.translateZ(v), this.opacity = Math.abs(2 * g - 1) * o.opacity, l.camera.fov = o.fov + 3 * c.easeInSine(1 - this.opacity), x.copy(u.container.position).sub(l.camera.position), w.normal.set(0, 0, -1).applyQuaternion(l.camera.quaternion);
            var a = 1 * w.distanceToPoint(x);
            a = a * Math.tan(o.fov / 360 * Math.PI / 2) / Math.tan(l.camera.fov / 360 * Math.PI / 2) - a, l.camera.translateZ(a), l.camera.updateMatrixWorld(!0), l.camera.updateProjectionMatrix()
        };
        var d = s.modes = {},
            p = s.modeList = [];
        s.onHidden = new i, s.onShown = new i, s.opacity = 0, s.prevId = "", s.currId = "", s.pendingId = "";
        var f = 0,
            m = .035,
            v = 0,
            g = .5,
            y = void 0,
            x = void 0,
            b = void 0,
            _ = void 0,
            w = void 0;

        function S() {
            "wide" === s.currId ? d.wide.change() : "narrow" === s.currId && d.narrow.change()
        }
    }, {
        "../core/properties": 67,
        "../core/settings": 68,
        "../motions/BrownianMotion": 81,
        "../utils/ease": 123,
        "../utils/math": 124,
        "../visual/screen/screen": 128,
        "./FreeCameraMode": 59,
        "./SplineCameraMode": 61,
        "./StillCameraMode": 62,
        "min-signal": 10,
        three: 57
    }],
    64: [function(e, t, n) {
        "use strict";
        t.exports = {
            wide: [{
                position: [-3.86112, 1.66463, 11.177],
                quaternion: [.0410949, -.258313, .010999, .965124]
            }, {
                position: [6.64309, 1.28259, 10.4538],
                quaternion: [.0613687, .0171891, -.001057, .997967]
            }, {
                position: [10.2943, .394463, 21.1072],
                quaternion: [.0660138, .21823, -.0147976, .97355]
            }, {
                position: [3.76581, .157657, 9.04469],
                quaternion: [.12397, 452596e-9, -565272e-10, .992286]
            }, {
                position: [13.7098, 2.39153, 7.90597],
                quaternion: [.0250148, .44139, -.0123108, .896882]
            }, {
                position: [3.97992, 10.5303, 14.9967],
                quaternion: [-.252286, .00652528, .00170133, .967629]
            }],
            narrow: [{
                position: [6.563506695197463, 1.2053421671044566, 11.721427551851155],
                quaternion: [.07235339920819156, .09268977892721994, -.009104865124938516, .9930209926967806]
            }, {
                position: [4, 3.5, 20],
                quaternion: [0, 0, 0, 1]
            }, {
                position: [17.083583075061483, 3.7632706951573613, 8.618660976614565],
                quaternion: [.0006069572748726825, .48733460058309613, .0030478031878673826, .8732097855458953]
            }, {
                position: [-1.4231127819800278, 6.6314409841695525, 14.066740644149997],
                quaternion: [-.12436861704951953, -.1881080008280786, -.021046071943262527, .9740148304689271]
            }, {
                position: [4.037988775656856, .13405260557406617, 9.36010886058748],
                quaternion: [.12842705872588486, .0020521684483088658, .0009307055713908252, .9917163974538374]
            }, {
                position: [22.273006927926005, 6.905623107518253, 12.374569232631517],
                quaternion: [-.06396713651911962, .5279177269950565, .04136888028015895, .8458721503361385]
            }],
            splines: [{
                position: [{
                    from: 3.06638694,
                    delta: 2.8725926900000003
                }, {
                    from: .956994414,
                    delta: .8530670360000001
                }, {
                    from: 2.6344409,
                    delta: 14.6588616
                }],
                quaternion: [{
                    from: .0627227277,
                    delta: .0321194231
                }, {
                    from: -.116107941,
                    delta: .1985006038
                }, {
                    from: -.00787693076,
                    delta: .015784940679999998
                }, {
                    from: .990909398,
                    delta: .006794214000000021
                }]
            }, {
                position: [{
                    from: 3.00168753,
                    delta: 11.25556897
                }, {
                    from: .437801301,
                    delta: 3.9498205790000003
                }, {
                    from: 6.39744711,
                    delta: 1.2771592099999998
                }],
                quaternion: [{
                    from: -.0536227413,
                    delta: .1736346523
                }, {
                    from: -.0232848153,
                    delta: .5939637643000001
                }, {
                    from: -.0236081462,
                    delta: .0609922055
                }, {
                    from: .818567336,
                    delta: .17443859500000003
                }]
            }, {
                position: [{
                    from: 3.37267137,
                    delta: 8.869496130000002
                }, {
                    from: .229441985,
                    delta: 6.768281115
                }, {
                    from: 5.92908907,
                    delta: 8.18762163
                }],
                quaternion: [{
                    from: -.102323972,
                    delta: .261955463
                }, {
                    from: -.141995147,
                    delta: .2388127075
                }, {
                    from: -.00902517606,
                    delta: .03223437906
                }, {
                    from: .976635277,
                    delta: .01881176299999998
                }]
            }, {
                position: [{
                    from: -4.2088666,
                    delta: 12.62041331
                }, {
                    from: .766577184,
                    delta: 1.8804708159999999
                }, {
                    from: 7.16021013,
                    delta: .21211099999999927
                }],
                quaternion: [{
                    from: .00542296702,
                    delta: .09432551028
                }, {
                    from: -.0353215225,
                    delta: .3305241355
                }, {
                    from: -.00778369606,
                    delta: .0100206153
                }, {
                    from: .955417812,
                    delta: .04366457400000001
                }]
            }]
        }
    }, {}],
    65: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = void 0,
            i = "Webkit Moz O ms".split(" "),
            o = document.createElement("div").style,
            a = window,
            s = document,
            l = (navigator.userAgent || navigator.vendor || window.opera).toLowerCase(),
            c = (n.videoFormat = d("video", ["video/mp4", "video/ogv"]), n.audioFormat = d("audio", ["audio/mp3", "audio/ogg"]), n.isIFrame = a.self !== a.top, n.isRetina = a.devicePixelRatio && 1.5 <= a.devicePixelRatio, n.isSupportOpacity = o.opacity !== r, n.cpuCoreCount = navigator.hardwareConcurrency || 1, n.isEdge = -1 < l.indexOf("edge")),
            u = n.isIE = -1 < l.indexOf("msie"),
            h = (n.isFirefox = -1 < l.indexOf("firefox"), n.isChrome = !c && -1 < l.indexOf("chrome"));
        n.isSafari = !c && !h && -1 < l.indexOf("safari"), n.isMobile = /(iPad|iPhone|Android)/i.test(l), n.isIOS = /(iPad|iPhone)/i.test(l), n.isMac = /(Mac)/i.test(l), n.filterStyle = u ? r : p("filter"), n.transitionStyle = p("transition"), n.transformStyle = p("transform"), n.transform3dStyle = p("transform", "perspective"), n.transformPerspectiveStyle = p("perspective"), n.transformOriginStyle = p("transformOrigin"), n.WebAudioContext = a.AudioContext || a.webkitAudioContext, n.baseUrl = document.location.origin, n.seedRandom = e("seed-random")("AZ0xEIu9WazVHT");

        function d(t, e) {
            var n = void 0;
            try {
                switch (t) {
                    case "video":
                        n = new a.Video;
                        break;
                    case "audio":
                        n = new a.Audio
                }
            } catch (e) {
                n = s.createElement(t)
            }
            for (var r = void 0, i = 0, o = e.length; i < o; i++)
                if (n.canPlayType && n.canPlayType(e[i])) {
                    r = e[i].substr(e[i].indexOf("/") + 1);
                    break
                }
            return r
        }

        function p(e, t) {
            return function(e, t) {
                return 1 < t ? i[t - 2] + e.charAt(0).toUpperCase() + e.slice(1) : 1 === t && e
            }(e, function(e) {
                var t = e.charAt(0).toUpperCase() + e.slice(1),
                    n = i.length;
                for (; n--;)
                    if (o[i[n] + t] !== r) return n + 2;
                return o[e] === r ? 0 : 1
            }(t || e))
        }
    }, {
        "seed-random": 56
    }],
    66: [function(e, t, n) {
        "use strict";
        var r = e("./browser");
        n.add = function(e) {
            if (window.atob) {
                var t = window.console;
                t && (r.isFirefox || r.isChrome ? t.log.apply(t, ["\n" + (e ? atob("JWMgQ3JlYXRlZCBieSBMdXNpb24gJWMgaHR0cHM6Ly9sdXNpb24uY28vIA==") : atob("JWMgRGV2ZWxvcGVkIGJ5IEx1c2lvbiAlYyBodHRwczovL2x1c2lvbi5jby8g")) + "\n", atob("Y29sb3I6ICNmZmY7IGJhY2tncm91bmQ6ICMyMjI7IHBhZGRpbmc6NXB4IDVweDs="), atob("Y29sb3I6ICM5OTk7IGJhY2tncm91bmQ6ICNGQ0ZDRkM7IHBhZGRpbmc6NXB4IDA7")]) : t.log(atob(e ? "Q3JlYXRlZCBieSBMdXNpb24gLSBodHRwczovL2x1c2lvbi5jby8=" : "RGV2ZWxvcGVkIGJ5IEx1c2lvbiAtIGh0dHBzOi8vbHVzaW9uLmNvLw==")))
            }
        }
    }, {
        "./browser": 65
    }],
    67: [function(e, t, n) {
        "use strict";
        var r = e("min-signal");
        n.loader = e("quick-loader").create(), e("./disclaimer").add(!0), n.gl = null, n.isSupportWebGL = null, n.renderer = null, n.scene = null, n.camera = null, n.postprocessing = null, n.isMouseDown = !1, n.hasMouseJustDown = !1, n.mouse = null, n.mouseDown = null, n.easedMouse = null, n.easedMouse2 = null, n.mouseEaseRatio = .15, n.mouseEaseRatio2 = .02, n.useCameraBrowianMotion = !0, n.sharedUniforms = null, n.resolution = null, n.isStageReady = !1, n.hasInitialized = !1, n.domElement = null, n.shaderTime = 0, n.shaderFrame = 0, n.shaderTimeMultiplier = 1, n.fpsList = [60], n.fps = 0, n.useXR = !1, n.viewQuality = 3, n.width = 0, n.height = 0, n.dpiWidth = 0, n.dpiHeight = 0, n.useHalfScreen = null, n.hasResized = !1, n.forceRenderOnResize = !1, n.pageRatio = 0, n.time = 0, n.bgColor = "#031a24", n.isHome = !1, n.isEditor = !1, n.isView = !1, n.isAbout = !1, n.isPreview = !1, n.useInterlacing = !1, n.currentSketch = null, n.viewSketch = null, n.forkSlotIndex = null, n.onCanvasClicked = new r, n.onShaderCompiled = new r, n.onShaderDataChanged = new r, n.onShaderTemplateChanged = new r, n.onTabChanged = new r, n.onHelperValueChanged = new r, n.modelId = "person", n.templateShaderId = ""
    }, {
        "./disclaimer": 66,
        "min-signal": 10,
        "quick-loader": 45
    }],
    68: [function(e, t, n) {
        "use strict";
        var r = e("mout/lang/isBoolean"),
            i = e("mout/lang/isInteger"),
            o = e("mout/queryString/parse")(window.location.href),
            a = e("./browser");
        for (var s in n.QUERY_STRING = e("mout/queryString/encode")(o), n.MODEL_PATH = "assets/models/", n.TEXTURE_PATH = "assets/textures/", n.SHADER_PATH = "assets/shaders/", n.GLOBAL_ID = "cineNoise", n.API_KEY = "Ntrt4r", n.canvas = null, n.gl = null, n.webglOpts = {
                antialias: !1,
                alpha: !1,
                xrCompatible: !0,
                powerPreference: "high-performance"
            }, n.RENDER_TARGET_FLOAT_TYPE = null, n.DATA_FLOAT_TYPE = null, n.USE_FLOAT_PACKING = !1, n.USE_WEBGL2 = !0, n.SCREEN_RESOLUTION = a.isMobile ? 256 : 512, n.SCREEN_SEGMENTS = n.SCREEN_RESOLUTION - 1, n.SCREEN_SIZE = 6, n.DEFAULT_VIEW_QUALITY = 3, n.skipLoadingAnimation = !1, o)
            if (void 0 !== n[s]) {
                var l = o[s];
                r(n[s]) ? n[s] = !(0 == l) : i(n[s]) && (n[s] = parseInt(l, 10))
            }
    }, {
        "./browser": 65,
        "mout/lang/isBoolean": 16,
        "mout/lang/isInteger": 17,
        "mout/queryString/encode": 34,
        "mout/queryString/parse": 36
    }],
    69: [function(e, t, n) {
        "use strict";
        var r = e("../../core/properties"),
            i = e("../../core/settings"),
            o = e("three"),
            a = e("glslify");
        n.preInit = function() {
            o.ShaderChunk.bsdfs += "\n" + a(["#define GLSLIFY 1\nfloat screenLightHeightRatio;\n// https://eheitzresearch.wordpress.com/415-2/\nvec3 FetchDiffuseFilteredTexture(sampler2D texLightFiltered, vec3 p1_, vec3 p2_, vec3 p3_, vec3 p4_) {\n    // area light plane basis\n    vec3 V1 = p2_ - p1_;\n    vec3 V2 = p4_ - p1_;\n    vec3 planeOrtho = (cross(V1, V2));\n    float planeAreaSquared = dot(planeOrtho, planeOrtho);\n    float planeDistxPlaneArea = dot(planeOrtho, p1_);\n    // orthonormal projection of (0,0,0) in area light space\n    vec3 P = planeDistxPlaneArea * planeOrtho / planeAreaSquared - p1_;\n\n    // find tex coords of P\n    float dot_V1_V2 = dot(V1,V2);\n    float inv_dot_V1_V1 = 1.0 / dot(V1, V1);\n    vec3 V2_ = V2 - V1 * dot_V1_V2 * inv_dot_V1_V1;\n    vec2 Puv;\n    Puv.y = dot(V2_, P) / dot(V2_, V2_);\n    Puv.x = dot(V1, P)*inv_dot_V1_V1 - dot_V1_V2*inv_dot_V1_V1*Puv.y ;\n\n    // LOD\n    float d = abs(planeDistxPlaneArea) / pow(planeAreaSquared, 0.75);\n\n\tfloat lod = log(2048.0*d)/log(3.0);\n\t// vec2 uv = clamp(vec2(0.125, 0.125) + 0.75 * Puv, vec2(0.0), vec2(1.0));\n\tvec2 uv = clamp(Puv, vec2(0.0), vec2(1.0));\n\n    // return texture2DLodEXT(texLightFiltered, uv, lod).rgb;\n\t// custom one for this project\n\t#ifdef IS_MOBILE\n\treturn lodMipmapSampleSmoothstep(texLightFiltered, uv, lod, u_screenTextureSize, u_screenMipmapTextureSize).rgb;\n\t#else\n\treturn lodMipmapSampleCubic(texLightFiltered, uv, lod, u_screenTextureSize, u_screenMipmapTextureSize).rgb;\n\t#endif\n}\n\nvec3 LTC_EvaluateWithCookie(sampler2D texLightFiltered,  const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\tvec3 textureLight = FetchDiffuseFilteredTexture(texLightFiltered, coords[0], coords[1], coords[2], coords[3]);\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result ) * textureLight;\n\n}"]), o.ShaderChunk.lights_physical_pars_fragment = o.ShaderChunk.lights_physical_pars_fragment.replace("void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight", "uniform sampler2D u_areaLightCookies[NUM_RECT_AREA_LIGHTS]; \nvoid RE_Direct_RectArea_Physical(const in sampler2D areaLightCookie, const in RectAreaLight rectAreaLight"), o.ShaderChunk.lights_physical_pars_fragment = o.ShaderChunk.lights_physical_pars_fragment.replace("LTC_Evaluate(", "LTC_EvaluateWithCookie(areaLightCookie, "), o.ShaderChunk.lights_physical_pars_fragment = o.ShaderChunk.lights_physical_pars_fragment.replace("LTC_Evaluate(", "LTC_EvaluateWithCookie(areaLightCookie, "), o.ShaderChunk.lights_fragment_begin = o.ShaderChunk.lights_fragment_begin.replace("RE_Direct_RectArea( rectAreaLight", "RE_Direct_RectArea( u_areaLightCookies[ i ], rectAreaLight"), r.loader.add(i.TEXTURE_PATH + "ltc_mats.buf", {
                type: "xhr",
                responseType: "arraybuffer",
                weight: 128,
                onLoad: function(e) {
                    if (!o.UniformsLib.LTC_1) {
                        var t = new o.DataTexture(new Float32Array(e, 0, 16384), 64, 64, o.RGBAFormat, o.FloatType, o.UVMapping, o.ClampToEdgeWrapping, o.ClampToEdgeWrapping, o.LinearFilter, o.NearestFilter, 1),
                            n = new o.DataTexture(new Float32Array(e, 65536, 16384), 64, 64, o.RGBAFormat, o.FloatType, o.UVMapping, o.ClampToEdgeWrapping, o.ClampToEdgeWrapping, o.LinearFilter, o.NearestFilter, 1);
                        t.needsUpdate = !0, n.needsUpdate = !0, o.UniformsLib.LTC_1 = t, o.UniformsLib.LTC_2 = n;
                        var r = {
                            ltc_1: {
                                value: null
                            },
                            ltc_2: {
                                value: null
                            }
                        };
                        Object.assign(o.ShaderLib.standard.uniforms, r), Object.assign(o.ShaderLib.physical.uniforms, r)
                    }
                }
            })
        }
    }, {
        "../../core/properties": 67,
        "../../core/settings": 68,
        glslify: 8,
        three: 57
    }],
    70: [function(e, t, n) {
        "use strict";
        var r = e("../../core/properties"),
            i = e("../../core/settings"),
            o = e("../../helpers/shaderHelper"),
            a = e("three"),
            s = e("glslify");
        n.preInit = function() {
            var e = new a.Texture(r.loader.add(i.TEXTURE_PATH + "LDR_RGB1_0.png", {
                weight: 55,
                onLoad: function() {
                    e.needsUpdate = !0
                }
            }).content);
            e.generateMipmaps = !1, e.minFilter = e.magFilter = a.NearestFilter, e.wrapS = e.wrapT = a.RepeatWrapping, l.u_blueNoiseTexture = {
                value: e
            }, l.u_blueNoiseTexelSize = {
                value: new a.Vector2(1 / u, 1 / u)
            }, l.u_blueNoiseCoordOffset = {
                value: c = new a.Vector2
            }, o.addChunk("getBlueNoise", s(["#define GLSLIFY 1\nuniform sampler2D u_blueNoiseTexture;\nuniform vec2 u_blueNoiseTexelSize;\nuniform vec2 u_blueNoiseCoordOffset;\n\n// getBlueNoise(gl_FragCoord.xy)\nvec3 getBlueNoise (vec2 coord) {\n\treturn texture2D(u_blueNoiseTexture, coord * u_blueNoiseTexelSize + u_blueNoiseCoordOffset).rgb;\n}\n// getStaticBlueNoise(gl_FragCoord.xy)\nvec3 getStaticBlueNoise (vec2 coord) {\n\treturn texture2D(u_blueNoiseTexture, coord * u_blueNoiseTexelSize).rgb;\n}"]))
        }, n.update = function(e) {
            c.set(Math.random(), Math.random())
        };
        var l = n.sharedUniforms = {},
            c = void 0,
            u = 128
    }, {
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../helpers/shaderHelper": 75,
        glslify: 8,
        three: 57
    }],
    71: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.getBlur9Material = m, n.getBlur9DepthMaterial = function(e, t) {
            t = !!t;
            var n = (e = !!e) ? t ? l : h : t ? c : d,
                r = 8 < u.MAX_VARYING_VECTORS;
            n = n || new i.RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        type: "t",
                        value: a
                    },
                    u_delta: {
                        type: "v2",
                        value: new i.Vector2
                    }
                },
                vertexShader: r ? u.precisionPrefix + o(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform vec2 u_delta;\nvarying vec2 v_uv[9];\n\nvoid main() {\n    vec2 uv = position.xy * 0.5 + 0.5;\n\n    v_uv[0] = uv;\n\n    vec2 delta = u_delta;\n    v_uv[1] = uv - delta;\n    v_uv[2] = uv + delta;\n\n    delta += u_delta;\n    v_uv[3] = uv - delta;\n    v_uv[4] = uv + delta;\n\n    delta += u_delta;\n    v_uv[5] = uv - delta;\n    v_uv[6] = uv + delta;\n\n    delta += u_delta;\n    v_uv[7] = uv - delta;\n    v_uv[8] = uv + delta;\n\n    gl_Position = vec4( position, 1.0 );\n\n}\n"]) : u.vertexShader,
                fragmentShader: u.precisionPrefix + o(r ? ["#define GLSLIFY 1\n#include <packing>\n\nuniform sampler2D u_texture;\nuniform float u_cameraFarSubNear;\nuniform float u_cameraNearMulFar;\nuniform float u_cameraNear;\nuniform float u_cameraFar;\n\nvarying vec2 v_uv[9];\n\n#if FROM_LINEAR\nfloat tap (vec2 uv) {\n    return unpackRGBAToDepth(texture2D(u_texture, uv));\n}\n#else\nfloat tap (vec2 uv) {\n    return u_cameraNearMulFar / (unpackRGBAToDepth(texture2D(u_texture, uv) * u_cameraFarSubNear - u_cameraFar);\n}\n#endif\n\n#if TO_LINEAR\nfloat encode (float depth) {\n    return packDepthToRGBA(depth);\n}\n#else\nfloat encode (float depth) {\n    return packDepthToRGBA((u_cameraNear + depth) * u_cameraFar) / (u_cameraFarSubNear * viewZ);\n}\n#endif\n\nvoid main() {\n        vec4 color = tap(v_uv[0]) * 0.1633;\n        color += tap( v_uv[1]) * 0.1531;\n        color += tap( v_uv[2]) * 0.1531;\n        color += tap( v_uv[3]) * 0.12245;\n        color += tap( v_uv[4]) * 0.12245;\n        color += tap( v_uv[5]) * 0.0918;\n        color += tap( v_uv[6]) * 0.0918;\n        color += tap( v_uv[7]) * 0.051;\n        color += tap( v_uv[8]) * 0.051;\n\n        gl_FragColor = encode(color);\n}\n"] : ["#define GLSLIFY 1\n#include <packing>\n\nuniform sampler2D u_texture;\nuniform vec2 u_delta;\nuniform float u_cameraFarSubNear;\nuniform float u_cameraNearMulFar;\nuniform float u_cameraNear;\nuniform float u_cameraFar;\n\nvarying vec2 v_uv;\n\n#if FROM_LINEAR\nfloat tap (vec2 uv) {\n    return unpackRGBAToDepth(texture2D(u_texture, uv));\n}\n#else\nfloat tap (vec2 uv) {\n    return u_cameraNearMulFar / (unpackRGBAToDepth(texture2D(u_texture, uv) * u_cameraFarSubNear - u_cameraFar);\n}\n#endif\n\n#if TO_LINEAR\nfloat encode (float depth) {\n    return packDepthToRGBA(depth);\n}\n#else\nfloat encode (float depth) {\n    return packDepthToRGBA((u_cameraNear + depth) * u_cameraFar) / (u_cameraFarSubNear * viewZ);\n}\n#endif\n\nvoid main() {\n        vec4 color = tap(v_uv) * 0.1633;\n\n        vec2 delta = u_delta;\n        color += tap(v_uv - delta) * 0.1531;\n        color += tap(v_uv + delta) * 0.1531;\n\n        delta += u_delta;\n        color += tap(v_uv - delta) * 0.12245;\n        color += tap(v_uv + delta) * 0.12245;\n\n        delta += u_delta;\n        color += tap(v_uv - delta) * 0.0918;\n        color += tap(v_uv + delta) * 0.0918;\n\n        delta += u_delta;\n        color += tap(v_uv - delta) * 0.051;\n        color += tap(v_uv + delta) * 0.051;\n\n        gl_FragColor = encode(color);\n}\n"]),
                blending: i.NoBlending,
                transparent: !0,
                defines: {
                    FROM_LINEAR: e,
                    TO_LINEAR: t
                }
            });
            e ? t ? l = n : h = n : t ? c = n : d = n;
            return n
        }, n.blur9 = function(e, t, n, r, i, o) {
            v(m(), .25, e, t, n, r, i, o)
        }, n.blur9RGBA = function(e, t, n, r, i, o) {
            v(m(!0), .25, e, t, n, r, i, o)
        }, n.blur = v;
        var u = e("../../helpers/fboHelper"),
            i = e("three"),
            o = e("glslify"),
            a = void 0,
            r = void 0,
            s = void 0,
            l = void 0,
            c = void 0,
            h = void 0,
            d = void 0,
            p = void 0,
            f = void 0;

        function m(e) {
            var t = (e = !!e) ? s : r,
                n = 8 < u.MAX_VARYING_VECTORS;
            return t || (t = new i.RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        type: "t",
                        value: a
                    },
                    u_delta: {
                        type: "v2",
                        value: new i.Vector2
                    }
                },
                vertexShader: n ? u.precisionPrefix + o(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform vec2 u_delta;\nvarying vec2 v_uv[9];\n\nvoid main() {\n    vec2 uv = position.xy * 0.5 + 0.5;\n\n    v_uv[0] = uv;\n\n    vec2 delta = u_delta;\n    v_uv[1] = uv - delta;\n    v_uv[2] = uv + delta;\n\n    delta += u_delta;\n    v_uv[3] = uv - delta;\n    v_uv[4] = uv + delta;\n\n    delta += u_delta;\n    v_uv[5] = uv - delta;\n    v_uv[6] = uv + delta;\n\n    delta += u_delta;\n    v_uv[7] = uv - delta;\n    v_uv[8] = uv + delta;\n\n    gl_Position = vec4( position, 1.0 );\n\n}\n"]) : u.vertexShader,
                fragmentShader: u.precisionPrefix + o(n ? ["#define GLSLIFY 1\nuniform sampler2D u_texture;\nvarying vec2 v_uv[9];\n\nvoid main() {\n\n    #ifdef USE_RGBA\n        vec4 color = texture2D( u_texture, v_uv[0] ) * 0.1633;\n        color += texture2D( u_texture,  v_uv[1] ) * 0.1531;\n        color += texture2D( u_texture,  v_uv[2] ) * 0.1531;\n        color += texture2D( u_texture,  v_uv[3] ) * 0.12245;\n        color += texture2D( u_texture,  v_uv[4] ) * 0.12245;\n        color += texture2D( u_texture,  v_uv[5] ) * 0.0918;\n        color += texture2D( u_texture,  v_uv[6] ) * 0.0918;\n        color += texture2D( u_texture,  v_uv[7] ) * 0.051;\n        color += texture2D( u_texture,  v_uv[8] ) * 0.051;\n\n        gl_FragColor = color;\n    #else\n        vec4 center = texture2D( u_texture, v_uv[0] );\n        vec3 color = center.rgb * 0.1633;\n        color += texture2D( u_texture,  v_uv[1] ).rgb * 0.1531;\n        color += texture2D( u_texture,  v_uv[2] ).rgb * 0.1531;\n        color += texture2D( u_texture,  v_uv[3] ).rgb * 0.12245;\n        color += texture2D( u_texture,  v_uv[4] ).rgb * 0.12245;\n        color += texture2D( u_texture,  v_uv[5] ).rgb * 0.0918;\n        color += texture2D( u_texture,  v_uv[6] ).rgb * 0.0918;\n        color += texture2D( u_texture,  v_uv[7] ).rgb * 0.051;\n        color += texture2D( u_texture,  v_uv[8] ).rgb * 0.051;\n\n        gl_FragColor = vec4(color, center.a);\n    #endif\n\n}\n"] : ["#define GLSLIFY 1\nuniform sampler2D u_texture;\nuniform vec2 u_delta;\n\nvarying vec2 v_uv;\n\nvoid main() {\n\n    #ifdef USE_RGBA\n        vec4 color = texture2D( u_texture, v_uv ) * 0.1633;\n\n        vec2 delta = u_delta;\n        color += texture2D( u_texture,  v_uv - delta ) * 0.1531;\n        color += texture2D( u_texture,  v_uv + delta ) * 0.1531;\n\n        delta += u_delta;\n        color += texture2D( u_texture,  v_uv - delta ) * 0.12245;\n        color += texture2D( u_texture,  v_uv + delta ) * 0.12245;\n\n        delta += u_delta;\n        color += texture2D( u_texture,  v_uv - delta ) * 0.0918;\n        color += texture2D( u_texture,  v_uv + delta ) * 0.0918;\n\n        delta += u_delta;\n        color += texture2D( u_texture,  v_uv - delta ) * 0.051;\n        color += texture2D( u_texture,  v_uv + delta ) * 0.051;\n\n        gl_FragColor = color;\n\n    #else\n        vec4 center = texture2D( u_texture, v_uv );\n        vec3 color = center.rgb * 0.1633;\n\n        vec2 delta = u_delta;\n        color += texture2D( u_texture,  v_uv - delta ).rgb * 0.1531;\n        color += texture2D( u_texture,  v_uv + delta ).rgb * 0.1531;\n\n        delta += u_delta;\n        color += texture2D( u_texture,  v_uv - delta ).rgb * 0.12245;\n        color += texture2D( u_texture,  v_uv + delta ).rgb * 0.12245;\n\n        delta += u_delta;\n        color += texture2D( u_texture,  v_uv - delta ).rgb * 0.0918;\n        color += texture2D( u_texture,  v_uv + delta ).rgb * 0.0918;\n\n        delta += u_delta;\n        color += texture2D( u_texture,  v_uv - delta ).rgb * 0.051;\n        color += texture2D( u_texture,  v_uv + delta ).rgb * 0.051;\n\n        gl_FragColor = vec4(color, center.a);\n\n    #endif\n\n}\n"]),
                blending: i.NoBlending,
                transparent: e,
                defines: {
                    USE_RGBA: e
                }
            }), e ? s = t : r = t), t
        }

        function v(e, t, n, r, i, o, a, s) {
            var l = Math.ceil(i.width * r) || 0,
                c = Math.ceil(i.height * r) || 0;
            (o = o || (e.transparent ? f = f || u.createRenderTarget(1, 1, !0) : p = p || u.createRenderTarget(1, 1))).setSize(l, c), a ? s || a.setSize(i.width, i.height) : a = i, e.uniforms.u_texture.value = i.texture || i, e.uniforms.u_delta.value.set(n / l * t, 0), u.render(e, o), e.uniforms.u_texture.value = o.texture || o, e.uniforms.u_delta.value.set(0, n / c * t), u.render(e, a)
        }
    }, {
        "../../helpers/fboHelper": 74,
        glslify: 8,
        three: 57
    }],
    72: [function(e, t, n) {
        "use strict";
        e("../../core/properties");
        var r = e("../../helpers/shaderHelper"),
            i = e("three"),
            o = e("glslify");
        n.init = function() {
            a.u_glPositionOffset = {
                value: s = new i.Vector2
            }, r.addChunk("glPositionOffset", o(["#define GLSLIFY 1\nuniform vec2 u_glPositionOffset;\n\nvec4 glPositionOffset (vec4 glPosition) {\n\treturn glPosition + vec4(u_glPositionOffset * glPosition.w, 0.0, 0.0);\n}"]))
        }, n.setOffset = function(e, t) {
            s.set(e, t)
        };
        var a = n.sharedUniforms = {},
            s = void 0
    }, {
        "../../core/properties": 67,
        "../../helpers/shaderHelper": 75,
        glslify: 8,
        three: 57
    }],
    73: [function(e, t, n) {
        "use strict";
        var i = e("three"),
            r = e("glslify"),
            b = e("../../utils/math"),
            c = e("../../helpers/fboHelper"),
            o = e("../../helpers/shaderHelper");
        (n = t.exports = function() {
            this.tmpRenderTarget = c.createRenderTarget(1, 1, !0), this.maxMipmapLevel = 0, this.textureSize = new i.Vector2;
            var e = s + 1;
            this.geometry = l(e), this.oddGeometry = l(e)
        }).init = function() {
            o.addChunk("lodMipmapSample", r(["#define GLSLIFY 1\nvec2 getMipUv (vec2 uv, float lod, vec2 textureSize, vec2 screenTextureSize) {\n\tfloat isNonZeroLod = step(0.5, lod);\n\tvec2 xy = vec2(\n\t\tisNonZeroLod * textureSize.x / screenTextureSize.x,\n\t\t1.0 - 1.0 / pow(2.0, max(0.0, lod - 1.0))\n\t);\n\tvec2 wh = (max(vec2(1.0), floor(textureSize / pow(2.0, lod))));\n\treturn xy + (0.5 + uv * (wh - 1.0)) / screenTextureSize;\n}\n\nvec2 getMipUv (vec2 uv, float lod, vec2 textureSize, vec2 screenTextureSize, out vec4 clampRect) {\n\tfloat isNonZeroLod = step(0.5, lod);\n\tvec2 xy = vec2(\n\t\tisNonZeroLod * textureSize.x / screenTextureSize.x,\n\t\t1.0 - 1.0 / pow(2.0, max(0.0, lod - 1.0))\n\t);\n\tvec2 wh = (max(vec2(1.0), floor(textureSize / pow(2.0, lod))));\n\tvec2 halfTexelSize = 0.5 / screenTextureSize;\n\n\tclampRect = vec4(\n\t\txy + halfTexelSize,\n\t\txy + wh / screenTextureSize - halfTexelSize\n\t);\n\t\n\treturn xy + (0.5 + uv * (wh - 1.0)) / screenTextureSize;\n}\n\nvec4 lodMipmapSampleNearestCubic (sampler2D tex, vec2 uv, float lod, vec2 textureSize, vec2 screenTextureSize) {\n\tvec4 clampRect;\n\tuv = getMipUv(uv, lod, textureSize, screenTextureSize, clampRect);\n\treturn textureBicubic(tex, uv, screenTextureSize, clampRect);\n}\n\nvec4 lodMipmapSampleNearestSmoothstep (sampler2D tex, vec2 uv, float lod, vec2 textureSize, vec2 screenTextureSize) {\n\treturn textureSmoothstep(tex, getMipUv(uv, lod, textureSize, screenTextureSize), screenTextureSize);\n}\n\nvec4 lodMipmapSampleNearest (sampler2D tex, vec2 uv, float lod, vec2 textureSize, vec2 screenTextureSize) {\n\treturn texture2D(tex, getMipUv(uv, lod, textureSize, screenTextureSize));\n}\n\nvec4 lodMipmapSampleCubic (sampler2D tex, vec2 uv, float lod, vec2 textureSize, vec2 screenTextureSize) {\n\tfloat lodFloor = floor(lod);\n\tfloat lodCeil = lodFloor + 1.0;\n\tfloat lodFract = lod - lodFloor;\n\n\tvec4 loClamp, hiClamp;\n\tvec2 loUv = getMipUv(uv, lodFloor, textureSize, screenTextureSize, loClamp);\n\tvec2 hiUv = getMipUv(uv, lodCeil, textureSize, screenTextureSize, hiClamp);\n\treturn mix(\n\t\ttextureBicubic(tex, loUv, screenTextureSize, loClamp),\n\t\ttextureBicubic(tex, hiUv, screenTextureSize, hiClamp),\n\t\tlodFract\n\t);\n}\n\nvec4 lodMipmapSampleSmoothstep (sampler2D tex, vec2 uv, float lod, vec2 textureSize, vec2 screenTextureSize) {\n\tfloat lodFloor = floor(lod);\n\tfloat lodCeil = lodFloor + 1.0;\n\tfloat lodFract = lod - lodFloor;\n\treturn mix(\n\t\ttextureSmoothstep(tex, getMipUv(uv, lodFloor, textureSize, screenTextureSize), screenTextureSize),\n\t\ttextureSmoothstep(tex, getMipUv(uv, lodCeil, textureSize, screenTextureSize), screenTextureSize),\n\t\tlodFract\n\t);\n}\n\nvec4 lodMipmapSample (sampler2D tex, vec2 uv, float lod, vec2 textureSize, vec2 screenTextureSize) {\n\tfloat lodFloor = floor(lod);\n\tfloat lodCeil = lodFloor + 1.0;\n\tfloat lodFract = lod - lodFloor;\n\treturn mix(\n\t\ttexture2D(tex, getMipUv(uv, lodFloor, textureSize, screenTextureSize)),\n\t\ttexture2D(tex, getMipUv(uv, lodCeil, textureSize, screenTextureSize)),\n\t\tlodFract\n\t);\n}\n"]))
        };
        var a = n.prototype;
        a.resize = function(e, t, n, r) {
            this.maxMipmapLevel = b.powerTwoFloorBase(t), this.tmpRenderTarget.setSize(n, r), this.textureSize.set(n, r);
            for (var i = this.geometry.attributes.position.array, o = this.geometry.attributes.uv.array, a = 0, s = 0, l = this.maxMipmapLevel; s < l; s++) {
                var c = (0 < s ? e : 0) / n,
                    u = (r - (r >> Math.max(0, s - 1))) / r,
                    h = Math.max(1, e >> s) / n,
                    d = Math.max(1, t >> s) / r;
                o[a + 0] = c, o[a + 1] = u + d, o[a + 2] = c, o[a + 3] = u, o[a + 4] = c + h, o[a + 5] = u + d, o[a + 6] = c + h, o[a + 7] = u + d, o[a + 8] = c, o[a + 9] = u, o[a + 10] = c + h, o[a + 11] = u, a += 12
            }
            for (var p = this.oddGeometry.attributes.uv.array, f = this.oddGeometry.attributes.position.array, m = a = 0, v = 0, g = 0, y = 0, x = this.maxMipmapLevel - 1; y < x; y++) i[m + 0] = 2 * o[a + 12] - 1, i[m + 1] = 2 * o[a + 13] - 1, i[m + 3] = 2 * o[a + 14] - 1, i[m + 4] = 2 * o[a + 15] - 1, i[m + 6] = 2 * o[a + 16] - 1, i[m + 7] = 2 * o[a + 17] - 1, i[m + 9] = 2 * o[a + 18] - 1, i[m + 10] = 2 * o[a + 19] - 1, i[m + 12] = 2 * o[a + 20] - 1, i[m + 13] = 2 * o[a + 21] - 1, i[m + 15] = 2 * o[a + 22] - 1, i[m + 16] = 2 * o[a + 23] - 1, (y + 1) % 2 && (f[g + 0] = 2 * (p[v + 0] = o[a + 12]) - 1, f[g + 1] = 2 * (p[v + 1] = o[a + 13]) - 1, f[g + 3] = 2 * (p[v + 2] = o[a + 14]) - 1, f[g + 4] = 2 * (p[v + 3] = o[a + 15]) - 1, f[g + 6] = 2 * (p[v + 4] = o[a + 16]) - 1, f[g + 7] = 2 * (p[v + 5] = o[a + 17]) - 1, f[g + 9] = 2 * (p[v + 6] = o[a + 18]) - 1, f[g + 10] = 2 * (p[v + 7] = o[a + 19]) - 1, f[g + 12] = 2 * (p[v + 8] = o[a + 20]) - 1, f[g + 13] = 2 * (p[v + 9] = o[a + 21]) - 1, f[g + 15] = 2 * (p[v + 10] = o[a + 22]) - 1, f[g + 16] = 2 * (p[v + 11] = o[a + 23]) - 1, v += 12, g += 18), a += 12, m += 18;
            this.geometry.attributes.uv.needsUpdate = !0, this.geometry.attributes.position.needsUpdate = !0, this.oddGeometry.attributes.uv.needsUpdate = !0, this.oddGeometry.attributes.position.needsUpdate = !0
        }, a.render = function(e) {
            var t = c.getColorState(),
                n = c.uvCopyMaterial;
            this.textureSize.x == e.width && this.textureSize.y == e.height || (e.setSize(e.width, e.height), this.resize(Math.round(e.width / 3 * 2), e.height, e.width, e.height));
            c.renderer.autoClearColor = !1;
            for (var r = e, i = this.tmpRenderTarget, o = 0, a = 0, s = this.maxMipmapLevel - 1; a < s; a++) {
                n.uniforms.u_texture.value = r.texture, this.geometry.drawRange.start = 6 * a, this.geometry.drawRange.count = 6, c.renderGeometry(this.geometry, n, i), i === this.tmpRenderTarget && o++;
                var l = i;
                i = r, r = l
            }
            this.oddGeometry.drawRange.start = 0, this.oddGeometry.drawRange.count = 6 * o, n.uniforms.u_texture.value = this.tmpRenderTarget.texture, c.renderGeometry(this.oddGeometry, n, e), c.setColorState(t)
        };
        var s = 14;

        function l(e) {
            var t = new Float32Array(6 * e * 2),
                n = new Float32Array(6 * e * 3),
                r = new i.BufferGeometry;
            return r.setAttribute("position", new i.BufferAttribute(n, 3)), r.setAttribute("uv", new i.BufferAttribute(t, 2)), r
        }
    }, {
        "../../helpers/fboHelper": 74,
        "../../helpers/shaderHelper": 75,
        "../../utils/math": 124,
        glslify: 8,
        three: 57
    }],
    74: [function(e, t, a) {
        "use strict";
        var s = e("three"),
            i = e("glslify");
        a.init = function(e, t) {
            l = a.renderer = e, a.floatType = t, c = new s.Scene, (u = new s.Camera).position.z = 1, (o = a.triGeom = new s.BufferGeometry).setAttribute("position", new s.BufferAttribute(new Float32Array([-1, -1, 0, 4, -1, 0, -1, 4, 0]), 3)), a.quadGeom = new s.PlaneBufferGeometry(2, 2), (h = new s.Mesh(o)).frustumCulled = !1, c.add(h);
            var n = a.precisionPrefix = "precision " + l.capabilities.precision + " float;\n";
            a.precisionPrefix2 = "#version 300 es\nprecision " + l.capabilities.precision + " float;\nprecision " + l.capabilities.precision + " int;\n#define IS_WEBGL2 true\n";
            a.vertexShader = n + i(["#define GLSLIFY 1\nattribute vec3 position;\nvarying vec2 v_uv;\n\nvoid main() {\n    v_uv = position.xy * 0.5 + 0.5;\n    gl_Position = vec4(position, 1.0 );\n}\n"]), a.copyMaterial = new s.RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    }
                },
                vertexShader: a.vertexShader,
                fragmentShader: n + i(["#define GLSLIFY 1\nuniform sampler2D u_texture;\n\nvarying vec2 v_uv;\n\nvoid main () {\n    gl_FragColor = texture2D(u_texture, v_uv);\n}\n"]),
                depthTest: !1,
                depthWrite: !1,
                blending: s.NoBlending
            }), a.uvCopyMaterial = new s.RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    }
                },
                vertexShader: n + i(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 v_uv;\n\nvoid main() {\n    v_uv = uv;\n    gl_Position = vec4(position, 1.0 );\n}\n"]),
                fragmentShader: n + i(["#define GLSLIFY 1\nuniform sampler2D u_texture;\n\nvarying vec2 v_uv;\n\nvoid main () {\n    gl_FragColor = texture2D(u_texture, v_uv);\n}\n"]),
                depthTest: !1,
                depthWrite: !1,
                blending: s.NoBlending
            }), a.clearMaterial = new s.RawShaderMaterial({
                uniforms: {
                    u_color: {
                        value: new s.Vector4(1, 1, 1, 1)
                    }
                },
                vertexShader: n + i(["#define GLSLIFY 1\nattribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position, 1.0 );\n}\n"]),
                fragmentShader: n + i(["#define GLSLIFY 1\nuniform vec4 u_color;\n\nvoid main () {\n    gl_FragColor = u_color;\n}\n"]),
                depthTest: !1,
                depthWrite: !1,
                transparent: !0,
                blending: s.NoBlending
            }), d = new s.Scene;
            var r = new s.PlaneBufferGeometry(1, 1);
            r.translate(.5, -.5, 0), f = new s.RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_transform: {
                        value: new s.Vector4(0, 0, 1, 1)
                    }
                },
                vertexShader: n + i(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform vec4 u_transform;\n\nvarying vec2 v_uv;\n\nvoid main() {\n    v_uv = uv;\n    gl_Position = vec4( position.xy * u_transform.zw + u_transform.xy, 0.0, 1.0 );\n}\n"]),
                fragmentShader: n + i(["#define GLSLIFY 1\nuniform sampler2D u_texture;\n\nvarying vec2 v_uv;\n\nvoid main () {\n    gl_FragColor = texture2D(u_texture, v_uv);\n}\n"]),
                depthTest: !1,
                depthWrite: !1,
                blending: s.NoBlending
            }), p = new s.Mesh(r, f), d.frustumCulled = !1, d.add(p)
        }, a.copy = function(e, t) {
            var n = a.copyMaterial;
            n.uniforms.u_texture.value = e, m(n, t)
        }, a.uvCopy = function(e, t) {
            var n = a.uvCopyMaterial;
            n.uniforms.u_texture.value = e, m(n, t)
        }, a.render = m, a.renderGeometry = function(e, t, n) {
            h.geometry = e, m(t, n), h.geometry = o
        }, a.renderMesh = function(e, t) {
            h.visible = !1, c.add(e), t && l.setRenderTarget(t || null);
            l.render(c, u), t && l.setRenderTarget(null);
            c.remove(e), h.visible = !0
        }, a.debugTo = function(e, t, n, r, i) {
            t = t || 200, n = n || 200, r = r || 0, i = i || 0;
            var o = l.getSize(new s.Vector2);
            r = r / o.width * 2 - 1, i = 1 - i / o.height * 2, t = t / o.width * 2, n = n / o.height * 2, f.uniforms.u_texture.value = e, f.uniforms.u_transform.value.set(r, i, t, n);
            v();
            l.autoClearColor = !1, l.setRenderTarget(null), l.render(d, u), v()
        }, a.clearColor = function(e, t, n, r, i) {
            var o = a.clearMaterial;
            o.uniforms.u_color.value.set(e, t, n, r), o.transparent = r < 1, o.blending = r < 1 ? s.NormalBlending : s.NoBlending, m(a.clearMaterial, i), o.transparent = !1, o.blending = s.NoBlending
        }, a.getColorState = v, a.setColorState = function(e) {
            l.setClearColor(e.clearColor, e.clearAlpha), l.autoClear = e.autoClear, l.autoClearColor = e.autoClearColor, l.autoClearStencil = e.autoClearStencil, l.autoClearDepth = e.autoClearDepth
        }, a.createRenderTarget = function(e, t, n, r, i) {
            return new s.WebGLRenderTarget(e, t, {
                wrapS: s.ClampToEdgeWrapping,
                wrapT: s.ClampToEdgeWrapping,
                magFilter: r ? s.NearestFilter : s.LinearFilter,
                minFilter: r ? s.NearestFilter : s.LinearFilter,
                format: n ? s.RGBAFormat : s.RGBFormat,
                type: i ? a.floatType : s.UnsignedByteType,
                anisotropy: 0,
                encoding: s.LinearEncoding,
                depthBuffer: !1,
                stencilBuffer: !1
            })
        }, a.createMultisampleRenderTarget = function(e, t, n, r, i) {
            return new s.WebGLMultisampleRenderTarget(e, t, {
                wrapS: s.ClampToEdgeWrapping,
                wrapT: s.ClampToEdgeWrapping,
                magFilter: r ? s.NearestFilter : s.LinearFilter,
                minFilter: r ? s.NearestFilter : s.LinearFilter,
                format: n ? s.RGBAFormat : s.RGBFormat,
                type: i ? a.floatType : s.UnsignedByteType,
                anisotropy: 0,
                encoding: s.LinearEncoding,
                depthBuffer: !1,
                stencilBuffer: !1
            })
        };
        var l = a.renderer = null,
            o = (a.quadGeom = null, a.triGeom = null);
        a.clearMaterial = null, a.floatType = null, a.precisionPrefix = "", a.precisionPrefix2 = "", a.vertexShader = "";
        var c = void 0,
            u = void 0,
            h = void 0,
            d = void 0,
            p = void 0,
            f = void 0;

        function m(e, t) {
            h.material = e, t && l.setRenderTarget(t), l.render(c, u), t && l.setRenderTarget(null)
        }

        function v() {
            return {
                autoClear: l.autoClear,
                autoClearColor: l.autoClearColor,
                autoClearStencil: l.autoClearStencil,
                autoClearDepth: l.autoClearDepth,
                clearColor: l.getClearColor().getHex(),
                clearAlpha: l.getClearAlpha()
            }
        }
    }, {
        glslify: 8,
        three: 57
    }],
    75: [function(e, t, n) {
        "use strict";
        var r = e("three");

        function i(e) {
            return e.replace(/#define\sGLSLIFY\s./, "")
        }

        function o(e) {
            return "#include <" + e + ">"
        }
        n.glslifyStrip = i, n.addChunk = function(e, t) {
            r.ShaderChunk[e] = i(t)
        }, n.insertBefore = function(e, t, n, r) {
            r && (t = o(t));
            return e.replace(t, i(n) + "\n" + t)
        }, n.insertAfter = function(e, t, n, r) {
            r && (t = o(t));
            return e.replace(t, t + "\n" + i(n) + "\n")
        }, n.replace = function(e, t, n, r) {
            r && (t = o(t));
            return e.replace(t, "\n" + i(n) + "\n")
        }
    }, {
        three: 57
    }],
    76: [function(e, t, n) {
        "use strict";
        var a = e("./core/browser"),
            s = e("./core/settings"),
            l = e("./core/properties"),
            r = e("./helpers/fboHelper"),
            i = e("./helpers/shaderHelper"),
            o = e("./effects/mipmapper/Mipmapper"),
            c = e("./effects/glPositionOffset/glPositionOffset"),
            u = e("./effects/areaLights/areaLights"),
            h = e("./effects/blueNoise/blueNoise"),
            d = e("./post/Postprocessing"),
            p = e("./post/smaa/Smaa"),
            f = e("./post/bloom/Bloom"),
            m = e("./post/final/Final"),
            v = e("./router/router"),
            g = e("./controls/cameraControls"),
            y = e("./visual/visual"),
            x = e("./shaders/shaders"),
            b = e("./input/input"),
            _ = e("./ui/preloader"),
            w = e("./ui/shaderContext"),
            S = e("./ui/viewInfos"),
            M = e("./ui/editor/editor"),
            T = e("./ui/prompt/prompt"),
            E = e("./ui/header/header"),
            C = e("./ui/about/about"),
            L = e("./io/exporter"),
            A = e("three"),
            R = e("glslify");
        e("mout/object/mixIn");
        t.exports = n = s, n.browser = a, n.properties = l, n.resize = F;
        var P = void 0,
            O = void 0,
            I = void 0,
            D = void 0,
            N = +new Date / 1e3;

        function k() {
            _.init(z), c.init(), h.preInit(), u.preInit(), y.preInit(), g.preInit(), window.addEventListener("resize", F), F(), B(), l.loader.start(_.onPreloading)
        }

        function z() {
            p.updateTextures(), y.init(), g.init(), O.add(y.container), b.init(), w.init(), M.init(), S.init(), E.init(), C.init(), v.init(), L.init(), l.hasInitialized = !0, F()
        }

        function F(e) {
            var t = window.innerWidth,
                n = window.innerHeight;
            if (l.rawWidth = t, l.rawHeight = n, l.useHalfScreen && (t = Math.ceil(t / 2)), l.hasResized = !0, l.isStageReady) {
                var r = a.isRetina ? 1.25 : 1,
                    i = t * r,
                    o = n * r;
                l.width = i, l.height = o, l.resolution.set(i, o), I.aspect = i / o, I.updateProjectionMatrix(), P.setSize(i, o), D.setSize(i, o), s.canvas.style.width = t + "px", s.canvas.style.height = n + "px", l.hasInitialized && (y.resize(i, o), M.resize(), l.forceRenderOnResize && (D.render(O, I, !0), l.forceRenderOnResize = !1))
            }
        }

        function B() {
            requestAnimationFrame(B),
                function() {
                    if (l.isAbout) return;
                    var e = +new Date / 1e3,
                        t = L.isExporting ? 0 : e - N;
                    if (N = e, L.isExporting) L.update();
                    else {
                        l.fpsList.push(1 / Math.max(1e-4, t)), 10 < l.fpsList.length && l.fpsList.shift();
                        for (var n = l.fps = 0, r = 0, i = l.fpsList.length; r < i; r++) {
                            var o = l.fpsList[r];
                            l.fps += o, n = Math.max(o, n)
                        }
                        l.fps /= l.fpsList.length, l.isStageReady && (l.time += t, h.update(t), P.setClearColor(0, 0), l.hasInitialized && (b.update(t), g.update(t), y.update(t), M.update()), O.updateMatrixWorld(!0), l.final.bgColor = l.bgColor, l.final.opacity = Math.min(g.opacity, l.pageRatio), l.useXR ? (P.xr.enabled = l.useXR, P.setRenderTarget(null), P.render(O, I), P.xr.enabled = !1) : (l.smaa.enabled = 1 < l.viewQuality, l.bloom.enabled = 1 < l.viewQuality, l.final.enabled = !0, D.render(O, I, !0)))
                    }
                    l.hasResized = !1, l.hasMouseJustDown = !1
                }()
        }
        a.isMobile && document.documentElement.classList.add("is-mobile"), s.canvas = document.getElementById("main-canvas"),
            function() {
                if (s.USE_WEBGL2 && window.WebGL2RenderingContext) try {
                    return s.gl = s.canvas.getContext("webgl2", s.webglOpts), s.RENDER_TARGET_FLOAT_TYPE = A.FloatType, s.DATA_FLOAT_TYPE = A.FloatType, !0
                } catch (e) {}
                if (s.USE_WEBGL2 = !1, window.WebGLRenderingContext) try {
                    var e = s.gl = s.canvas.getContext("webgl", s.webglOpts) || s.canvas.getContext("experimental-webgl", s.webglOpts);
                    return (e.getExtension("OES_texture_float") || e.getExtension("OES_texture_half_float")) && e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (s.RENDER_TARGET_FLOAT_TYPE = a.isIOS || !e.getExtension("OES_texture_float") ? A.HalfFloatType : A.FloatType, s.DATA_FLOAT_TYPE = A.FloatType) : (s.USE_FLOAT_PACKING = !0, s.RENDER_TARGET_FLOAT_TYPE = s.DATA_FLOAT_TYPE = A.UnsignedByteType), !0
                } catch (e) {
                    return !1
                }
                return !1
            }() && (P = l.renderer = new A.WebGLRenderer({
                canvas: s.canvas,
                context: s.gl
            }), i.addChunk("textureBicubic", R(["#define GLSLIFY 1\nvec4 cubic(float v) {\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w);\n}\n\n// https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\nvec4 textureBicubic(sampler2D t, vec2 texCoords, vec2 textureSize) {\n   vec2 invTexSize = 1.0 / textureSize;\n   texCoords = texCoords * textureSize - 0.5;\n\n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2 (-0.5, 1.5).xyxy;\n\n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n\n    offset *= invTexSize.xxyy;\n\n    vec4 sample0 = texture2D(t, offset.xz);\n    vec4 sample1 = texture2D(t, offset.yz);\n    vec4 sample2 = texture2D(t, offset.xw);\n    vec4 sample3 = texture2D(t, offset.yw);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(\n       mix(sample3, sample2, sx), mix(sample1, sample0, sx)\n    , sy);\n}\n\nvec4 textureBicubic(sampler2D t, vec2 texCoords, vec2 textureSize, vec4 clampRect) {\n   vec2 invTexSize = 1.0 / textureSize;\n   texCoords = texCoords * textureSize - 0.5;\n\n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2 (-0.5, 1.5).xyxy;\n\n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n\n    offset *= invTexSize.xxyy;\n\n    vec4 sample0 = texture2D(t, clamp(offset.xz, clampRect.xy, clampRect.zw));\n    vec4 sample1 = texture2D(t, clamp(offset.yz, clampRect.xy, clampRect.zw));\n    vec4 sample2 = texture2D(t, clamp(offset.xw, clampRect.xy, clampRect.zw));\n    vec4 sample3 = texture2D(t, clamp(offset.yw, clampRect.xy, clampRect.zw));\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(\n       mix(sample3, sample2, sx), mix(sample1, sample0, sx)\n    , sy);\n}"])), i.addChunk("textureSmoothstep", R(["#define GLSLIFY 1\n// http://www.iquilezles.org/www/articles/texture/texture.htm\nvec4 textureSmoothstep(sampler2D t, vec2 texCoords, vec2 textureSize) {\n\ttexCoords = texCoords * textureSize + 0.5;\n\tvec2 iTexCoords = floor( texCoords );\n\tvec2 fTexCoords = fract( texCoords );\n\ttexCoords = iTexCoords + fTexCoords*fTexCoords*(3.0-2.0*fTexCoords);\n\ttexCoords = (texCoords - 0.5)/textureSize;\n\treturn texture2D( t, texCoords );\n}"])), O = l.scene = new A.Scene, I = l.camera = new A.PerspectiveCamera(60, 1, .05, 100), O.add(I), l.resolution = new A.Vector2, l.sharedUniforms = {
                u_resolution: {
                    value: l.resolution
                }
            }, r.init(P, s.RENDER_TARGET_FLOAT_TYPE), D = l.postprocessing = new d, p.setTextures(l.loader.add(s.TEXTURE_PATH + "smaa-area.png", {
                weight: 32
            }).content, l.loader.add(s.TEXTURE_PATH + "smaa-search.png", {
                weight: .1
            }).content), D.queue.push(l.smaa = new p), D.queue.push(l.bloom = new f), D.queue.push(l.final = new m), o.init(), l.isStageReady = !0, T.init(), x.init(), v.preInit(k))
    }, {
        "./controls/cameraControls": 63,
        "./core/browser": 65,
        "./core/properties": 67,
        "./core/settings": 68,
        "./effects/areaLights/areaLights": 69,
        "./effects/blueNoise/blueNoise": 70,
        "./effects/glPositionOffset/glPositionOffset": 72,
        "./effects/mipmapper/Mipmapper": 73,
        "./helpers/fboHelper": 74,
        "./helpers/shaderHelper": 75,
        "./input/input": 77,
        "./io/exporter": 78,
        "./post/Postprocessing": 88,
        "./post/bloom/Bloom": 89,
        "./post/final/Final": 90,
        "./post/smaa/Smaa": 91,
        "./router/router": 92,
        "./shaders/shaders": 94,
        "./ui/about/about": 95,
        "./ui/editor/editor": 97,
        "./ui/header/header": 116,
        "./ui/preloader": 117,
        "./ui/prompt/prompt": 118,
        "./ui/shaderContext": 120,
        "./ui/viewInfos": 122,
        "./visual/visual": 133,
        glslify: 8,
        "mout/object/mixIn": 32,
        three: 57
    }],
    77: [function(e, t, n) {
        "use strict";
        var r = e("../core/settings"),
            i = e("../core/properties"),
            o = e("../utils/math"),
            a = e("three");
        n.init = function() {
            var e = r.canvas;
            i.mouse = new a.Vector2, i.mouseDown = new a.Vector2, i.easedMouse = new a.Vector2, i.easedMouse2 = new a.Vector2, e.addEventListener("mousedown", h), e.addEventListener("touchstart", m(h)), e.addEventListener("mousemove", d), e.addEventListener("touchmove", m(d)), document.documentElement.addEventListener("mouseup", p), document.documentElement.addEventListener("touchend", m(p))
        }, n.update = function(e) {
            i.easedMouse.lerp(i.mouse, i.mouseEaseRatio), i.easedMouse2.lerp(i.mouse, i.mouseEaseRatio2)
        };
        var s = void 0,
            l = void 0,
            c = void 0,
            u = 0;

        function h(e) {
            e.stopPropagation && e.stopPropagation(), s = f(e), i.mouseDown.set(s.x, s.y), l = s.x, c = s.y, u = +new Date, i.isMouseDown = !0, i.hasMouseJustDown = !0, d(e)
        }

        function d(e) {
            s = f(e), i.mouse.set(s.x, s.y), s.x, s.y
        }

        function p(e) {
            s = f(e), i.isMouseDown = !1, i.mouseDown.set, o.distanceTo(s.x - l, s.y - c) < 40 && +new Date - u < 200 && i.onCanvasClicked.dispatch(s)
        }

        function f(e) {
            var t = r.canvas.getBoundingClientRect();
            return {
                x: o.clamp((e.clientX - t.left) / t.width * 2 - 1, -1, 1),
                y: o.clamp(1 - (e.clientY - t.top) / t.height * 2, -1, 1)
            }
        }

        function m(t) {
            return function(e) {
                t.call(this, e.changedTouches[0] || e.touches[0])
            }
        }
    }, {
        "../core/properties": 67,
        "../core/settings": 68,
        "../utils/math": 124,
        three: 57
    }],
    78: [function(e, t, v) {
        "use strict";
        var g = e("three"),
            n = e("glslify"),
            y = e("../core/properties"),
            c = e("../utils/math"),
            x = e("../helpers/fboHelper"),
            b = e("../effects/glPositionOffset/glPositionOffset"),
            r = e("min-signal");
        v.init = function() {
            _ = new g.PerspectiveCamera, C = x.createRenderTarget(1, 1, !0, !0, !0), L = x.createRenderTarget(1, 1, !0, !0), A = new g.RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: C.texture
                    },
                    u_iteration: {
                        value: 0
                    }
                },
                vertexShader: x.vertexShader,
                fragmentShader: x.precisionPrefix + n(["#define GLSLIFY 1\nuniform sampler2D u_texture;\nuniform float u_iteration;\n\nvarying vec2 v_uv;\n\nvoid main () {\n\tvec4 sum = texture2D(u_texture, v_uv);\n    sum /= u_iteration;\n\tgl_FragColor = vec4(sum.rgb, 1.0);\n}"]),
                blending: g.NoBlending,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            })
        }, v.save = function(e, t, n) {
            v.isExporting = !0, S = c.clamp(n || 64, 4, u), M = e || 3840, T = t || 2160;
            for (var r = w = 0, i = Math.max(1, Math.sqrt(S - 1)), o = R.length = 0; o < S; o++) {
                r += 2.3999632297286535;
                var a = Math.sqrt(o) / i,
                    s = Math.cos(r),
                    l = Math.sin(r);
                a *= Math.min(Math.abs(1 / s), Math.abs(1 / l)), R.push({
                    x: s * a,
                    y: -l * a
                })
            }
            A.uniforms.u_iteration.value = S, C.setSize(M, T), L.setSize(M, T), x.clearColor(0, 0, 0, 1, C), v.onExportStarted.dispatch(S)
        }, v.update = function() {
            if (v.isExporting) {
                0 === w && (E = y.time, _.copy(y.camera), y.camera.matrixWorld.decompose(_.position, _.quaternion, _.scale), _.aspect = M / T, _.updateProjectionMatrix());
                var e = y.postprocessing.width,
                    t = y.postprocessing.height,
                    n = y.time;
                y.time = E, y.postprocessing.setSize(M, T);
                var r = R[w];
                r && b.setOffset(r.x / M, r.y / T);
                var i = y.smaa.enabled;
                y.smaa.enabled = !1, v.onBeforeRender.dispatch(w, r), y.postprocessing.render(y.scene, _, !1), v.onAfterRender.dispatch(w, r), y.smaa.enabled = i, x.copyMaterial.blending = g.CustomBlending, x.copyMaterial.blendSrc = g.OneFactor, x.copyMaterial.blendDst = g.OneFactor, x.copyMaterial.blendEquation = g.AddEquation, x.copyMaterial.blendSrcAlpha = g.OneFactor, x.copyMaterial.blendDstAlpha = g.OneFactor, x.copyMaterial.blendEquationAlpha = g.AddEquation;
                var o = x.getColorState();
                if (x.renderer.autoClearColor = !1, x.copy(y.postprocessing.fromTexture, C), x.setColorState(o), b.setOffset(0, 0), x.copyMaterial.blending = g.NoBlending, y.time = n, y.postprocessing.setSize(e, t), S <= ++w) {
                    x.render(A, L);
                    var a = new Uint8Array(M * T * 4);
                    x.renderer.readRenderTargetPixels(L, 0, 0, M, T, a);
                    var s = document.createElement("canvas"),
                        l = s.getContext("2d");
                    s.width = M, s.height = T;
                    for (var c = (s.ctx = l).createImageData(M, T), u = c.data, h = 4 * M, d = 0, p = 0, f = (T - 1) * h; d < T; d++) {
                        for (var m = 0; m < h; m++) u[p + m] = a[f + m];
                        p += h, f -= h
                    }
                    l.putImageData(c, 0, 0), v.onExportUpdated.dispatch(w / S), v.isExporting = !1, v.onExportEnded.dispatch(s)
                } else v.onExportUpdated.dispatch(w / S)
            }
        }, v.onExportStarted = new r, v.onExportUpdated = new r, v.onExportEnded = new r, v.onBeforeRender = new r, v.onAfterRender = new r, v.isExporting = !1;
        var _ = void 0,
            w = 0,
            S = 0,
            M = 0,
            T = 0,
            E = 0,
            C = void 0,
            L = void 0,
            A = void 0,
            R = [],
            u = 128
    }, {
        "../core/properties": 67,
        "../effects/glPositionOffset/glPositionOffset": 72,
        "../helpers/fboHelper": 74,
        "../utils/math": 124,
        glslify: 8,
        "min-signal": 10,
        three: 57
    }],
    79: [function(e, t, n) {
        "use strict";
        n.checkForSlot = function(e) {
            return !!window.localStorage.getItem("slot_" + e)
        }, n.loadFromSlot = function(e) {
            var t = window.localStorage.getItem("slot_" + e);
            return JSON.parse(t)
        }, n.saveToSlot = function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : properties.currentSketch;
            window.localStorage.setItem("slot_" + e, JSON.stringify(t))
        }
    }, {}],
    80: [function(e, t, n) {
        "use strict";
        var a = e("../core/settings"),
            s = e("../visual/screen/screenShader"),
            l = e("mout/object/get");
        n.load = function(e, t) {
            if (s.preInitTester(), e) {
                var n = new XMLHttpRequest;
                n.onerror = function() {
                    t({
                        success: !1,
                        errorType: 2
                    })
                }, n.onreadystatechange = function() {
                    if (4 === n.readyState && 200 === n.status) {
                        var e = void 0;
                        try {
                            e = JSON.parse(n.response)
                        } catch (e) {
                            return void t({
                                success: !1,
                                errorType: 1
                            })
                        }
                        e && function(e, t) {
                            var n = l(e, "Shader.renderpass"),
                                r = l(e, "Shader.info");
                            if (n) {
                                var i = n[0];
                                if (1 === n.length && "image" === i.type) {
                                    var o = s.testShader(i.code);
                                    t(o ? {
                                        success: !1,
                                        errorType: a.USE_WEBGL2 ? 3 : 4
                                    } : {
                                        success: !0,
                                        shader: i.code,
                                        shaderInfo: {
                                            id: r.id,
                                            title: r.name,
                                            description: r.description,
                                            username: r.username
                                        }
                                    })
                                } else t({
                                    success: !1,
                                    errorType: 5
                                })
                            } else t({
                                success: !1,
                                errorType: 2
                            })
                        }(e, t)
                    }
                }, n.responseType = "text", n.open("GET", "https://www.shadertoy.com/api/v1/shaders/" + e + "?key=" + a.API_KEY, !0), n.send(null)
            } else t({
                success: !1,
                errorType: 1
            })
        }, n.ERROR_MESSAGES = {
            1: "Shadertoy Id is missing.",
            2: "Shadertoy Id is invalid or it doesn't allow api access.",
            3: "This shadertoy is not compatible with Cine Shader.",
            4: "This shadertoy is not compatible with Cine Shader or it uses WebGL 2 special codes which your browser doesn't support.",
            5: "This shadertoy used framebuffer which Cine Shader doesn't support."
        }
    }, {
        "../core/settings": 68,
        "../visual/screen/screenShader": 131,
        "mout/object/get": 29
    }],
    81: [function(e, t, n) {
        "use strict";
        var r = e("three");

        function i() {
            this.position = new r.Vector3, this.rotation = new r.Quaternion, this.scale = new r.Vector3(1, 1, 1), this.matrix = new r.Matrix4, this.enablePositionNoise = !0, this.enableRotationNoise = !0, this.positionFrequency = .25, this.rotationFrequency = .25, this.positionAmplitude = .3, this.rotationAmplitude = .003, this.positionScale = new r.Vector3(1, 1, 1), this.rotationScale = new r.Vector3(1, 1, 0), this.positionFractalLevel = 3, this.rotationFractalLevel = 3, this.times = new Float32Array(6), this.rehash()
        }
        var o = (t.exports = i).prototype;
        o.rehash = function() {
            for (var e = 0; e < 6; e++) this.times[e] = -1e4 * Math.random()
        }, o.update = function(e) {
            var t;
            if (e = void 0 === e ? 1e3 / 60 : e, this.enablePositionNoise) {
                for (t = 0; t < 3; t++) this.times[t] += this.positionFrequency * e;
                s.set(u(this.times[0], this.positionFractalLevel), u(this.times[1], this.positionFractalLevel), u(this.times[2], this.positionFractalLevel)), s.multiply(this.positionScale), s.multiplyScalar(this.positionAmplitude * l), this.position.copy(s)
            }
            if (this.enableRotationNoise) {
                for (t = 0; t < 3; t++) this.times[t + 3] += this.rotationFrequency * e;
                s.set(u(this.times[3], this.rotationFractalLevel), u(this.times[4], this.rotationFractalLevel), u(this.times[5], this.rotationFractalLevel)), s.multiply(this.rotationScale), s.multiplyScalar(this.rotationAmplitude * l), a.set(s.x, s.y, s.z), this.rotation.setFromEuler(a)
            }
            this.matrix.compose(this.position, this.rotation, this.scale)
        };
        var a = new r.Euler,
            s = new r.Vector3,
            l = 1 / .75;
        var c = new function() {
            for (var s = 1, l = 1, c = [], e = 0; e < 256; ++e) c.push(Math.random());
            var u = function(e, t, n) {
                return e * (1 - n) + t * n
            };
            return {
                getVal: function(e) {
                    var t = e * l,
                        n = Math.floor(t),
                        r = t - n,
                        i = r * r * (3 - 2 * r),
                        o = 255 & n,
                        a = 1 + o & 255;
                    return u(c[o], c[a], i) * s
                },
                setAmplitude: function(e) {
                    s = e
                },
                setScale: function(e) {
                    l = e
                }
            }
        };

        function u(e, t) {
            for (var n = 0, r = .5, i = 0; i < t; i++) n += r * c.getVal(e), e *= 2, r *= .5;
            return n
        }
    }, {
        three: 57
    }],
    82: [function(e, t, n) {
        "use strict";
        var o = e("../core/settings"),
            a = e("../core/properties"),
            r = e("./Page"),
            s = e("gsap").gsap,
            l = e("../ui/header/header"),
            c = e("../ui/about/about");
        e("../ui/transitionBlock");

        function i() {
            u.constructor.call(this, {
                id: "about",
                aliases: [/about/]
            })
        }
        t.exports = i;
        var u = r.prototype,
            h = i.prototype = Object.create(u);
        h.constructor = r, h.show = function(e, t, n, r, i) {
            a.isAbout = !0, e === n ? i() : (!1 !== a.useHalfScreen && (a.useHalfScreen = !1, a.forceRenderOnResize = !0, o.resize()), c.show(), l.updateMenu(2), s.to(a, 1, {
                pageRatio: 1,
                onComplete: i
            }))
        }, h.hide = function(e, t, n, r, i) {
            a.isAbout = !1, e === n ? i() : (c.hide(), s.to(a, 1, {
                pageRatio: 0,
                onComplete: i
            }))
        }
    }, {
        "../core/properties": 67,
        "../core/settings": 68,
        "../ui/about/about": 95,
        "../ui/header/header": 116,
        "../ui/transitionBlock": 121,
        "./Page": 85,
        gsap: 9
    }],
    83: [function(e, t, n) {
        "use strict";
        var o = e("../core/settings"),
            a = e("../core/properties"),
            r = e("./Page"),
            s = e("../ui/editor/editor"),
            l = e("../ui/header/header"),
            c = e("gsap").gsap;

        function i() {
            d = document.querySelector(".editor"), u.constructor.call(this, {
                id: "editor",
                isMobileBlock: !0,
                mobileBlockMsg: "The Editor mode doesn't work on mobile. Please try it on a desktop device.",
                aliases: [/editor/]
            })
        }
        t.exports = i;
        var u = r.prototype,
            h = i.prototype = Object.create(u);
        h.constructor = r, h.show = function(e, t, n, r, i) {
            a.isEditor = !0, e === n ? i() : (!0 !== a.useHalfScreen && (a.useHalfScreen = !0, a.forceRenderOnResize = !0, o.resize()), s.initLocalSketches(), s.show(), s.resize(), l.updateMenu(1), c.to(d, 1, {
                opacity: 1
            }), c.to(a, 1, {
                pageRatio: 1,
                onComplete: i
            }))
        }, h.hide = function(e, t, n, r, i) {
            a.isEditor = !1, e === n ? i() : (s.hide(), c.to(d, 1, {
                opacity: 0
            }), c.to(a, 1, {
                pageRatio: 0,
                onComplete: i
            }))
        };
        var d = void 0
    }, {
        "../core/properties": 67,
        "../core/settings": 68,
        "../ui/editor/editor": 97,
        "../ui/header/header": 116,
        "./Page": 85,
        gsap: 9
    }],
    84: [function(e, t, n) {
        "use strict";
        var a = e("../core/settings"),
            s = e("../core/properties"),
            r = e("./Page"),
            l = e("gsap").gsap,
            c = e("../controls/cameraControls"),
            o = e("../ui/shaderContext"),
            u = e("../visual/screen/screenShader"),
            h = e("../ui/header/header"),
            d = e("../shaders/shaders");

        function i() {
            p.constructor.call(this, {
                id: "home",
                aliasTestPirority: -100,
                aliases: [/.+/]
            })
        }
        t.exports = i;
        var p = r.prototype,
            f = i.prototype = Object.create(p);
        f.constructor = r, f.show = function(e, t, n, r, i) {
            if (s.isHome = !0, e === n) i();
            else {
                !1 !== s.useHalfScreen && (s.useHalfScreen = !1, s.forceRenderOnResize = !0, a.resize()), c.changeMode("splines"), c.modes.splines.restart(), s.viewQuality = a.DEFAULT_VIEW_QUALITY;
                var o = d.infos[s.templateShaderId];
                u.changeShader((o || d.splineShaderList[0].id).shader), s.modelId = "person", h.updateMenu(0), l.to(s, 1, {
                    pageRatio: 1,
                    onComplete: i
                })
            }
        }, f.hide = function(e, t, n, r, i) {
            s.isHome = !1, o.hide(), e === n ? i() : l.to(s, 1, {
                pageRatio: 0,
                onComplete: i
            })
        }
    }, {
        "../controls/cameraControls": 63,
        "../core/properties": 67,
        "../core/settings": 68,
        "../shaders/shaders": 94,
        "../ui/header/header": 116,
        "../ui/shaderContext": 120,
        "../visual/screen/screenShader": 131,
        "./Page": 85,
        gsap: 9
    }],
    85: [function(e, t, n) {
        "use strict";
        var r = e("mout/object/mixIn");

        function i(e) {
            r(this, {
                id: "",
                aliasTestPirority: 0,
                isMobileBlock: !1,
                mobileBlockMsg: "",
                aliases: []
            }, e)
        }
        var o = i.prototype;
        t.exports = i;
        o.show = function(e, t, n, r, i) {
            i()
        }, o.hide = function(e, t, n, r, i) {
            i()
        }
    }, {
        "mout/object/mixIn": 32
    }],
    86: [function(e, t, n) {
        "use strict";
        var o = e("../core/settings"),
            a = e("../core/properties"),
            r = e("./Page"),
            s = e("gsap").gsap,
            l = e("../controls/cameraControls"),
            c = e("../ui/viewInfos"),
            u = e("../ui/header/header"),
            h = e("../visual/screen/screenShader");

        function i() {
            d.constructor.call(this, {
                id: "view",
                aliases: [/view\/.+/]
            })
        }
        t.exports = i;
        var d = r.prototype,
            p = i.prototype = Object.create(d);
        p.constructor = r, p.show = function(e, t, n, r, i) {
            a.isView = !0, e === n ? i() : (!1 !== a.useHalfScreen && (a.useHalfScreen = !1, a.forceRenderOnResize = !0, o.resize()), l.changeMode("splines"), l.modes.splines.restart(), a.viewQuality = o.DEFAULT_VIEW_QUALITY, f || !a.viewSketch || a.isPreview || (a.currentSketch = a.viewSketch, h.changeShader(a.currentSketch.shader)), u.updateMenu(), s.to(a, 1, {
                pageRatio: 1,
                onComplete: i
            }), f = !1)
        }, p.hide = function(e, t, n, r, i) {
            a.isView = !1, e === n ? i() : (c.hide(), s.to(a, 1, {
                pageRatio: 0,
                onComplete: i
            }))
        };
        var f = !0
    }, {
        "../controls/cameraControls": 63,
        "../core/properties": 67,
        "../core/settings": 68,
        "../ui/header/header": 116,
        "../ui/viewInfos": 122,
        "../visual/screen/screenShader": 131,
        "./Page": 85,
        gsap: 9
    }],
    87: [function(e, t, n) {
        "use strict";
        var r = e("three"),
            i = e("mout/object/merge"),
            o = e("../helpers/fboHelper");

        function a(e) {
            i(this, {
                uniforms: {
                    u_texture: {},
                    u_resolution: {
                        value: null
                    },
                    u_fullResolution: {
                        value: null
                    },
                    u_isVR: {
                        value: !1
                    }
                },
                defines: {},
                enabled: !0,
                vertexShader: "",
                fragmentShader: "",
                isRawMaterial: !0,
                depthTest: !1,
                depthWrite: !1,
                blending: r.NoBlending,
                transparent: !0
            }, e), this.vertexShader || (this.vertexShader = o.vertexShader), this.addRawShaderPrefix && this.isRawMaterial && (this.vertexShader = o.precisionPrefix + this.vertexShader, this.fragmentShader = o.precisionPrefix + this.fragmentShader), this.material = new(this.isRawMaterial ? r.RawShaderMaterial : r.ShaderMaterial)({
                uniforms: this.uniforms,
                vertexShader: this.vertexShader,
                fragmentShader: this.fragmentShader,
                defines: this.defines,
                depthTest: this.depthTest,
                depthWrite: this.depthWrite,
                blending: this.blending,
                transparent: this.transparent
            })
        }
        t.exports = a;
        var s = a.prototype;
        s.setPostprocessing = function(e) {
            this.uniforms.u_resolution.value = e.resolution
        }, s.dispose = function() {}, s.needsRender = function() {
            return !0
        }, s.render = function(e, t) {
            this.uniforms.u_texture.value = e.fromTexture, e.renderMaterial(this.material, t ? null : e.toRenderTarget), e.swap()
        }
    }, {
        "../helpers/fboHelper": 74,
        "mout/object/merge": 31,
        three: 57
    }],
    88: [function(e, t, n) {
        "use strict";
        var r = e("three"),
            u = e("../helpers/fboHelper"),
            i = e("min-signal");

        function o(e, t) {
            h || n.init(), this.width = 1, this.height = 1, this.scene = null, this.camera = null, this.preserveScene = e, this.resolution = new r.Vector2(0, 0), this.fullResolution = new r.Vector2(0, 0), this.onBeforeSceneRendered = new i, this.onAfterSceneRendered = new i, this.onAfterRendered = new i, this.fromRenderTarget = u.createRenderTarget(1, 1, !0), this.fromRenderTarget.depthBuffer = !0, this.fromRenderTarget.stencilBuffer = !0, this.toRenderTarget = this.fromRenderTarget.clone(), this.prevSceneRenderTarget = e ? this.fromRenderTarget.clone() : null, this.sceneRenderTarget = e ? this.fromRenderTarget.clone() : null, this.useDepthTexture = !!t, this.useDepthTexture && (this.depthTexture = new r.DepthTexture, this.depthTexture.type = r.UnsignedShortType, this.depthTextureUniform = {
                value: this.depthTexture
            }), this.fromTexture = this.fromRenderTarget.texture, this.toTexture = this.toRenderTarget.texture, this.prevSceneTexture = e ? this.prevSceneRenderTarget.texture : null, this.sceneTexture = e ? this.sceneRenderTarget.texture : null, this.mesh = new r.Mesh, this.queue = []
        }
        var a = o.prototype;
        n = t.exports = o, a.swap = function() {
            var e = this.fromRenderTarget;
            this.fromRenderTarget = this.toRenderTarget, this.toRenderTarget = e, this.fromTexture = this.fromRenderTarget.texture, this.toTexture = this.toRenderTarget.texture
        }, a.setSize = function(e, t) {
            this.width = e, this.height = t, this.resolution.set(e, t), this.fullResolution.set(e, t), this.preserveScene && this.sceneRenderTarget.setSize(e, t);
            this.preserveScene && this.prevSceneRenderTarget.setSize(e, t);
            this.fromRenderTarget.setSize(e, t), this.toRenderTarget.setSize(e, t)
        }, a.dispose = function() {
            this.fromRenderTarget && this.fromRenderTarget.dispose();
            this.toRenderTarget && this.toRenderTarget.dispose();
            this.prevSceneRenderTarget && this.prevSceneRenderTarget.dispose();
            this.sceneRenderTarget && this.sceneRenderTarget.dispose()
        }, a.renderMaterial = function(e, t) {
            this.mesh.material = e, u.renderMesh(this.mesh, t)
        }, a.render = function(e, t, n) {
            this.scene = e, this.camera = t, this.mesh.geometry = u.renderer.xr.enabled ? d : h;
            var r = this.queue.filter(p),
                i = void 0;
            if (this.onBeforeSceneRendered.dispatch(), this.preserveScene) {
                var o = this.prevSceneRenderTarget;
                this.prevSceneRenderTarget = this.sceneRenderTarget, this.sceneRenderTarget = o, this.prevSceneTexture = this.prevSceneRenderTarget.texture, this.sceneTexture = this.sceneRenderTarget.texture
            }
            if (r.length) {
                this.useDepthTexture && (this.fromRenderTarget.depthTexture = this.depthTexture), u.renderer.setRenderTarget(this.fromRenderTarget), u.renderer.render(e, t), u.renderer.setRenderTarget(null), this.preserveScene && u.copy(this.fromRenderTarget.texture, this.sceneRenderTarget), this.onAfterSceneRendered.dispatch(this.fromRenderTarget, this.sceneRenderTarget);
                var a = u.getColorState();
                u.renderer.autoClear = !1;
                for (var s = 0, l = r.length; s < l; s++) {
                    var c = s === l - 1 && n;
                    (i = r[s]).setPostprocessing(this), i.render(this, c)
                }
                u.setColorState(a)
            } else this.preserveScene ? (u.renderer.setRenderTarget(this.sceneRenderTarget), u.renderer.render(e, t), u.renderer.setRenderTarget(null), n && u.copy(this.sceneRenderTarget.texture), this.onAfterSceneRendered.dispatch(this.sceneRenderTarget, null)) : u.renderer.render(e, t);
            this.onAfterRendered.dispatch()
        };
        var h = n.geom = null,
            d = n.vrGeom = null;

        function p(e) {
            return e.enabled && e.needsRender()
        }
        n.init = function() {
            (h = n.geom = n.geom || new r.BufferGeometry).setAttribute("position", new r.BufferAttribute(new Float32Array([-1, -1, 0, 4, -1, 0, -1, 4, 0]), 3)), h.setAttribute("a_uvClamp", new r.BufferAttribute(new Float32Array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]), 4)), (d = n.vrGeom = n.vrGeom || new r.BufferGeometry).setAttribute("position", new r.BufferAttribute(new Float32Array([-4, -1, 0, 0, -1, 0, 0, 4, 0, 0, -1, 0, 4, -1, 0, 0, 4, 0]), 3)), d.setAttribute("a_uvClamp", new r.BufferAttribute(new Float32Array([0, 0, .5, 1, 0, 0, .5, 1, 0, 0, .5, 1, .5, 0, 1, 1, .5, 0, 1, 1, .5, 0, 1, 1]), 4))
        }
    }, {
        "../helpers/fboHelper": 74,
        "min-signal": 10,
        three: 57
    }],
    89: [function(e, t, n) {
        "use strict";
        var r = e("../PostEffect"),
            l = e("../../helpers/fboHelper"),
            c = e("../../utils/math"),
            u = e("mout/object/merge"),
            h = e("glslify"),
            d = e("three");

        function i(e) {
            var t = (e = u({
                useHighPass: !0,
                ITERATION: 5,
                amount: .75,
                radius: .75,
                threshold: .1
            }, e)).ITERATION;
            this.directionX = new d.Vector2(1, 0), this.directionY = new d.Vector2(0, 1);
            var n = this.highPassRenderTarget = l.createRenderTarget(1, 1, !0);
            this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.blurMaterials = [];
            for (var r = 0; r < t; r++) this.renderTargetsHorizontal.push(n.clone()), this.renderTargetsVertical.push(n.clone());
            for (var i = {
                    u_bloomStrength: {
                        value: 1
                    },
                    u_bloomWeights: {
                        value: []
                    }
                }, o = 0; o < t; o++) i["u_blurTexture" + o] = {
                value: this.renderTargetsVertical[o].texture
            };
            p.constructor.call(this, u({
                uniforms: i,
                defines: {
                    ITERATION: t
                },
                fragmentShader: l.precisionPrefix + h(["#define GLSLIFY 1\nvarying vec2 v_uv;\nuniform sampler2D u_texture;\n\nuniform sampler2D u_blurTexture0;\n#if ITERATION > 1\nuniform sampler2D u_blurTexture1;\n#endif\n#if ITERATION > 2\nuniform sampler2D u_blurTexture2;\n#endif\n#if ITERATION > 3\nuniform sampler2D u_blurTexture3;\n#endif\n#if ITERATION > 4\nuniform sampler2D u_blurTexture4;\n#endif\nuniform float u_bloomWeights[ITERATION];\n\n#include <common>\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\nvoid main() {\n\tvec4 c = texture2D(u_texture, v_uv);\n\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\tfloat v = dot( c.xyz, luma );\n\tfloat a = 1.0 - v;//max(0.0, 1.2 - v);//mix(1.0, 0.1, v);\n\n\tgl_FragColor = c + (\n\t\tu_bloomWeights[0] * texture2D(u_blurTexture0, v_uv)\n\t\t#if ITERATION > 1\n\t\t+ u_bloomWeights[1] * texture2D(u_blurTexture1, v_uv)\n\t\t#endif\n\t\t#if ITERATION > 2\n\t\t+ u_bloomWeights[2] * texture2D(u_blurTexture2, v_uv)\n\t\t#endif\n\t\t#if ITERATION > 3\n\t\t+ u_bloomWeights[3] * texture2D(u_blurTexture3, v_uv)\n\t\t#endif\n\t\t#if ITERATION > 4\n\t\t+ u_bloomWeights[4] * texture2D(u_blurTexture4, v_uv)\n\t\t#endif\n\t) * a;\n\n    gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\tgl_FragColor.a = 1.0;\n}\n"]),
                blending: d.NoBlending
            }, e)), this.highPassMaterial = new d.RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_luminosityThreshold: {
                        value: 1
                    },
                    u_smoothWidth: {
                        value: 1
                    }
                },
                vertexShader: l.precisionPrefix + l.vertexShader,
                fragmentShader: l.precisionPrefix + h(["#define GLSLIFY 1\nuniform sampler2D u_texture;\n\nuniform float u_luminosityThreshold;\nuniform float u_smoothWidth;\n\nvarying vec2 v_uv;\n\nvoid main() {\n\n  vec4 texel = texture2D( u_texture, v_uv );\n\n  vec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n  float v = dot( texel.xyz, luma );\n\n  vec4 outputColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n  float alpha = smoothstep( u_luminosityThreshold, u_luminosityThreshold + u_smoothWidth, v );\n\n  outputColor = mix( outputColor, texel, alpha );\n\n  gl_FragColor = vec4(outputColor.rgb, 1.0);\n\n}\n"])
            });
            for (var a = 0; a < this.ITERATION; a++) {
                var s = 3 + 2 * a;
                this.blurMaterials[a] = new d.RawShaderMaterial({
                    uniforms: {
                        u_texture: {
                            value: null
                        },
                        u_resolution: {
                            value: new d.Vector2
                        },
                        u_direction: {
                            value: null
                        }
                    },
                    vertexShader: l.precisionPrefix + l.vertexShader,
                    fragmentShader: l.precisionPrefix + h(["#define GLSLIFY 1\nvarying vec2 v_uv;\nuniform sampler2D u_texture;\nuniform vec2 u_resolution;\nuniform vec2 u_direction;\n\nfloat gaussianPdf(in float x, in float sigma) {\n  return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n}\nvoid main() {\n  vec2 invSize = 1.0 / u_resolution;\n  float fSigma = float(SIGMA);\n  float weightSum = gaussianPdf(0.0, fSigma);\n  vec3 diffuseSum = texture2D( u_texture, v_uv).rgb * weightSum;\n  for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n    float x = float(i);\n    float w = gaussianPdf(x, fSigma);\n    vec2 uvOffset = u_direction * invSize * x;\n    vec3 sample1 = texture2D( u_texture, v_uv + uvOffset).rgb;\n    vec3 sample2 = texture2D( u_texture, v_uv - uvOffset).rgb;\n    diffuseSum += (sample1 + sample2) * w;\n    weightSum += 2.0 * w;\n  }\n  gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n}\n"]),
                    defines: {
                        KERNEL_RADIUS: s,
                        SIGMA: s
                    }
                })
            }
        }
        var p = r.prototype,
            o = i.prototype = Object.create(p);
        o.constructor = i, o.setPostprocessing = function(e) {
            p.setPostprocessing.call(this, e);
            var t = e.width,
                n = e.height,
                r = Math.ceil(t / 2),
                i = Math.ceil(n / 2);
            this.highPassRenderTarget.setSize(r, i);
            for (var o = 0; o < this.ITERATION; o++) this.renderTargetsHorizontal[o].setSize(r, i), this.renderTargetsVertical[o].setSize(r, i), this.blurMaterials[o].uniforms.u_resolution.value = new d.Vector2(r, i), r = Math.ceil(r / 2), i = Math.ceil(i / 2)
        }, o.dispose = function() {
            this.highPassRenderTarget && this.highPassRenderTarget.dispose();
            for (var e = 0; e < this.ITERATION; e++) this.renderTargetsHorizontal[e] && this.renderTargetsHorizontal[e].dispose(), this.renderTargetsVertical[e] && this.renderTargetsVertical[e].dispose()
        }, o.needsRender = function() {
            return !!this.amount
        }, o.render = function(e, t) {
            var n = this.ITERATION;
            this.useHighPass && (this.highPassMaterial.uniforms.u_texture.value = e.fromTexture, this.highPassMaterial.uniforms.u_luminosityThreshold.value = this.threshold, e.renderMaterial(this.highPassMaterial, this.highPassRenderTarget));
            for (var r = this.useHighPass ? this.highPassRenderTarget : e.fromRenderTarget, i = 0; i < n; i++) {
                var o = this.blurMaterials[i];
                o.uniforms.u_texture.value = r.texture, o.uniforms.u_direction.value = this.directionX, e.renderMaterial(o, this.renderTargetsHorizontal[i]), o.uniforms.u_texture.value = this.renderTargetsHorizontal[i].texture, o.uniforms.u_direction.value = this.directionY, e.renderMaterial(o, this.renderTargetsVertical[i]), r = this.renderTargetsVertical[i]
            }
            this.material.uniforms.u_texture.value = e.fromTexture;
            for (var a = 0; a < n; a++) {
                var s = (n - a) / n;
                this.uniforms.u_bloomWeights.value[a] = this.amount * c.mix(s, 1.2 - s, this.radius) / Math.pow(2, n - a - 1)
            }
            p.render.call(this, e, t)
        }, t.exports = i
    }, {
        "../../helpers/fboHelper": 74,
        "../../utils/math": 124,
        "../PostEffect": 87,
        glslify: 8,
        "mout/object/merge": 31,
        three: 57
    }],
    90: [function(e, t, n) {
        "use strict";
        var r = e("../PostEffect"),
            i = e("../../effects/blur/blur"),
            o = e("../../helpers/fboHelper"),
            a = e("../../utils/math"),
            s = e("mout/object/merge"),
            l = e("glslify"),
            c = e("three");

        function u(e) {
            e = s({
                opacity: 1,
                rgbOffset: .001,
                bgColor: "#051015"
            }, e), h.constructor.call(this, s({
                uniforms: {
                    u_opacity: {
                        value: 0
                    },
                    u_rgbOffset: {
                        value: .01
                    },
                    u_bgColor: {
                        value: new c.Color
                    }
                },
                fragmentShader: o.precisionPrefix + l(["#define GLSLIFY 1\nvarying vec2 v_uv;\nuniform sampler2D u_texture;\nuniform float u_opacity;\nuniform vec3 u_bgColor;\nuniform float u_rgbOffset;\n\nvec3 screen (vec3 cb, vec3 cs) {\n\treturn cb + cs - (cb * cs);\n}\n\nvec3 colorDodge (vec3 cb, vec3 cs) {\n\treturn mix(\n\t\tmin(vec3(1.0), cb / (1.0 - cs)),\n\t\tvec3(1.0),\n\t\tstep(vec3(1.0), cs)\n\t);\n}\n\nvoid main() {\n\tvec2 uv = v_uv;\n\tvec2 uvOffset = (uv - 0.5) * (1.0 + u_rgbOffset * mix(16.0, 0.0, u_opacity * u_opacity)) + 0.5 - uv;\n\tvec3 color = vec3(\n\t\ttexture2D(u_texture, uv + uvOffset).r,\n\t\ttexture2D(u_texture, uv).g,\n\t\ttexture2D(u_texture, uv - uvOffset).b\n\t);\n\n\tcolor *= u_opacity;\n\n\t// vigeette\n\tvec2 toCenter = uv - 0.5;\n\tcolor *= 1.0 - dot(toCenter, toCenter) * 2.0;\n\n\t// linear dodge add\n\tcolor = mix(color, screen(colorDodge(color, u_bgColor), u_bgColor), 0.75);\n\n\tgl_FragColor = vec4(mix(vec3(0.0196078431372549,0.06274509803921569,0.08235294117647059), color, min(1.0, u_opacity * 8.0)), 1.0);\n}\n"]),
                blending: c.NoBlending
            }, e)), this.blurRenderTarget = o.createRenderTarget(1, 1)
        }
        t.exports = u;
        var h = r.prototype,
            d = u.prototype = Object.create(h);
        d.constructor = u, d.needsRender = function() {
            return !0
        }, d.render = function(e, t) {
            this.uniforms.u_opacity.value = this.opacity, this.uniforms.u_rgbOffset.value = this.rgbOffset, this.uniforms.u_bgColor.value.set(this.bgColor);
            var n = a.cUnMix(.5, 0, this.opacity);
            0 < n && (i.blur9(2 * n, .5, e.fromRenderTarget, this.blurRenderTarget, e.fromRenderTarget), i.blur9(4 * n, .25, e.fromRenderTarget, this.blurRenderTarget, e.fromRenderTarget), i.blur9(8 * n, .25, e.fromRenderTarget, this.blurRenderTarget, e.fromRenderTarget));
            h.render.call(this, e, t)
        }
    }, {
        "../../effects/blur/blur": 71,
        "../../helpers/fboHelper": 74,
        "../../utils/math": 124,
        "../PostEffect": 87,
        glslify: 8,
        "mout/object/merge": 31,
        three: 57
    }],
    91: [function(e, t, n) {
        "use strict";
        var i = e("../../helpers/fboHelper"),
            r = e("../PostEffect"),
            o = e("mout/object/merge"),
            a = e("three"),
            s = e("glslify");

        function l(e) {
            e = o({}, e), this.edgesRenderTarget = i.createRenderTarget(1, 1), this.weightsRenderTarget = i.createRenderTarget(1, 1, !0), this.uResolutionInv = {
                value: new a.Vector2
            }, c.constructor.call(this, o({
                uniforms: {
                    u_weightsTexture: {
                        value: this.weightsRenderTarget.texture
                    },
                    u_resolutionInv: this.uResolutionInv
                },
                vertexShader: i.precisionPrefix + s(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform vec2 u_resolutionInv;\n\nvarying vec2 v_uv;\nvarying vec4 v_offsets[ 2 ];\n\nvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n  v_offsets[ 0 ] = texcoord.xyxy + u_resolutionInv.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n  v_offsets[ 1 ] = texcoord.xyxy + u_resolutionInv.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n}\n\nvoid main() {\n\tv_uv = position.xy * 0.5 + 0.5;\n\n  SMAANeighborhoodBlendingVS( v_uv );\n\n  // gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = vec4( position, 1.0 );\n\n}\n"]),
                fragmentShader: i.precisionPrefix + s(["#define GLSLIFY 1\nuniform sampler2D u_weightsTexture;\nuniform sampler2D u_texture;\nuniform vec2 u_resolutionInv;\n\nvarying vec2 v_uv;\nvarying vec4 v_offsets[ 2 ];\n\nvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n  // Fetch the blending weights for current pixel:\n  vec4 a;\n  a.xz = texture2D( blendTex, texcoord ).xz;\n  a.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n  a.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n  // Is there any blending weight with a value greater than 0.0?\n  if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n    return texture2D( colorTex, texcoord, 0.0 );\n  } else {\n    // Up to 4 lines can be crossing a pixel (one through each edge). We\n    // favor blending by choosing the line with the maximum weight for each\n    // direction:\n    vec2 offset;\n    offset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n    offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n    // Then we go in the direction that has the maximum weight:\n    if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n      offset.y = 0.0;\n    } else {\n      offset.x = 0.0;\n    }\n\n    // Fetch the opposite color and lerp by hand:\n    vec4 C = texture2D( colorTex, texcoord, 0.0 );\n    texcoord += sign( offset ) * u_resolutionInv;\n    vec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n    float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n    // WebGL port note: Added gamma correction\n    C.xyz = pow(abs(C.xyz), vec3(2.2));\n    Cop.xyz = pow(abs(Cop.xyz), vec3(2.2));\n    vec4 mixed = mix(C, Cop, s);\n    mixed.xyz = pow(abs(mixed.xyz), vec3(1.0 / 2.2));\n\n    return mixed;\n  }\n}\n\nvoid main() {\n\n  gl_FragColor = SMAANeighborhoodBlendingPS( v_uv, v_offsets, u_texture, u_weightsTexture );\n}\n"])
            }, e)), this.edgesMaterial = new a.RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_resolutionInv: this.uResolutionInv
                },
                vertexShader: i.precisionPrefix + s(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform vec2 u_resolutionInv;\n\nvarying vec2 v_uv;\nvarying vec4 v_offsets[ 3 ];\n\nvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\n  v_offsets[ 0 ] = texcoord.xyxy + u_resolutionInv.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n  v_offsets[ 1 ] = texcoord.xyxy + u_resolutionInv.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n  v_offsets[ 2 ] = texcoord.xyxy + u_resolutionInv.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n}\n\nvoid main() {\n\n\tv_uv = position.xy * 0.5 + 0.5;\n\n  SMAAEdgeDetectionVS( v_uv );\n\n  // gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = vec4( position, 1.0 );\n\n}\n"]),
                fragmentShader: i.precisionPrefix + s(["#define GLSLIFY 1\nuniform sampler2D u_texture;\n\nvarying vec2 v_uv;\nvarying vec4 v_offsets[ 3 ];\n\nvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n  vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n  // Calculate color deltas:\n  vec4 delta;\n  vec3 C = texture2D( colorTex, texcoord ).rgb;\n\n  vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n  vec3 t = abs( C - Cleft );\n  delta.x = max( max( t.r, t.g ), t.b );\n\n  vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n  t = abs( C - Ctop );\n  delta.y = max( max( t.r, t.g ), t.b );\n\n  // We do the usual threshold:\n  vec2 edges = step( threshold, delta.xy );\n\n  // Then discard if there is no edge:\n  if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n    discard;\n\n  // Calculate right and bottom deltas:\n  vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n  t = abs( C - Cright );\n  delta.z = max( max( t.r, t.g ), t.b );\n\n  vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n  t = abs( C - Cbottom );\n  delta.w = max( max( t.r, t.g ), t.b );\n\n  // Calculate the maximum delta in the direct neighborhood:\n  float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n  // Calculate left-left and top-top deltas:\n  vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n  t = abs( C - Cleftleft );\n  delta.z = max( max( t.r, t.g ), t.b );\n\n  vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n  t = abs( C - Ctoptop );\n  delta.w = max( max( t.r, t.g ), t.b );\n\n  // Calculate the final maximum delta:\n  maxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n  // Local contrast adaptation in action:\n  edges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n  return vec4( edges, 0.0, 0.0 );\n}\n\nvoid main() {\n\n  gl_FragColor = SMAAColorEdgeDetectionPS( v_uv, v_offsets, u_texture );\n\n}\n"]),
                defines: {
                    SMAA_THRESHOLD: "0.1"
                },
                blending: a.NoBlending,
                depthTest: !1,
                depthWrite: !1
            }), this.weightsMaterial = new a.RawShaderMaterial({
                uniforms: {
                    u_edgesTexture: {
                        value: this.edgesRenderTarget.texture
                    },
                    u_areaTexture: h.u_areaTexture,
                    u_searchTexture: h.u_searchTexture,
                    u_resolutionInv: this.uResolutionInv
                },
                vertexShader: i.precisionPrefix + s(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform vec2 u_resolutionInv;\n\nvarying vec2 v_uv;\nvarying vec4 v_offsets[ 3 ];\nvarying vec2 v_pixcoord;\n\nvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n  v_pixcoord = texcoord / u_resolutionInv;\n\n  // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n  v_offsets[ 0 ] = texcoord.xyxy + u_resolutionInv.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n  v_offsets[ 1 ] = texcoord.xyxy + u_resolutionInv.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n  // And these for the searches, they indicate the ends of the loops:\n  v_offsets[ 2 ] = vec4( v_offsets[ 0 ].xz, v_offsets[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * u_resolutionInv.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n}\n\nvoid main() {\n\tv_uv = position.xy * 0.5 + 0.5;\n\n  SMAABlendingWeightCalculationVS( v_uv );\n\n  // gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = vec4( position, 1.0 );\n\n}\n"]),
                fragmentShader: i.precisionPrefix + s(["#define GLSLIFY 1\n#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * u_resolutionInv, 0.0 )\n\nuniform sampler2D u_edgesTexture;\nuniform sampler2D u_areaTexture;\nuniform sampler2D u_searchTexture;\nuniform vec2 u_resolutionInv;\n\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixcoord;\n\nvec2 round( vec2 x ) {\n  return sign( x ) * floor( abs( x ) + 0.5 );\n}\n\nfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n  // Not required if searchTex accesses are set to point:\n  // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n  // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n  //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n  e.r = bias + e.r * scale;\n  return 255.0 * texture2D( searchTex, e, 0.0 ).r;\n}\n\nfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n  /**\n  * @PSEUDO_GATHER4\n  * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n  * sample between edge, thus fetching four edges in a row.\n  * Sampling with different offsets in each direction allows to disambiguate\n  * which edges are active from the four fetched ones.\n  */\n  vec2 e = vec2( 0.0, 1.0 );\n\n  for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    texcoord -= vec2( 2.0, 0.0 ) * u_resolutionInv;\n    if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n  }\n\n  // We correct the previous (-0.25, -0.125) offset we applied:\n  texcoord.x += 0.25 * u_resolutionInv.x;\n\n  // The searches are bias by 1, so adjust the coords accordingly:\n  texcoord.x += u_resolutionInv.x;\n\n  // Disambiguate the length added by the last step:\n  texcoord.x += 2.0 * u_resolutionInv.x; // Undo last step\n  texcoord.x -= u_resolutionInv.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n  return texcoord.x;\n}\n\nfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n  vec2 e = vec2( 0.0, 1.0 );\n\n  for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    texcoord += vec2( 2.0, 0.0 ) * u_resolutionInv;\n    if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n  }\n\n  texcoord.x -= 0.25 * u_resolutionInv.x;\n  texcoord.x -= u_resolutionInv.x;\n  texcoord.x -= 2.0 * u_resolutionInv.x;\n  texcoord.x += u_resolutionInv.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n  return texcoord.x;\n}\n\nfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n  vec2 e = vec2( 1.0, 0.0 );\n\n  for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    texcoord += vec2( 0.0, 2.0 ) * u_resolutionInv; // WebGL port note: Changed sign\n    if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n  }\n\n  texcoord.y -= 0.25 * u_resolutionInv.y; // WebGL port note: Changed sign\n  texcoord.y -= u_resolutionInv.y; // WebGL port note: Changed sign\n  texcoord.y -= 2.0 * u_resolutionInv.y; // WebGL port note: Changed sign\n  texcoord.y += u_resolutionInv.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n  return texcoord.y;\n}\n\nfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n  vec2 e = vec2( 1.0, 0.0 );\n\n  for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    texcoord -= vec2( 0.0, 2.0 ) * u_resolutionInv; // WebGL port note: Changed sign\n    if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n  }\n\n  texcoord.y += 0.25 * u_resolutionInv.y; // WebGL port note: Changed sign\n  texcoord.y += u_resolutionInv.y; // WebGL port note: Changed sign\n  texcoord.y += 2.0 * u_resolutionInv.y; // WebGL port note: Changed sign\n  texcoord.y -= u_resolutionInv.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n  return texcoord.y;\n}\n\nvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n  // Rounding prevents precision errors of bilinear filtering:\n  vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n  // We do a scale and bias for mapping to texel space:\n  texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n  // Move to proper place, according to the subpixel offset:\n  texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n  return texture2D( areaTex, texcoord, 0.0 ).rg;\n}\n\nvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n  vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n  vec2 e = texture2D( edgesTex, texcoord ).rg;\n\n  if ( e.g > 0.0 ) { // Edge at north\n    vec2 d;\n\n    // Find the distance to the left:\n    vec2 coords;\n    coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n    coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * u_resolutionInv.y (@CROSSING_OFFSET)\n    d.x = coords.x;\n\n    // Now fetch the left crossing edges, two at a time using bilinear\n    // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n    // discern what value each edge has:\n    float e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n    // Find the distance to the right:\n    coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n    d.y = coords.x;\n\n    // We want the distances to be in pixel units (doing this here allow to\n    // better interleave arithmetic and memory accesses):\n    d = d / u_resolutionInv.x - pixcoord.x;\n\n    // SMAAArea below needs a sqrt, as the areas texture is compressed\n    // quadratically:\n    vec2 sqrt_d = sqrt( abs( d ) );\n\n    // Fetch the right crossing edges:\n    coords.y -= 1.0 * u_resolutionInv.y; // WebGL port note: Added\n    float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n    // Ok, we know how this pattern looks like, now it is time for getting\n    // the actual area:\n    weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n  }\n\n  if ( e.r > 0.0 ) { // Edge at west\n    vec2 d;\n\n    // Find the distance to the top:\n    vec2 coords;\n\n    coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n    coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * u_resolutionInv.x;\n    d.x = coords.y;\n\n    // Fetch the top crossing edges:\n    float e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n    // Find the distance to the bottom:\n    coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n    d.y = coords.y;\n\n    // We want the distances to be in pixel units:\n    d = d / u_resolutionInv.y - pixcoord.y;\n\n    // SMAAArea below needs a sqrt, as the areas texture is compressed\n    // quadratically:\n    vec2 sqrt_d = sqrt( abs( d ) );\n\n    // Fetch the bottom crossing edges:\n    coords.y -= 1.0 * u_resolutionInv.y; // WebGL port note: Added\n    float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n    // Get the area for this direction:\n    weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n  }\n\n  return weights;\n}\n\nvoid main() {\n\n  gl_FragColor = SMAABlendingWeightCalculationPS( v_uv, v_pixcoord, v_offsets, u_edgesTexture, u_areaTexture, u_searchTexture, ivec4( 0.0 ) );\n\n}\n"]),
                defines: {
                    SMAA_MAX_SEARCH_STEPS: "8",
                    SMAA_AREATEX_MAX_DISTANCE: "16",
                    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
                    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
                },
                transparent: !0,
                blending: a.NoBlending,
                depthTest: !1,
                depthWrite: !1
            })
        }
        var c = r.prototype,
            u = l.prototype = Object.create(c);
        u.constructor = l, u.setPostprocessing = function(e) {
            c.setPostprocessing.call(this, e);
            var t = e.width,
                n = e.height;
            this.edgesRenderTarget.setSize(t, n), this.weightsRenderTarget.setSize(t, n), this.uResolutionInv.value.set(1 / t, 1 / n)
        }, u.dispose = function() {
            this.edgesRenderTarget && this.edgesRenderTarget.dispose();
            this.weightsRenderTarget && this.weightsRenderTarget.dispose()
        }, u.needsRender = function() {
            return !h.u_areaTexture.value.needsUpdate
        }, u.render = function(e, t) {
            var n = i.getColorState();
            h.u_searchTexture.value || console.warn("You need to use Smaa.setImages() to set the smaa textures manually and assign to this class.");
            var r = i.renderer;
            r.autoClear = !0, r.setClearColor(0, 0), this.edgesMaterial.uniforms.u_texture.value = e.fromTexture, e.renderMaterial(this.edgesMaterial, this.edgesRenderTarget, !0), e.renderMaterial(this.weightsMaterial, this.weightsRenderTarget, !0), i.setColorState(n), this.material.uniforms.u_texture.value = e.fromTexture, c.render.call(this, e, t)
        }, (n = t.exports = l).setTextures = function(e, t) {
            var n = void 0;
            (n = h.u_areaTexture.value = d(e)).format = a.RGBFormat, n.minFilter = a.LinearFilter, (n = h.u_searchTexture.value = d(t)).magFilter = a.NearestFilter, n.minFilter = a.NearestFilter
        }, n.updateTextures = function() {
            h.u_areaTexture.value.needsUpdate = !0, h.u_searchTexture.value.needsUpdate = !0
        };
        var h = {
            u_areaTexture: {
                value: null
            },
            u_searchTexture: {
                value: null
            }
        };

        function d(e) {
            var t = new a.Texture(e);
            return t.generateMipmaps = !1, t.flipY = !1, t
        }
    }, {
        "../../helpers/fboHelper": 74,
        "../PostEffect": 87,
        glslify: 8,
        "mout/object/merge": 31,
        three: 57
    }],
    92: [function(e, t, o) {
        "use strict";
        var a = e("../core/browser"),
            s = e("../core/settings"),
            l = e("../core/properties"),
            c = e("../io/shadertoy"),
            u = e("../ui/prompt/prompt"),
            h = e("../ui/editor/Sketch"),
            r = e("mout/string/trim");
        o.preInit = function(n) {
            window.addEventListener("popstate", b), _(o.currPath);
            for (var e = 0, t = p.length; e < t; e++) {
                var r = p[e] = new p[e];
                f[r.id] = r
            }
            if (p.sort(function(e, t) {
                    return t.aliasTestPirority - e.aliasTestPirority
                }), a.isMobile) {
                var i = C(o.currPath);
                i.isMobileBlock && (u.showMsg(i.mobileBlockMsg, !0), history.replaceState(null, null, "/" + s.QUERY_STRING), _(o.currPath))
            }(function(e) {
                if (!e.dataset.hasLinksParsed) {
                    for (var t = e.getElementsByTagName("a"), n = t.length; n--;) M(t[n]);
                    e.dataset.hasLinksParsed = !0
                }
            })(document.body), 2 === d.length && "view" === d[0] ? c.load(d[1], function(e) {
                if (e.success) {
                    var t = new h({
                        id: e.shaderInfo.id
                    });
                    t.importShader(e.shader, e.shaderInfo), l.viewSketch = l.currentSketch = t, l.isView = !0, n()
                } else u.showMsg(c.ERROR_MESSAGES[e.errorType], !0), L("/"), n()
            }) : n()
        }, o.init = function() {
            v = !0, A()
        }, o.isAnimating = x, o.parseCurrUrl = _, o.parseUrl = w, o.getPageFromPath = C, o.goToUrl = L;
        var n = o.prevPath = [],
            d = o.currPath = [],
            p = o.pageList = [e("../pages/HomePage"), e("../pages/ViewPage"), e("../pages/EditorPage"), e("../pages/AboutPage")],
            f = o.pages = {},
            i = void 0,
            m = void 0,
            v = !1,
            g = !0,
            y = !0;

        function x() {
            return !(g && v)
        }

        function b(e) {
            e.preventDefault(), A()
        }

        function _(e) {
            return w(window.location.href, e)
        }

        function w(e, t) {
            var n = r(e.split("#")[0].replace(a.baseUrl, "").split("?")[0], "/").split("/");
            return t && S(n, t), n
        }

        function S(e, t) {
            for (var n = t.length = 0, r = e.length; n < r; n++) t[n] = e[n]
        }

        function M(e) {
            e.dataset.hasParsed || ("A" === e.tagName && e.href && (0 === e.href.indexOf(a.baseUrl) ? e.addEventListener("click", T) : e.addEventListener("click", E)), e.dataset.hasParsed = !0)
        }

        function T(e) {
            e.preventDefault(), L(this.href)
        }

        function E(e) {
            e.preventDefault(), window.open(this.href, this.target)
        }

        function C(e) {
            for (var t = e.join("/"), n = 0, r = p.length; n < r; n++)
                for (var i = p[n], o = i.aliases, a = 0, s = o.length; a < s; a++) {
                    var l = o[a];
                    if (t.match(l)) return i
                }
            return f.home
        }

        function L(e) {
            e = w(e).join("/") + s.QUERY_STRING, history.pushState(null, null, e || "/"), A()
        }

        function A() {
            if (!x()) {
                var e = _();
                !y && e.join("/") === d.join("/") || (v = g = !1, S(d, n), S(e, d), i = m, m = C(e), y ? (v = !(y = !1), P()) : i ? i.hide(m, d, i, n, R) : R())
            }
        }

        function R() {
            v = !0, P()
        }

        function P() {
            m.show(m, d, i, n, O)
        }

        function O() {
            g = !0, A()
        }
    }, {
        "../core/browser": 65,
        "../core/properties": 67,
        "../core/settings": 68,
        "../io/shadertoy": 80,
        "../pages/AboutPage": 82,
        "../pages/EditorPage": 83,
        "../pages/HomePage": 84,
        "../pages/ViewPage": 86,
        "../ui/editor/Sketch": 96,
        "../ui/prompt/prompt": 118,
        "mout/string/trim": 43
    }],
    93: [function(e, t, n) {
        "use strict";
        var r = e("glslify");

        function i(e) {
            return e.replace(/#define\sGLSLIFY\s./, "")
        }
        t.exports = [{
            id: "ripple",
            title: "Ripple",
            isSpline: !1,
            isEditable: !0,
            shader: i(r(["#define GLSLIFY 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}"])),
            desc: ""
        }, {
            id: "raymarch",
            title: "Raymarch",
            isSpline: !1,
            isEditable: !0,
            shader: i(r(["#define GLSLIFY 1\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}"])),
            desc: ""
        }, {
            id: "domain_warp",
            title: "Domain Warping",
            isSpline: !0,
            isEditable: !1,
            shader: i(r(["#define GLSLIFY 1\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n"])) + i(r(["#define GLSLIFY 1\nfloat fbm( vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*snoise( p ); p = p*2.02;\n    f += 0.2500*snoise( p ); p = p*2.03;\n    f += 0.1250*snoise( p ); p = p*2.01;\n    f += 0.0625*snoise( p );\n    return f/0.9375;\n}\n\nfloat pattern(vec3 p ) {\n    vec3 q = vec3( fbm( p ), fbm( p + vec3(5.2,1.3, 2.0) ), 0.0 );\n    return fbm( p + 4.0*q );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n      float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + pattern(vec3(uv * 0.75, iTime * 0.03 + 0.1 * mouseRatio)) * 0.75;\n    fragColor = vec4(1.0, 1.0, 1.0, noise);\n}"])),
            desc: 'A domain distortion noise technique invented by <a class="button-inline title-text-effect__non-text" href="http://www.iquilezles.org/www/articles/warp/warp.htm" target="_blank">Inigo Quilez</a>'
        }, {
            id: "turbulence",
            title: "Turbulence Noise",
            isSpline: !0,
            isEditable: !0,
            shader: i(r(["#define GLSLIFY 1\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n"])) + i(r(["#define GLSLIFY 1\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    fragColor = vec4(1.0, 1.0, 1.0, noise);\n}"])),
            desc: "A procedural noise technique which is commonly used in landscape creation"
        }, {
            id: "worley3d",
            title: "Worley Noise",
            isSpline: !0,
            isEditable: !1,
            shader: i(r(["#define GLSLIFY 1\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n    return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n    return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n    vec3 Pi = mod(floor(P), 289.0);\n     vec3 Pf = fract(P) - 0.5;\n\n    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n    vec3 p1 = permute(p + Pi.y - 1.0);\n    vec3 p2 = permute(p + Pi.y);\n    vec3 p3 = permute(p + Pi.y + 1.0);\n\n    vec3 p11 = permute(p1 + Pi.z - 1.0);\n    vec3 p12 = permute(p1 + Pi.z);\n    vec3 p13 = permute(p1 + Pi.z + 1.0);\n\n    vec3 p21 = permute(p2 + Pi.z - 1.0);\n    vec3 p22 = permute(p2 + Pi.z);\n    vec3 p23 = permute(p2 + Pi.z + 1.0);\n\n    vec3 p31 = permute(p3 + Pi.z - 1.0);\n    vec3 p32 = permute(p3 + Pi.z);\n    vec3 p33 = permute(p3 + Pi.z + 1.0);\n\n    vec3 ox11 = fract(p11*K) - Ko;\n    vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n    vec3 ox12 = fract(p12*K) - Ko;\n    vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n    vec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n    vec3 ox13 = fract(p13*K) - Ko;\n    vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n    vec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n    vec3 ox21 = fract(p21*K) - Ko;\n    vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n    vec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n    vec3 ox22 = fract(p22*K) - Ko;\n    vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n    vec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n    vec3 ox23 = fract(p23*K) - Ko;\n    vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n    vec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n    vec3 ox31 = fract(p31*K) - Ko;\n    vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n    vec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n    vec3 ox32 = fract(p32*K) - Ko;\n    vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n    vec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n    vec3 ox33 = fract(p33*K) - Ko;\n    vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n    vec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n    vec3 dx11 = Pfx + jitter*ox11;\n    vec3 dy11 = Pfy.x + jitter*oy11;\n    vec3 dz11 = Pfz.x + jitter*oz11;\n\n    vec3 dx12 = Pfx + jitter*ox12;\n    vec3 dy12 = Pfy.x + jitter*oy12;\n    vec3 dz12 = Pfz.y + jitter*oz12;\n\n    vec3 dx13 = Pfx + jitter*ox13;\n    vec3 dy13 = Pfy.x + jitter*oy13;\n    vec3 dz13 = Pfz.z + jitter*oz13;\n\n    vec3 dx21 = Pfx + jitter*ox21;\n    vec3 dy21 = Pfy.y + jitter*oy21;\n    vec3 dz21 = Pfz.x + jitter*oz21;\n\n    vec3 dx22 = Pfx + jitter*ox22;\n    vec3 dy22 = Pfy.y + jitter*oy22;\n    vec3 dz22 = Pfz.y + jitter*oz22;\n\n    vec3 dx23 = Pfx + jitter*ox23;\n    vec3 dy23 = Pfy.y + jitter*oy23;\n    vec3 dz23 = Pfz.z + jitter*oz23;\n\n    vec3 dx31 = Pfx + jitter*ox31;\n    vec3 dy31 = Pfy.z + jitter*oy31;\n    vec3 dz31 = Pfz.x + jitter*oz31;\n\n    vec3 dx32 = Pfx + jitter*ox32;\n    vec3 dy32 = Pfy.z + jitter*oy32;\n    vec3 dz32 = Pfz.y + jitter*oz32;\n\n    vec3 dx33 = Pfx + jitter*ox33;\n    vec3 dy33 = Pfy.z + jitter*oy33;\n    vec3 dz33 = Pfz.z + jitter*oz33;\n\n    vec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n    vec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n    vec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n    vec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n    vec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n    vec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n    vec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n    vec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n    vec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n    vec3 d1a = min(d11, d12);\n    d12 = max(d11, d12);\n    d11 = min(d1a, d13); // Smallest now not in d12 or d13\n    d13 = max(d1a, d13);\n    d12 = min(d12, d13); // 2nd smallest now not in d13\n    vec3 d2a = min(d21, d22);\n    d22 = max(d21, d22);\n    d21 = min(d2a, d23); // Smallest now not in d22 or d23\n    d23 = max(d2a, d23);\n    d22 = min(d22, d23); // 2nd smallest now not in d23\n    vec3 d3a = min(d31, d32);\n    d32 = max(d31, d32);\n    d31 = min(d3a, d33); // Smallest now not in d32 or d33\n    d33 = max(d3a, d33);\n    d32 = min(d32, d33); // 2nd smallest now not in d33\n    vec3 da = min(d11, d21);\n    d21 = max(d11, d21);\n    d11 = min(da, d31); // Smallest now in d11\n    d31 = max(da, d31); // 2nd smallest now not in d31\n    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n    d12 = min(d12, d21); // 2nd smallest now not in d21\n    d12 = min(d12, d22); // nor in d22\n    d12 = min(d12, d31); // nor in d31\n    d12 = min(d12, d32); // nor in d32\n    d11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n    d11.y = min(d11.y,d12.z); // Only two more to go\n    d11.y = min(d11.y,d11.z); // Done! (Phew!)\n    return sqrt(d11.xy); // F1, F2\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n      float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    vec2 noise = worley(vec3(uv * 5.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.25), 1.0, false);\n    fragColor = vec4(1.0, 1.0, 1.0, noise.y - noise.x);\n}"])),
            desc: "A cellular noise function introduced by Steven Worley in 1996"
        }, {
            id: "ridge",
            title: "Ridge Noise",
            isSpline: !0,
            isEditable: !1,
            shader: i(r(["#define GLSLIFY 1\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n"])) + i(r(["#define GLSLIFY 1\nfloat fbm( vec3 p ) {\n\tfloat f = 0.0;\n\tf += 0.5000*snoise( p ); p = p*2.02;\n\tf += 0.2500*snoise( p ); p = p*2.03;\n\tf += 0.1250*snoise( p ); p = p*2.01;\n\tf += 0.0625*snoise( p );\n\treturn f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord / iResolution.xy;\n  \tfloat mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n\tfloat noise = fbm(vec3(uv * 2.2, iTime * 0.18));\n\tnoise = abs(noise) * 2.0;\n\tnoise = 0.5 * (1.0 + mouseRatio) - noise;\n\tnoise = noise * noise;   \n\tfragColor = vec4(1.0, 1.0, 1.0, noise);\n}"])),
            desc: "A ridge shaped noise function by applying an absolute function to a Fractal Brownian Motion"
        }]
    }, {
        glslify: 8
    }],
    94: [function(e, t, n) {
        "use strict";
        e("../core/settings");
        var r = e("../core/properties"),
            i = e("./shaderList");
        n.init = function() {
            for (var e = 0, t = o.length; e < t; e++) {
                var n = o[e];
                (l[n.id] = n).isSpline && a.push(n), n.isEditable && s.push(n)
            }
            r.templateShaderId = a[0].id
        };
        var o = n.infoList = i,
            a = n.splineShaderList = [],
            s = n.editorShaderList = [],
            l = n.infos = {}
    }, {
        "../core/properties": 67,
        "../core/settings": 68,
        "./shaderList": 93
    }],
    95: [function(e, t, n) {
        "use strict";
        var u = e("../../core/browser"),
            h = e("../effects/TitleTextEffect"),
            r = e("../prompt/prompt"),
            i = e("../prompt/promptData"),
            a = e("gsap").gsap;
        n.init = function() {
            d = document.querySelector(".about"), f = document.querySelector(".about__wrapper"), p = document.querySelector(".about__intro"), x = document.querySelectorAll(".question__title"), _ = document.querySelectorAll(".category__question"), b = document.querySelectorAll(".about__category-separator"), M = document.querySelectorAll(".about-prompt-button");
            for (var e = 0, t = M.length; e < t; e++) M[e].addEventListener("click", T);
            for (var n = 0, r = x.length; n < r; n++) x[n].addEventListener("click", E);
            m = new h({
                domElement: document.querySelector(".about__title"),
                useBlur: !u.isMobile
            }), v = new h({
                domElement: document.querySelector(".about__description"),
                useBlur: !u.isMobile
            }), g = document.querySelectorAll(".category__title"), y = document.querySelectorAll(".category__text");
            for (var i = 0, o = g.length; i < o; i++) {
                var a = new h({
                    domElement: g[i],
                    useBlur: !u.isMobile
                });
                w.push(a)
            }
            for (var s = 0, l = y.length; s < l; s++) {
                var c = new h({
                    domElement: y[s],
                    useBlur: !u.isMobile
                });
                S.push(c)
            }
            u.isMobile || f.addEventListener("scroll", C)
        }, n.show = function() {
            d.classList.add("is-visible"), m.show(2, .5), v.show(2, .8);
            for (var e = 0, t = w.length; e < t; e++) w[e].show(1, 1 + .75 * e);
            for (var n = 0, r = S.length; n < r; n++) S[n].show(1, 1.75 + .75 * n);
            s && s.kill();
            a.set(x, {
                opacity: 0
            }), s = a.to(x, {
                opacity: 1,
                stagger: .3,
                delay: 2.25,
                duration: 3.5,
                ease: "Power4.easeOut"
            }), l && l.kill();
            a.set(b, {
                opacity: 0
            }), l = a.to(b, {
                opacity: 1,
                stagger: 1,
                scaleX: 1,
                delay: 1.5,
                duration: 3,
                ease: "Power4.easeOut"
            })
        }, n.hide = function() {
            d.classList.remove("is-visible"), m.hide(1, 0), v.hide(1, 0);
            for (var e = 0, t = w.length; e < t; e++) w[e].hide(1, 0);
            for (var n = 0, r = S.length; n < r; n++) S[n].hide(1, 0);
            s && s.kill();
            s = a.to(x, {
                opacity: 0,
                duration: 1,
                ease: "Power4.easeOut"
            }), l && l.kill();
            l = a.to(b, {
                opacity: 0,
                scaleX: 1,
                duration: 1,
                ease: "Power4.easeOut"
            });
            for (var i = 0, o = _.length; i < o; i++) _[i].classList.remove("is-open")
        };
        var d = void 0,
            p = void 0,
            f = void 0,
            m = void 0,
            v = void 0,
            g = void 0,
            y = void 0,
            x = void 0,
            b = void 0,
            _ = void 0,
            w = [],
            S = [],
            s = void 0,
            l = void 0,
            M = void 0;

        function T() {
            r.showMsg(i[this.dataset.id], !1)
        }

        function E(e) {
            e.target.parentNode.classList.toggle("is-open")
        }

        function C(e) {
            p.style.transform = "translateY(" + f.scrollTop + "px)"
        }
    }, {
        "../../core/browser": 65,
        "../effects/TitleTextEffect": 115,
        "../prompt/prompt": 118,
        "../prompt/promptData": 119,
        gsap: 9
    }],
    96: [function(e, t, n) {
        "use strict";
        var r = e("mout/object/merge"),
            i = e("../../core/properties"),
            o = e("./editorCode"),
            a = e("./editorButtons"),
            s = e("../../shaders/shaders"),
            l = e("../../io/localStorage"),
            c = e("../viewInfos");
        var u = (t.exports = function(e) {
            r(this, {
                id: 0,
                data: {},
                shader: null
            }, e)
        }).prototype;
        u.init = function() {
            if (l.checkForSlot(this.id)) {
                var e = l.loadFromSlot(this.id);
                this.data = e.data, this.shader = e.shader
            } else this.data = {
                title: "My Shader " + this.id,
                description: "Lorem ipsum dolor",
                model: "person"
            }, this.shader = s.editorShaderList[0].shader;
            i.onShaderDataChanged.add(function() {
                l.saveToSlot(this.id, this)
            }.bind(this)), i.onShaderTemplateChanged.add(function() {
                l.saveToSlot(this.id, this)
            }.bind(this)), i.onShaderCompiled.add(function() {
                l.saveToSlot(this.id, this)
            }.bind(this))
        }, u.show = function() {
            i.modelId = this.data.model, i.isEditor && (a.setData(this.data), o.changeCode(this.shader, this.data))
        }, u.importShader = function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
            this.data = o.getDataFromShader(e, t), this.shader = e, c.setData(this.data, this.id), this.show()
        }, u.setData = function(e) {
            this.data = e, this.show()
        }, u.preview = function() {
            i.isPreview = !0, c.setData(this.data, this.id), c.updateTexts()
        }
    }, {
        "../../core/properties": 67,
        "../../io/localStorage": 79,
        "../../shaders/shaders": 94,
        "../viewInfos": 122,
        "./editorButtons": 98,
        "./editorCode": 99,
        "mout/object/merge": 31
    }],
    97: [function(e, t, n) {
        "use strict";
        var o = e("../../core/properties"),
            r = e("../../io/shadertoy"),
            i = e("./editorButtons"),
            a = e("./editorTabs"),
            s = e("./editorCode"),
            l = e("./editorControls"),
            c = e("../../controls/cameraControls"),
            u = e("../prompt/prompt"),
            h = e("../prompt/promptData"),
            d = e("./Sketch");
        n.init = function() {
            f = document.querySelector(".editor"), v = document.querySelector(".editor__intro--minimize"), g = document.querySelectorAll(".button__instructions"), m = document.querySelectorAll(".editor__nav-mode"), i.init(), a.init(), s.init(), l.init(), o.onTabChanged.add(_), v.addEventListener("click", x);
            for (var e = 0, t = g.length; e < t; e++) g[e].addEventListener("click", b);
            for (var n = 0, r = m.length; n < r; n++) {
                m[n].addEventListener("change", S)
            }(y = localStorage.getItem("editorMinimized")) && (y = !y, x())
        }, n.show = function() {
            f.classList.add("is-visible"), l.syncViewQuality(), S()
        }, n.hide = function() {
            f.classList.remove("is-visible")
        }, n.initLocalSketches = function() {
            if (null !== o.forkSlotIndex)
                for (var e = 0, t = a.tabs.length; e < t; e++) e === o.forkSlotIndex && a.setActiveTab(e);
            for (var n = 0, r = a.tabs.length; n < r; n++) {
                var i = p[n];
                i || ((i = new d({
                    id: n
                })).init(), p.push(i)), a.tabs[n].classList.contains("is-active") && (null !== o.forkSlotIndex ? i.importShader(o.currentSketch.shader, o.currentSketch.data) : (o.currentSketch = i).show())
            }
            o.forkSlotIndex = null
        }, n.resize = w, n.update = function(e) {
            l.update()
        };
        var p = [],
            f = (o.currentSketch = null, void 0),
            m = void 0,
            v = void 0,
            g = void 0,
            y = !1;

        function x(e) {
            y = !y, f.classList.toggle("is-minimized", y), v.title = y ? "Show Instruction" : "Hide Instruction", w(o.width, o.height), localStorage.setItem("editorMinimized", y)
        }

        function b() {
            if ("test-shadertoy" === this.dataset.id) {
                u.showInput("Please enter a shadertoy sketch url:", "https://www.shadertoy.com/view/3sySRK", !1, !1);
                u.setOkCallback(function() {
                    var n = u.getInputValue(),
                        e = n.replace("https://www.shadertoy.com/view/", "");
                    e = e.replace("/", ""), r.load(e, function(e) {
                        if (e.success) window.open("https://cineshader.com/view/" + n.split("/view/")[1]);
                        else {
                            var t = r.ERROR_MESSAGES[e.errorType];
                            u.showMsg(t, !0)
                        }
                    })
                })
            } else u.showMsg(h[this.dataset.id], !1)
        }

        function _() {
            var e = document.querySelector(".editor__tab.is-active"),
                t = Array.prototype.indexOf.call(a.tabs, e);
            (o.currentSketch = p[t]).show(), s.clearHistory()
        }

        function w(e, t) {
            s.resize()
        }

        function S() {
            for (var e = 0, t = m.length; e < t; e++) {
                var n = m[e];
                if (n.checked) {
                    c.changeMode(n.value);
                    break
                }
            }
        }
    }, {
        "../../controls/cameraControls": 63,
        "../../core/properties": 67,
        "../../io/shadertoy": 80,
        "../prompt/prompt": 118,
        "../prompt/promptData": 119,
        "./Sketch": 96,
        "./editorButtons": 98,
        "./editorCode": 99,
        "./editorControls": 100,
        "./editorTabs": 114
    }],
    98: [function(e, t, n) {
        "use strict";
        var r = e("../../core/properties"),
            i = e("../../io/shadertoy"),
            o = e("../../shaders/shaders"),
            a = e("../prompt/prompt");
        n.init = function() {
            s = document.querySelector(".group--template select"), l = document.querySelector(".group--template button"), c = document.querySelector(".group--model select"), u = document.querySelector(".group--title input"), h = document.querySelector(".group--description input"), l.addEventListener("click", d), c.addEventListener("change", p), u.addEventListener("input", f), h.addEventListener("input", f);
            for (var e = 0, t = o.editorShaderList.length; e < t; e++) {
                var n = o.editorShaderList[e],
                    r = document.createElement("option");
                r.value = n.id, r.innerHTML = n.title, s.appendChild(r)
            }
            var i = document.createElement("option");
            i.value = "shadertoy", i.innerHTML = "Shadertoy...", s.appendChild(i)
        }, n.getData = function() {
            return {
                title: u.value,
                description: h.value,
                model: c.value
            }
        }, n.setData = function(e) {
            u.value = e.title, h.value = e.description, c.value = e.model
        };
        var s = void 0,
            l = void 0,
            c = void 0,
            u = void 0,
            h = void 0;

        function d(e) {
            if (r.templateShaderId = s.value, r.currentSketch.data.templateId = r.templateShaderId, "shadertoy" === r.templateShaderId) {
                a.showInput("Please enter a shadertoy sketch url:", "https://www.shadertoy.com/view/3sySRK", !1, !1);
                a.setOkCallback(function() {
                    var e = a.getInputValue().replace("https://www.shadertoy.com/view/", "");
                    e = e.replace("/", ""), i.load(e, function(e) {
                        if (e.success) r.currentSketch.importShader(e.shader, e.shaderInfo);
                        else {
                            var t = i.ERROR_MESSAGES[e.errorType];
                            2 === e.errorType && (t += "<br>Try to directly copy and paste the code to the editor."), a.showMsg(t, !0)
                        }
                    })
                })
            } else r.onShaderTemplateChanged.dispatch()
        }

        function p(e) {
            r.modelId = c.value, r.currentSketch.data.model = r.modelId, r.onShaderDataChanged.dispatch()
        }

        function f(e) {
            r.currentSketch.data.title = u.value, r.currentSketch.data.description = h.value, r.onShaderDataChanged.dispatch()
        }
    }, {
        "../../core/properties": 67,
        "../../io/shadertoy": 80,
        "../../shaders/shaders": 94,
        "../prompt/prompt": 118
    }],
    99: [function(e, t, n) {
        "use strict";
        var r, i = e("./editorHelpers/Helpers"),
            o = (r = i) && r.__esModule ? r : {
                default: r
            };
        e("codemirror/addon/search/search"), e("codemirror/addon/search/searchcursor"), e("codemirror/addon/comment/comment"), e("codemirror/mode/clike/clike.js");
        var a = e("../../core/browser"),
            s = e("../../core/properties"),
            l = e("../../visual/screen/screenShader"),
            c = e("./editorButtons"),
            u = e("./editorControls"),
            h = e("../../shaders/shaders"),
            d = e("mout/string/trim"),
            p = e("mout/object/mixIn"),
            f = e("codemirror");
        n.init = function() {
            v = document.getElementById("shader-editor"), g = document.getElementById("shader-editor-cm");
            var e = {
                "Ctrl-/": "toggleComment",
                "Alt-Enter": _,
                "Alt-Down": u.triggerRestart,
                "Alt-Up": u.triggerPause
            };
            a.isMac && p(e, {
                "Cmd-/": "toggleComment",
                "Cmd-Enter": _,
                "Cmd-Down": u.triggerRestart,
                "Cmd-Up": u.triggerPause
            });
            y = f(g, {
                value: "",
                indentUnit: 4,
                theme: "monokai",
                viewportMargin: 10,
                lineNumbers: !0,
                matchBrackets: !0,
                mode: "x-shader/x-fragment",
                autoCloseBrackets: !0,
                extraKeys: e,
                showCursorWhenSelecting: !0,
                indentWithTabs: !1
            }), new o.default({
                editor: y
            }), document.querySelector(".button__compile").addEventListener("click", _), y.addKeyMap({}), c.getData(), s.onShaderCompiled.add(S), s.onShaderDataChanged.add(M), s.onShaderTemplateChanged.add(T), s.onHelperValueChanged.add(E)
        }, n.changeCode = function(e, t) {
            t, y.doc.setValue(e), w(), _()
        }, n.getDataFromShader = function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null,
                n = void 0,
                r = void 0,
                i = e.indexOf(m),
                o = e.indexOf("*/", i) + 2;
            n = -1 !== i && 1 !== o && i < o - 2 ? (r = (r = (r = e.substring(i, o)).replace(m, "")).replace("*/", ""), JSON.parse(r)) : t ? {
                title: t.title,
                description: t.description,
                model: "person"
            } : {
                title: "My shader",
                description: "Lorem ipsum dolor",
                model: "person"
            };
            t && t.username && (n.username = t.username);
            return n
        }, n.clearHistory = function() {
            y.doc.clearHistory()
        }, n.resize = function(e, t) {
            var n = v.getBoundingClientRect();
            v.style.height = Math.max(1, s.rawHeight - n.top - 20) + "px", y.refresh()
        };
        var m = "/** SHADERDATA",
            v = void 0,
            g = void 0,
            y = void 0,
            x = [],
            b = void 0;

        function _() {
            l.changeShader(y.doc.getValue())
        }

        function w() {
            var e = y.doc.getCursor(),
                t = y.getScrollInfo(),
                n = y.doc.getHistory(),
                r = y.doc.getValue();
            return r = function(e, t) {
                var n = 1 < arguments.length && void 0 !== t ? t : null,
                    r = void 0;
                null === n && (n = c.getData());
                var i = e.lastIndexOf("}");
                if (-1 !== i)
                    if (i + 1 === e.length) e += "\n\n";
                    else if (i + 1 < e.length) {
                    var o = e.substring(i + 1, e.length);
                    o && (e = e.replace(o, "\n\n"))
                }
                return r = m + "\n", r += JSON.stringify(n, null, "\t"), e += r += "\n*/"
            }(r = function(e) {
                var t = null,
                    n = e.indexOf(m),
                    r = e.indexOf("*/", n) + 2,
                    i = -1 !== n && 1 !== r && n < r;
                if (i)
                    for (; i;) t = e.substring(n, r), n = (e = e.replace(t, "")).indexOf(m), r = e.indexOf("*/", n) + 2, i = -1 !== n && 1 !== r && n < r;
                return e
            }(r)), y.doc.setValue(r), y.doc.setCursor(e), y.scrollTo(t.left, t.top), y.doc.setHistory(n), s.currentSketch.shader = r
        }

        function S(e, t) {
            if (y.operation(function() {
                    for (var e = 0; e < x.length; e++) y.doc.removeLineWidget(x[e])
                }), e) v.classList.add("success");
            else {
                v.classList.add("error");
                for (var n = t.fragmentShader.log.split(/\r\n|\r|\n/), r = 0, i = n.length; r < i; r++) {
                    var o = d(n[r]);
                    o && o.replace(/\d+:(\d+):\s(.+)/g, function(e, t, n, r, i) {
                        if (5 === arguments.length) {
                            var o = parseInt(t, 10) - l.shaderLineStart,
                                a = document.createElement("div");
                            a.className = "cm-err-msg", a.innerHTML = n, x.push(y.doc.addLineWidget(o, a, {
                                coverGutter: !1,
                                noHScroll: !0
                            }))
                        }
                    })
                }
                y.refresh()
            }
            clearTimeout(b), b = setTimeout(function() {
                v.classList.remove("error", "success")
            }, 500)
        }

        function M() {
            w(), c.getData()
        }

        function T() {
            var e = void 0;
            e = h.infos[s.templateShaderId] ? h.infos[s.templateShaderId].shader : h.infos.empty.shader, c.getData(), y.doc.setValue(e), l.changeShader(e), w()
        }

        function E() {
            _()
        }
    }, {
        "../../core/browser": 65,
        "../../core/properties": 67,
        "../../shaders/shaders": 94,
        "../../visual/screen/screenShader": 131,
        "./editorButtons": 98,
        "./editorControls": 100,
        "./editorHelpers/Helpers": 101,
        codemirror: 5,
        "codemirror/addon/comment/comment": 1,
        "codemirror/addon/search/search": 3,
        "codemirror/addon/search/searchcursor": 4,
        "codemirror/mode/clike/clike.js": 6,
        "mout/object/mixIn": 32,
        "mout/string/trim": 43
    }],
    100: [function(e, t, n) {
        "use strict";
        var r = e("../../router/router"),
            i = e("../../core/settings"),
            o = e("../../core/properties"),
            a = e("../../io/exporter");
        n.init = function() {
            h = document.querySelector(".editor__controls .time"), p = document.querySelector(".editor__controls .fps-value"), s = document.querySelector(".editor__controls .button__restart"), l = document.querySelector(".editor__controls .button__pause"), c = document.querySelector(".editor__controls .button__preview"), u = document.querySelector(".editor__controls .button__screenshot"), s.addEventListener("click", x), l.addEventListener("click", b), c.addEventListener("click", S), u.addEventListener("click", v), d = document.querySelector(".editor__controls-view-quality select");
            var e = localStorage.getItem("editorViewQuality");
            d.value = null != e ? parseInt(e, 10) || 0 : i.DEFAULT_VIEW_QUALITY;
            d.addEventListener("change", y), a.onExportEnded.add(g)
        }, n.update = function(e) {
            20 <= (f += 1) && (p.innerHTML = o.fps.toFixed(1), f = 0);
            h.innerHTML = o.shaderTime.toFixed(1) + "s"
        }, n.triggerRestart = _, n.triggerPause = w, n.syncViewQuality = y;
        var s = void 0,
            l = void 0,
            c = void 0,
            u = void 0,
            h = void 0,
            d = void 0,
            p = void 0,
            f = 0,
            m = !1;

        function v() {
            a.isExporting || a.save(1920, 1080, 64)
        }

        function g(e) {
            ! function(e, t, n) {
                var r = document.createElement("a");
                e.toBlob(function(e) {
                    r.href = URL.createObjectURL(e), r.download = t, r.click(), n && n()
                }, "image/png")
            }(e, "cineshader.png")
        }

        function y() {
            o.viewQuality = d.value, localStorage.setItem("editorViewQuality", o.viewQuality)
        }

        function x() {
            _()
        }

        function b() {
            w()
        }

        function _() {
            o.shaderTime = 0, o.shaderFrame = 0
        }

        function w() {
            m = !m, o.shaderTimeMultiplier = m ? 0 : 1, l.classList.toggle("is-paused", m)
        }

        function S() {
            o.currentSketch.preview(), r.goToUrl("/view/" + (o.currentSketch.id + 1))
        }
    }, {
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../io/exporter": 78,
        "../../router/router": 92
    }],
    101: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function(e, t, n) {
            return t && i(e.prototype, t), n && i(e, n), e
        };

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var s = a(e("./pickers/ColorPicker")),
            l = a(e("./pickers/Vec2Picker")),
            c = a(e("./pickers/FloatPicker")),
            o = a(e("./pickers/types/Color"));
        a(e("./modals/Modal"));

        function a(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }
        var u = e("../../../core/properties");
        RegExp.prototype.execAll = function(e) {
            for (var t = null, n = []; t = this.exec(e);) {
                var r = [];
                for (var i in t) parseInt(i) == i && r.push(t[i]);
                r.index = t.index, n.push(r)
            }
            return n
        };
        var h = (r(d, [{
            key: "getMatch",
            value: function(e) {
                var t = ["color", "vec3", "vec2", "number"],
                    n = void 0;
                for (var r in t)
                    if (n = this.getTypeMatch(e, t[r])) return n
            }
        }, {
            key: "getTypeMatch",
            value: function(e, t) {
                if (t) {
                    var n = void 0;
                    switch (t.toLowerCase()) {
                        case "color":
                            n = /vec[3|4]\([\d|.|,\s]*\)/g;
                            break;
                        case "vec3":
                            n = /vec3\([-|\d|.|,\s]*\)/g;
                            break;
                        case "vec2":
                            n = /vec2\([-|\d|.|,\s]*\)/g;
                            break;
                        case "number":
                            n = /[-]?\d+\.\d+|\d+\.|\.\d+/g;
                            break;
                        default:
                            return void console.error("invalid match selection")
                    }
                    var r = this.main.editor.getLine(e.line),
                        i = n.execAll(r);
                    if (i)
                        for (var o = 0; o < i.length; o++) {
                            var a = i[o][0],
                                s = a.length,
                                l = i[o].index,
                                c = i[o].index + s;
                            if (e.ch >= l && e.ch <= c) return {
                                type: t,
                                start: l,
                                end: c,
                                string: a
                            }
                        }
                }
            }
        }]), d);

        function d(e) {
            var a = this;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, d), this.main = e;
            var t = window.getComputedStyle(e.editor.getWrapperElement(), null),
                n = new o.default("" !== t.background ? t.background : t.backgroundColor),
                r = new o.default(t.color);
            this.properties = {
                bgColor: n.getString("rgb"),
                fnColor: r.getString("rgb"),
                dimColor: "rgb(127, 127, 127)",
                selColor: "rgb(40, 168, 107)",
                linkButton: !1
            };
            var i = this.main.editor.getWrapperElement();
            i.addEventListener("contextmenu", function(e) {
                var t = a.main.editor.getCursor(!0);
                a.main.editor.getTokenAt(t).type
            }), i.addEventListener("mouseup", function(e) {
                if (!a.main.editor.somethingSelected()) {
                    var i = a.main.editor.getCursor(!0),
                        o = a.getMatch(i),
                        t = a.main.editor.getTokenAt(i);
                    if (o) {
                        if (a.activeModal && a.activeModal.isVisible) return a.activeModal.removeModal(), void u.onHelperValueChanged.dispatch();
                        "color" === o.type && (a.activeModal = new s.default(o.string, a.properties), a.activeModal.showAt(a.main.editor), a.activeModal.on("changed", function(e) {
                            var t = e.getString("vec"),
                                n = {
                                    line: i.line,
                                    ch: o.start
                                },
                                r = {
                                    line: i.line,
                                    ch: o.end
                                };
                            o.end = o.start + t.length, a.main.editor.replaceRange(t, n, r, "+" + o.type)
                        })), "vec2" === o.type ? (a.activeModal = new l.default(o.string, a.properties), a.activeModal.showAt(a.main.editor), a.activeModal.on("changed", function(e) {
                            var t = e.getString(),
                                n = {
                                    line: i.line,
                                    ch: o.start
                                },
                                r = {
                                    line: i.line,
                                    ch: o.end
                                };
                            o.end = o.start + t.length, a.main.editor.replaceRange(t, n, r, "+" + o.type)
                        })) : "number" === o.type && (a.activeModal = new c.default(o.string, a.properties), a.activeModal.showAt(a.main.editor), a.activeModal.on("changed", function(e) {
                            var t = e.getString(),
                                n = {
                                    line: i.line,
                                    ch: o.start
                                },
                                r = {
                                    line: i.line,
                                    ch: o.end
                                };
                            o.end = o.start + t.length, a.main.editor.replaceRange(t, n, r, "+" + o.type)
                        }))
                    } else t.type
                }
            })
        }
        n.default = h
    }, {
        "../../../core/properties": 67,
        "./modals/Modal": 102,
        "./pickers/ColorPicker": 103,
        "./pickers/FloatPicker": 104,
        "./pickers/Vec2Picker": 106,
        "./pickers/types/Color": 107
    }],
    102: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function(e, t, n) {
            return t && i(e.prototype, t), n && i(e, n), e
        };

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        n.addEvent = l, n.removeEvent = c;
        var o = e("../tools/mixin");
        var a = (r(s, [{
            key: "close",
            value: function() {
                this.trigger("close")
            }
        }, {
            key: "showAt",
            value: function(e) {
                var t = e.cursorCoords(!0, "page"),
                    n = t.left,
                    r = t.top;
                r += 30, this.presentModal(n, r)
            }
        }, {
            key: "presentModal",
            value: function(e, t) {
                var n = this;
                window.setTimeout(function() {
                    n.onClickOutsideHandler = l(document.body, "click", n.onClickOutside, n), n.onKeyPressHandler = l(window, "keydown", n.onKeyPress, n)
                }, 0), this.isVisible = !0, this.el.style.left = e + "px", this.el.style.top = t + "px", this.el.style.width = this.width + "px", this.el.style.height = this.height + "px", this.position && (this.el.style.position = this.position), document.body.appendChild(this.el), this.trigger("show")
            }
        }, {
            key: "getModalClass",
            value: function() {
                return this.CSS_PREFIX + "modal"
            }
        }, {
            key: "onKeyPress",
            value: function(e) {
                this.removeModal()
            }
        }, {
            key: "onClickOutside",
            value: function(e) {
                if (e.target !== document.body) {
                    var t = e.target;
                    if (t) {
                        for (; t !== document.documentElement && !t.classList.contains(this.getModalClass());) t = t.parentNode;
                        t.classList.contains(this.getModalClass()) || this.removeModal()
                    }
                }
            }
        }, {
            key: "removeModal",
            value: function() {
                this.el && this.el.parentNode && this.el.parentNode.removeChild(this.el), c(document.body, "click", this.onClickOutsideHandler), this.onClickOutsideHandler = null, c(window, "keydown", this.onKeyPressHandler), this.onKeyPressHandler = null, this.close(), this.isVisible = !1
            }
        }]), s);

        function s(e, t) {
            for (var n in function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, s), (0, o.subscribeMixin)(this), this.CSS_PREFIX = e, t = t || {}) this[n] = t[n];
            if (this.el = document.createElement("div"), this.el.className = this.CSS_PREFIX + "_modal ge_modal", this.el.style.backgroundColor = this.bgColor, this.el.innerHTML = this.innerHTML || "", this.elements)
                for (var r = 0; r < this.elements.length; r++) this.el.appendChild(this.elements[r]);
            this.isVisible = !1
        }

        function l(e, t, n, r) {
            var i;
            return e.addEventListener(t, i = function(e) {
                n.call(r, e)
            }, !1), i
        }

        function c(e, t, n) {
            e.removeEventListener(t, n, !1)
        }
        n.default = a
    }, {
        "../tools/mixin": 113
    }],
    103: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function(e, t, n) {
            return t && i(e.prototype, t), n && i(e, n), e
        };

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var c = e("./Picker"),
            o = s(c),
            a = s(e("./types/Color")),
            u = e("../tools/common"),
            f = e("../tools/interactiveDom");

        function s(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }
        var l = e("../../../../core/properties"),
            h = void 0,
            d = 0,
            m = void 0,
            p = (function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
            }(v, o.default), r(v, [{
                key: "init",
                value: function() {
                    var e = this;
                    if (!m) {
                        var t = document.createElement("div"),
                            n = document.createElement("div"),
                            r = document.createElement("div"),
                            i = document.createElement("canvas"),
                            o = document.createElement("div"),
                            a = document.createElement("div"),
                            s = document.createElement("div"),
                            l = document.createElement("div"),
                            c = document.createElement("canvas"),
                            u = document.createElement("div"),
                            h = document.createElement("div"),
                            d = document.createElement("div");
                        t.className = this.CSS_PREFIX + "modal ge_picker_modal", t.style.backgroundColor = this.bgColor, n.className = this.CSS_PREFIX + "patch", n.style.backgroundColor = this.bgColor, r.className = this.CSS_PREFIX + "hsv-map", i.className = this.CSS_PREFIX + "disc", i.style.backgroundColor = this.bgColor, o.className = this.CSS_PREFIX + "disc-cover", a.className = this.CSS_PREFIX + "disc-cursor", s.className = this.CSS_PREFIX + "bar-bg", l.className = this.CSS_PREFIX + "bar-white", c.className = this.CSS_PREFIX + "bar-luminance", u.className = this.CSS_PREFIX + "bar-cursors", h.className = this.CSS_PREFIX + "bar-cursor-left", d.className = this.CSS_PREFIX + "bar-cursor-right", r.id = "cp-map", u.id = "cp-bar", t.appendChild(n), t.appendChild(r), r.appendChild(i), r.appendChild(o), r.appendChild(a), r.appendChild(s), r.appendChild(l), r.appendChild(c), r.appendChild(u), u.appendChild(h), u.appendChild(d), m = t
                    }
                    if (this.el = m.cloneNode(!0), (0, f.subscribeInteractiveDom)(this.el, {
                            move: !0,
                            resize: !1,
                            snap: !1
                        }), this.dom = {}, this.dom.hsvMap = this.el.querySelector(".ge_colorpicker_hsv-map"), this.dom.hsvMapCover = this.dom.hsvMap.children[1], this.dom.hsvMapCursor = this.dom.hsvMap.children[2], this.dom.hsvBarBGLayer = this.dom.hsvMap.children[3], this.dom.hsvBarWhiteLayer = this.dom.hsvMap.children[4], this.dom.hsvBarCursors = this.dom.hsvMap.children[6], this.dom.hsvLeftCursor = this.dom.hsvBarCursors.children[0], this.dom.hsvRightCursor = this.dom.hsvBarCursors.children[1], this.dom.colorDisc = this.el.querySelector(".ge_colorpicker_disc"), this.dom.luminanceBar = this.el.querySelector(".ge_colorpicker_bar-luminance"), this.linkButton) {
                        var p = document.createElement("div");
                        p.innerHTML = "+", p.className = this.CSS_PREFIX + "link-button", p.style.color = this.fgColor, this.el.appendChild(p), p.addEventListener("click", function() {
                            e.trigger("linkButton", e.value), "function" == typeof e.linkButton && e.linkButton(e.value), e.removeModal()
                        })
                    }
                }
            }, {
                key: "draw",
                value: function() {
                    this.el.querySelector(".ge_colorpicker_patch").style.backgroundColor = this.value.getString("rgb");
                    var e = this.value.colors,
                        t = this.dom.colorDisc.offsetHeight / 2,
                        n = 2 * Math.PI,
                        r = Math.cos(n - e.hsv.h * n),
                        i = Math.sin(n - e.hsv.h * n),
                        o = e.hsv.s * (t - 5);
                    this.dom.hsvMapCover.style.opacity = 1 - e.hsv.v / 255, this.dom.hsvBarWhiteLayer.style.opacity = 1 - e.hsv.s, this.dom.hsvBarBGLayer.style.backgroundColor = "rgb(" + e.hueRGB.r + "," + e.hueRGB.g + "," + e.hueRGB.b + ")", this.dom.hsvMapCursor.style.cssText = "left: " + (r * o + t) + "px;top: " + (i * o + t) + "px;border-color: " + (.22 < e.luminance ? "#333;" : "#ddd"), .22 < e.luminance ? this.dom.hsvBarCursors.classList.add("ge_colorpicker_dark") : this.dom.hsvBarCursors.classList.remove("ge_colorpicker_dark"), this.dom.hsvLeftCursor && (this.dom.hsvLeftCursor.style.top = this.dom.hsvRightCursor.style.top = (1 - e.hsv.v / 255) * t * 2 + "px")
                }
            }, {
                key: "presentModal",
                value: function(e, t) {
                    (function e(t, n, r) {
                        null === t && (t = Function.prototype);
                        var i = Object.getOwnPropertyDescriptor(t, n);
                        if (void 0 === i) {
                            var o = Object.getPrototypeOf(t);
                            return null === o ? void 0 : e(o, n, r)
                        }
                        if ("value" in i) return i.value;
                        var a = i.get;
                        return void 0 !== a ? a.call(r) : void 0
                    })(v.prototype.__proto__ || Object.getPrototypeOf(v.prototype), "presentModal", this).call(this, e, t), this.onHsvDownHandler = (0, c.addEvent)(this.dom.hsvMap, "mousedown", this.onHsvDown, this);
                    var n = this.dom.colorDisc;
                    if (n.getContext) {
                        var r = n.getContext("2d"),
                            i = (0, u.getDevicePixelRatio)(r),
                            o = this.disc.width / i,
                            a = this.disc.height / i;
                        this.dom.colorDisc.width = o * i, this.dom.colorDisc.height = a * i, r.scale(i, i), g(r, [o / 2, a / 2], [o / 2 - 1, a / 2 - 1], 360, function(e, t) {
                                var n = e.createRadialGradient(1, 1, 1, 1, 1, 0);
                                n.addColorStop(0, "hsl(" + (360 - t + 0) + ", 100%, 50%)"), n.addColorStop(1, "#fff"), e.fillStyle = n, e.fill()
                            }),
                            function(e, t, n, r, i) {
                                i = i || 1, n = [(n[0] || n) - i / 2, (n[1] || n) - i / 2], g(e, t, n, 1, function(e, t) {
                                    e.restore(), e.lineWidth = i, e.strokeStyle = r || "#000", e.stroke()
                                })
                            }(r, [o / 2, a / 2], [o / 2, a / 2], this.bgColor, 2 / i);
                        var s = this.dom.luminanceBar.getContext("2d");
                        this.dom.luminanceBar.width = this.barlum.width, this.dom.luminanceBar.height = this.barlum.height * i, s.scale(i, i);
                        var l = s.createLinearGradient(0, 0, 0, this.barlum.height / i);
                        l.addColorStop(0, "transparent"), l.addColorStop(1, "black"), s.fillStyle = l, s.fillRect(0, 0, 30, 200)
                    }
                    this.draw()
                }
            }, {
                key: "setValue",
                value: function(e) {
                    this.value = new a.default(e)
                }
            }, {
                key: "onHsvDown",
                value: function(e) {
                    var t = e.target || e.srcElement;
                    e.preventDefault(), h = t.id ? t : t.parentNode, d = h.offsetHeight, this.onHsvMoveHandler = (0, c.addEvent)(this.el, "mousemove", this.onHsvMove, this), this.onHsvUpHandler = (0, c.addEvent)(window, "mouseup", this.onHsvUp, this), this.onHsvMove(e), this.dom.hsvMap.classList.add("ge_colorpicker_no-cursor"), this.renderer.start()
                }
            }, {
                key: "onHsvMove",
                value: function(e) {
                    e.preventDefault(), e.stopPropagation();
                    var t = void 0,
                        n = void 0,
                        r = void 0,
                        i = void 0,
                        o = void 0;
                    if (e.target === this.dom.hsvMapCover && h === this.dom.hsvMap) t = d / 2, n = e.offsetX - t, r = e.offsetY - t, i = (360 - (180 * Math.atan2(r, n) / Math.PI + (r < 0 ? 360 : 0))) / 360, o = Math.sqrt(n * n + r * r) / t, this.value.set({
                        h: i,
                        s: o
                    }, "hsv");
                    else if (e.target === this.dom.hsvBarCursors && h === this.dom.hsvBarCursors) {
                        var a = (d - e.offsetY) / d;
                        a = 255 * Math.max(0, Math.min(1, a)), this.value.set({
                            v: a
                        }, "hsv")
                    }
                    this.trigger("changed", this.value)
                }
            }, {
                key: "onHsvUp",
                value: function(e) {
                    this.renderer.stop(), this.dom.hsvMap.classList.remove("ge_colorpicker_no-cursor"), this.destroyEvents(), l.onHelperValueChanged.dispatch()
                }
            }, {
                key: "destroyEvents",
                value: function() {
                    (0, c.removeEvent)(this.el, "mousemove", this.onHsvMoveHandler), this.onHsvMoveHandler = null, (0, c.removeEvent)(window, "mouseup", this.onHsvUpHandler), this.onHsvUpHandler = null
                }
            }, {
                key: "close",
                value: function() {
                    this.destroyEvents(), (0, c.removeEvent)(this.dom.hsvMap, "mousedown", this.onHsvDownHandler), this.onHsvDownHandler = null
                }
            }]), v);

        function v() {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "vec3(1.0,0.0,0.0)",
                t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, v);
            var n = function(e, t) {
                if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !t || "object" != typeof t && "function" != typeof t ? e : t
            }(this, (v.__proto__ || Object.getPrototypeOf(v)).call(this, "ge_colorpicker_", t));
            return n.width = 250, n.height = 216, n.disc = {
                width: 200,
                height: 200
            }, n.barlum = {
                width: 25,
                height: 200
            }, n.setValue(e), n.init(), n
        }

        function g(e, t, n, r, i) {
            var o = t[0] || t,
                a = t[1] || t,
                s = n[0] || n,
                l = n[1] || n,
                c = 360,
                u = Math.PI / 180;
            for (e.save(), e.translate(o - s, a - l), e.scale(s, l), r = c / r || 360; 0 < c; c -= r) e.beginPath(), 360 !== r && e.moveTo(1, 1), e.arc(1, 1, 1, (c - r / 2 - 1) * u, (c + r / 2 + 1) * u), i ? i(e, c) : (e.fillStyle = "black", e.fill());
            e.restore()
        }
        n.default = p
    }, {
        "../../../../core/properties": 67,
        "../tools/common": 111,
        "../tools/interactiveDom": 112,
        "./Picker": 105,
        "./types/Color": 107
    }],
    104: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function(e, t, n) {
            return t && i(e.prototype, t), n && i(e, n), e
        };

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var o = s(e("./Picker")),
            a = s(e("./types/Float"));

        function s(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }
        var l = (function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }(c, o.default), r(c, [{
            key: "draw",
            value: function() {
                this.ctx.clearRect(0, 0, this.width, this.height), this.ctx.strokeStyle = this.dimColor, this.ctx.lineWidth = 1, this.ctx.beginPath(), this.ctx.moveTo(0, .5 + .5 * this.height), this.ctx.lineTo(0 + this.width, .5 + .5 * this.height), this.ctx.closePath(), this.ctx.stroke(), this.ctx.strokeStyle = this.fnColor, this.ctx.lineWidth = 1, this.ctx.beginPath(), this.ctx.moveTo(.5 * this.width, 0), this.ctx.lineTo(.5 * this.width, this.height), this.ctx.closePath(), this.ctx.stroke(), this.ctx.fillStyle = this.overPoint ? this.selColor : this.fnColor, this.ctx.beginPath(), this.ctx.moveTo(.5 * this.width, 5), this.ctx.lineTo(.48 * this.width, 0), this.ctx.lineTo(.52 * this.width, 0), this.ctx.closePath(), this.ctx.fill();
                var e = this.width / 40,
                    t = this.offsetX;
                Math.abs(this.offsetX - .5 * this.width) > .5 * this.width && (t = (this.offsetX - .5 * this.width) % (.5 * this.width) + this.width), this.ctx.strokeStyle = this.dimColor, this.ctx.beginPath();
                for (var n = 0; n < 120; n++) {
                    var r = n % 20 == 0 ? .35 * this.height : n % 10 == 0 ? .2 * this.height : .1 * this.height;
                    this.ctx.moveTo(n * e - t, .5 * this.height - r), this.ctx.lineTo(n * e - t, .5 * this.height + r)
                }
                this.ctx.stroke();
                var i = Math.round((this.value - this.min) / this.range * this.width);
                this.ctx.strokeStyle = this.overPoint ? this.selColor : this.fnColor, this.ctx.lineWidth = 1, this.ctx.beginPath(), this.ctx.moveTo(this.offsetX + i, .5 * this.height), this.ctx.lineTo(this.offsetX + i, this.height), this.ctx.closePath(), this.ctx.stroke(), this.overPoint = !1
            }
        }, {
            key: "onMouseDown",
            value: function(e) {
                this.prevOffset = e.offsetX,
                    function e(t, n, r) {
                        null === t && (t = Function.prototype);
                        var i = Object.getOwnPropertyDescriptor(t, n);
                        if (void 0 === i) {
                            var o = Object.getPrototypeOf(t);
                            return null === o ? void 0 : e(o, n, r)
                        }
                        if ("value" in i) return i.value;
                        var a = i.get;
                        return void 0 !== a ? a.call(r) : void 0
                    }(c.prototype.__proto__ || Object.getPrototypeOf(c.prototype), "onMouseDown", this).call(this, e)
            }
        }, {
            key: "onMouseMove",
            value: function(e) {
                var t = e.offsetX,
                    n = t - this.prevOffset,
                    r = this.offsetX - n,
                    i = this.width / this.scale;
                this.setValue(r / i), this.prevOffset = t;
                var o = new a.default(this.getValue());
                this.trigger("changed", o), this.overPoint = !0
            }
        }, {
            key: "setValue",
            value: function(e) {
                "string" == typeof e ? this.value = parseFloat(e) : "number" == typeof e && (this.value = e);
                var t = this.width / this.scale;
                this.offsetX = this.value * t
            }
        }]), c);

        function c(e, t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, c);
            var n = function(e, t) {
                if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !t || "object" != typeof t && "function" != typeof t ? e : t
            }(this, (c.__proto__ || Object.getPrototypeOf(c)).call(this, "ge_floatpicker_", t));
            return n.width = n.width || 250, n.height = n.height || 40, n.prevOffset = 0, n.scale = 2, n.setValue(e || 1), n.create(), n
        }
        n.default = l
    }, {
        "./Picker": 105,
        "./types/Float": 109
    }],
    105: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function(e, t, n) {
            return t && i(e.prototype, t), n && i(e, n), e
        };

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        n.addEvent = u, n.removeEvent = h;
        var o = e("../tools/common"),
            a = e("../tools/mixin");
        var s = e("../../../../core/properties"),
            l = (r(c, [{
                key: "create",
                value: function() {
                    this.el = document.createElement("div"), this.el.className = this.CSS_PREFIX + "modal ge_picker_modal", this.el.style.backgroundColor = this.bgColor, this.canvas = document.createElement("canvas"), this.canvas.className = this.CSS_PREFIX + "canvas ge_picker_canvas", this.canvas.style.backgroundColor = this.bgColor, this.el.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d");
                    var e = (0, o.getDevicePixelRatio)(this.ctx);
                    this.canvas.width = this.width * e, this.canvas.height = this.height * e, this.ctx.scale(e, e)
                }
            }, {
                key: "draw",
                value: function() {}
            }, {
                key: "close",
                value: function() {
                    this.destroyEvents(), h(this.el, "mousedown", this.onMouseDownHandler), this.onMouseDownHandler = null
                }
            }, {
                key: "destroyEvents",
                value: function() {
                    h(this.el, "mousemove", this.onMouseMoveHandler), this.onMouseMoveHandler = null, h(window, "mouseup", this.onMouseUpHandler), this.onMouseUpHandler = null
                }
            }, {
                key: "setValue",
                value: function(e) {
                    this.value = e
                }
            }, {
                key: "getValue",
                value: function() {
                    return this.value
                }
            }, {
                key: "showAt",
                value: function(e) {
                    var t = e.cursorCoords(!0, "page"),
                        n = t.left,
                        r = t.top;
                    n -= .5 * this.width, r += 30, this.presentModal(n, r)
                }
            }, {
                key: "presentModal",
                value: function(e, t) {
                    var n = this;
                    window.setTimeout(function() {
                        n.onClickOutsideHandler = u(document.body, "click", n.onClickOutside, n), n.onKeyPressHandler = u(window, "keydown", n.onKeyPress, n)
                    }, 0), this.isVisible = !0, this.el.style.left = e + "px", this.el.style.top = t + "px", this.el.style.width = this.width + "px", this.el.style.height = this.height + "px", document.body.appendChild(this.el), this.onMouseDownHandler = u(this.el, "mousedown", this.onMouseDown, this), this.renderer.drawFrame()
                }
            }, {
                key: "removeModal",
                value: function() {
                    this.el && this.el.parentNode && this.el.parentNode.removeChild(this.el), h(document.body, "click", this.onClickOutsideHandler), this.onClickOutsideHandler = null, h(window, "keydown", this.onKeyPressHandler), this.onKeyPressHandler = null, this.close(), this.isVisible = !1
                }
            }, {
                key: "onKeyPress",
                value: function(e) {
                    this.removeModal()
                }
            }, {
                key: "onClickOutside",
                value: function(e) {
                    if (e.target !== document.body) {
                        for (var t = e.target; t !== document.documentElement && !t.classList.contains(this.CSS_PREFIX + "modal");) t = t.parentNode;
                        t.classList.contains(this.CSS_PREFIX + "modal") || this.removeModal()
                    }
                }
            }, {
                key: "onMouseDown",
                value: function(e) {
                    e.preventDefault(), this.onMouseMoveHandler = u(this.el, "mousemove", this.onMouseMove, this), this.onMouseUpHandler = u(window, "mouseup", this.onMouseUp, this), this.onMouseMove(e), this.renderer.start()
                }
            }, {
                key: "onMouseMove",
                value: function(e) {}
            }, {
                key: "onMouseUp",
                value: function(e) {
                    s.onHelperValueChanged.dispatch(), this.renderer.stop(), this.destroyEvents()
                }
            }]), c);

        function c(e, t) {
            var n = this;
            for (var r in function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, c), (0, a.subscribeMixin)(this), this.CSS_PREFIX = e, this.bgColor = "#051015", this.dimColor = "rgb(100, 100, 100)", this.fnColor = "rgb(230, 230, 230)", this.selColor = "rgb(133, 204, 196)", t = t || {}) this[r] = t[r];
            this.renderer = {
                frame: null,
                drawFrame: function() {
                    n.el && n.draw()
                },
                start: function() {
                    n.renderer.drawFrame(), n.renderer.frame = window.requestAnimationFrame(n.renderer.start)
                },
                stop: function() {
                    window.cancelAnimationFrame(n.renderer.frame)
                }
            }, this.isVisible = !1
        }

        function u(e, t, n, r) {
            var i;
            return e.addEventListener(t, i = function(e) {
                n.call(r, e)
            }, !1), i
        }

        function h(e, t, n) {
            e.removeEventListener(t, n, !1)
        }
        n.default = l
    }, {
        "../../../../core/properties": 67,
        "../tools/common": 111,
        "../tools/mixin": 113
    }],
    106: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function(e, t, n) {
            return t && i(e.prototype, t), n && i(e, n), e
        };

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var o = s(e("./Picker")),
            a = s(e("./types/Vector"));

        function s(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }
        var l = (function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }(c, o.default), r(c, [{
            key: "draw",
            value: function() {
                this.ctx.clearRect(0, 0, this.width, this.height), this.ctx.strokeStyle = this.dimColor, this.ctx.lineWidth = 2, this.ctx.strokeRect(0, 0, this.width, this.height), this.ctx.beginPath(), this.ctx.lineWidth = .25;
                for (var e = this.width / 20, t = 0; t < 20; t++) this.ctx.moveTo(t * e, 0), this.ctx.lineTo(t * e, this.height), this.ctx.moveTo(0, t * e), this.ctx.lineTo(this.width, t * e);
                this.ctx.stroke(), this.ctx.strokeStyle = this.dimColor, this.ctx.lineWidth = 1, this.ctx.beginPath(), this.ctx.moveTo(0, .5 + .5 * this.height), this.ctx.lineTo(this.width, .5 + .5 * this.height), this.ctx.closePath(), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.moveTo(.5 + .5 * this.width, 0), this.ctx.lineTo(.5 + .5 * this.width, this.height), this.ctx.closePath(), this.ctx.stroke();
                var n = Math.round((this.value.x - this.min) / this.range * this.width),
                    r = Math.round((1 - (this.value.y - this.min) / this.range) * this.height),
                    i = this.size / 2;
                n < i && (n = i), n > this.width - i && (n = this.width - i), r < i && (r = i), r > this.height - i && (r = this.height - i), this.ctx.fillStyle = this.overPoint ? this.selColor : this.fnColor, this.ctx.beginPath();
                var o = this.overPoint ? 4 : 2;
                this.ctx.arc(n, r, o, 0, 2 * Math.PI, !1), this.ctx.fill(), this.ctx.restore(), this.overPoint = !1
            }
        }, {
            key: "onMouseMove",
            value: function(e) {
                var t = e.offsetX,
                    n = e.offsetY;
                this.value.x = this.range / this.width * t - (this.range - this.max), this.value.y = -1 * (this.range / this.height * n - (this.range - this.max)), this.trigger("changed", this.value), this.overPoint = !0
            }
        }, {
            key: "setValue",
            value: function(e) {
                this.value = new a.default(e)
            }
        }]), c);

        function c(e, t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, c);
            var n = function(e, t) {
                if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !t || "object" != typeof t && "function" != typeof t ? e : t
            }(this, (c.__proto__ || Object.getPrototypeOf(c)).call(this, "ge_vec2picker_", t));
            n.width = n.width || 200, n.height = n.height || 200, n.min = n.min || -1, n.max = n.max || 1, n.size = n.size || 6, n.range = n.max - n.min, n.overPoint = !1;
            var r = -1 * (n.range / 2 - n.max);
            return n.setValue(e || [r, r]), n.create(), n
        }
        n.default = l
    }, {
        "./Picker": 105,
        "./types/Vector": 110
    }],
    107: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function(e, t, n) {
            return t && i(e.prototype, t), n && i(e, n), e
        };

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var o, h = e("./ColorConverter"),
            d = (o = h) && o.__esModule ? o : {
                default: o
            };
        var a = (r(s, [{
            key: "set",
            value: function(e, t) {
                if ("number" == typeof e) {
                    t = t || "rgb", this.colors[t] = {};
                    for (var n = 3; n--;) {
                        var r = t[n] || t.charAt(n);
                        this.colors[t][r] = e
                    }
                } else if ("string" == typeof e) {
                    var i = e.replace(/(?:#|\)|%)/g, "").split("(");
                    if (i[1]) {
                        var o = (i[1] || "").split(/,\s*/);
                        t = t || (i[1] ? i[0].substr(0, 3) : "rgb"), this.set(o, t)
                    } else this.set((0, h.getColorAsRGB)(e), "rgb")
                } else if (e)
                    if (Array.isArray(e)) {
                        var a = "";
                        t = t || "rgb", this.colors[t] = this.colors[t] || {};
                        for (var s = 3; s--;) {
                            a = t[s] || t.charAt(s);
                            var l = 3 <= e.length ? s : 0;
                            this.colors[t][a] = parseFloat(e[l])
                        }
                        4 === e.length && (this.colors.alpha = parseFloat(e[3]))
                    } else if (t)
                    for (var c in e) this.colors[t][c] = (0, h.limitValue)(e[c] / (0, h.getValueRanges)(t)[c][1], 0, 1) * (0, h.getValueRanges)(t)[c][1];
                if (t) {
                    if ("rgb" !== t) {
                        var u = d.default;
                        this.colors.rgb = u[t + "2rgb"](this.colors[t])
                    }
                    this.convert(t), this.colors.hueRGB = d.default.hue2RGB(this.colors.hsv.h), this.colors.luminance = (0, h.getLuminance)(this.colors.rgb)
                }
            }
        }, {
            key: "convert",
            value: function(e) {
                var t = d.default,
                    n = (0, h.getValueRanges)(),
                    r = {
                        hsl: "hsv",
                        cmyk: "cmy",
                        rgb: e
                    };
                if ("alpha" !== e)
                    for (var i in n)
                        if (!n[i][i] && e !== i && "XYZ" !== i) {
                            var o = r[i] || "rgb";
                            this.colors[i] = t[o + "2" + i](this.colors[o])
                        }
            }
        }, {
            key: "get",
            value: function(e) {
                if ("rgb" === e) return this.colors.rgb;
                var t = d.default;
                return this.colors[e] = t["rgb2" + e](this.colors.rgb), this.colors[e]
            }
        }, {
            key: "getString",
            value: function(e) {
                if ("HEX" === e) return d.default["rgb2" + e](this.colors.rgb);
                var t = this.get(e),
                    n = e,
                    r = "";
                "vec" === e && (n += this.colors.alpha ? 4 : 3), n += "(";
                for (var i = 0; i < 3; i++) r = e[i] || e.charAt(i), n += "vec" === e ? t[r].toFixed(3) : Math.floor(t[r]), 2 !== i && (n += ",");
                return this.colors.alpha && (n += "," + this.colors.alpha.toFixed(3)), n + ")"
            }
        }, {
            key: "uniformType",
            value: function() {
                return this.colors.alpha ? "vec4" : "vec3"
            }
        }, {
            key: "uniformValue",
            value: function() {
                var e = this.get("vec"),
                    t = [e.v, e.e, e.c];
                return this.colors.alpha && t.push(this.colors.alpha), t
            }
        }, {
            key: "uniformMethod",
            value: function(e) {
                return this.colors.alpha ? "4f" : "3f"
            }
        }]), s);

        function s(e) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, s), this.colors = {}, this.set(e)
        }
        n.default = a
    }, {
        "./ColorConverter": 108
    }],
    108: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function(e, t, n) {
            return t && i(e.prototype, t), n && i(e, n), e
        };

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        n.limitValue = d, n.getLuminance = function(e, t) {
            for (var n = t ? 1 : 255, r = [e.r / n, e.g / n, e.b / n], i = r.length; i--;) r[i] = r[i] <= .03928 ? r[i] / 12.92 : Math.pow((r[i] + .055) / 1.055, 2.4);
            return s.r * r[0] + s.g * r[1] + s.b * r[2]
        }, n.getColorAsRGB = function(e) {
            var t = document.createElement("div");
            t.style.backgroundColor = e, document.body.appendChild(t);
            var n = window.getComputedStyle(t).backgroundColor;
            "transparent" === n && (n = "rgb(0, 0, 0)");
            return t.parentNode.removeChild(t), n
        }, n.getValueRanges = function(e) {
            return e ? a[e] : a
        };
        var o, a = {
                rgb: {
                    r: [0, 255],
                    g: [0, 255],
                    b: [0, 255]
                },
                hsv: {
                    h: [0, 1],
                    s: [0, 1],
                    v: [0, 255]
                },
                hsl: {
                    h: [0, 360],
                    s: [0, 100],
                    l: [0, 100]
                },
                cmy: {
                    c: [0, 100],
                    m: [0, 100],
                    y: [0, 100]
                },
                cmyk: {
                    c: [0, 100],
                    m: [0, 100],
                    y: [0, 100],
                    k: [0, 100]
                },
                Lab: {
                    L: [0, 100],
                    a: [-128, 127],
                    b: [-128, 127]
                },
                XYZ: {
                    X: [0, 100],
                    Y: [0, 100],
                    Z: [0, 100]
                },
                vec: {
                    v: [0, 1],
                    e: [0, 1],
                    c: [0, 1]
                },
                alpha: {
                    alpha: [0, 1]
                },
                HEX: {
                    HEX: [0, 16777215]
                }
            },
            l = {
                X: [.4124564, .3575761, .1804375],
                Y: [.2126729, .7151522, .072175],
                Z: [.0193339, .119192, .9503041],
                R: [3.2404542, -1.5371385, -.4985314],
                G: [-.969266, 1.8760108, .041556],
                B: [.0556434, -.2040259, 1.0572252]
            },
            c = {
                X: l.X[0] + l.X[1] + l.X[2],
                Y: l.Y[0] + l.Y[1] + l.Y[2],
                Z: l.Z[0] + l.Z[1] + l.Z[2]
            },
            s = {
                r: .2126,
                g: .7152,
                b: .0722
            },
            u = (r(h, null, [{
                key: "vec2rgb",
                value: function(e) {
                    return {
                        r: e.v * a.rgb.r[1],
                        g: e.e * a.rgb.g[1],
                        b: e.c * a.rgb.b[1]
                    }
                }
            }, {
                key: "rgb2vec",
                value: function(e) {
                    return {
                        v: e.r / a.rgb.r[1],
                        e: e.g / a.rgb.g[1],
                        c: e.b / a.rgb.b[1]
                    }
                }
            }, {
                key: "RGB2HEX",
                value: function(e) {
                    return ((e.r < 16 ? "0" : "") + e.r.toString(16) + (e.g < 16 ? "0" : "") + e.g.toString(16) + (e.b < 16 ? "0" : "") + e.b.toString(16)).toUpperCase()
                }
            }, {
                key: "HEX2rgb",
                value: function(e) {
                    return e = e.split(""), {
                        r: parseInt(e[0] + e[e[3] ? 1 : 0], 16) / 255,
                        g: parseInt(e[e[3] ? 2 : 1] + (e[3] || e[1]), 16) / 255,
                        b: parseInt((e[4] || e[2]) + (e[5] || e[2]), 16) / 255
                    }
                }
            }, {
                key: "hue2RGB",
                value: function(e) {
                    var t = 6 * e,
                        n = Math.floor(t),
                        r = 6 == t ? 0 : t - n;
                    return {
                        r: Math.round(255 * [1, 1 - r, 0, 0, r, 1][n]),
                        g: Math.round(255 * [r, 1, 1, 1 - r, 0, 0][n]),
                        b: Math.round(255 * [0, 0, r, 1, 1, 1 - r][n])
                    }
                }
            }, {
                key: "rgb2hsv",
                value: function(e) {
                    var t, n, r = e.r,
                        i = e.g,
                        o = e.b,
                        a = 0;
                    return i < o && (i = o + (o = i, 0), a = -1), n = o, r < i && (r = i + (i = r, 0), a = -2 / 6 - a, n = Math.min(i, o)), t = r - n, {
                        h: (r ? t / r : 0) < 1e-15 ? 0 : t ? Math.abs(a + (i - o) / (6 * t)) : 0,
                        s: r ? t / r : 0,
                        v: r
                    }
                }
            }, {
                key: "hsv2rgb",
                value: function(e) {
                    var t = 6 * e.h,
                        n = e.s,
                        r = e.v,
                        i = Math.floor(t),
                        o = t - i,
                        a = r * (1 - n),
                        s = r * (1 - o * n),
                        l = r * (1 - (1 - o) * n),
                        c = i % 6;
                    return {
                        r: [r, s, a, a, l, r][c],
                        g: [l, r, r, s, a, a][c],
                        b: [a, a, l, r, r, s][c]
                    }
                }
            }, {
                key: "hsv2hsl",
                value: function(e) {
                    var t = (2 - e.s) * e.v,
                        n = e.s * e.v;
                    return n = e.s ? t < 1 ? t ? n / t : 0 : n / (2 - t) : 0, {
                        h: e.h,
                        s: e.v || n ? n : 0,
                        l: t / 2
                    }
                }
            }, {
                key: "rgb2hsl",
                value: function(e, t) {
                    var n = h.rgb2hsv(e);
                    return h.hsv2hsl(t ? n : o.hsv = n)
                }
            }, {
                key: "hsl2rgb",
                value: function(e) {
                    var t = 6 * e.h,
                        n = e.s,
                        r = e.l,
                        i = r < .5 ? r * (1 + n) : r + n - n * r,
                        o = r + r - i,
                        a = i ? (i - o) / i : 0,
                        s = Math.floor(t),
                        l = i * a * (t - s),
                        c = o + l,
                        u = i - l,
                        h = s % 6;
                    return {
                        r: [i, u, o, o, c, i][h],
                        g: [c, i, i, u, o, o][h],
                        b: [o, o, c, i, i, u][h]
                    }
                }
            }, {
                key: "rgb2cmy",
                value: function(e) {
                    return {
                        c: 1 - e.r,
                        m: 1 - e.g,
                        y: 1 - e.b
                    }
                }
            }, {
                key: "cmy2cmyk",
                value: function(e) {
                    var t = Math.min(Math.min(e.c, e.m), e.y),
                        n = 1 - t || 1e-20;
                    return {
                        c: (e.c - t) / n,
                        m: (e.m - t) / n,
                        y: (e.y - t) / n,
                        k: t
                    }
                }
            }, {
                key: "cmyk2cmy",
                value: function(e) {
                    var t = e.k;
                    return {
                        c: e.c * (1 - t) + t,
                        m: e.m * (1 - t) + t,
                        y: e.y * (1 - t) + t
                    }
                }
            }, {
                key: "cmy2rgb",
                value: function(e) {
                    return {
                        r: 1 - e.c,
                        g: 1 - e.m,
                        b: 1 - e.y
                    }
                }
            }, {
                key: "rgb2cmyk",
                value: function(e) {
                    var t = h.rgb2cmy(e);
                    return h.cmy2cmyk(t)
                }
            }, {
                key: "cmyk2rgb",
                value: function(e) {
                    var t = h.cmyk2cmy(e);
                    return h.cmy2rgb(t)
                }
            }, {
                key: "XYZ2rgb",
                value: function(e) {
                    var t = l,
                        n = e.X,
                        r = e.Y,
                        i = e.Z,
                        o = n * t.R[0] + r * t.R[1] + i * t.R[2],
                        a = n * t.G[0] + r * t.G[1] + i * t.G[2],
                        s = n * t.B[0] + r * t.B[1] + i * t.B[2];
                    return o = (t = .0031308) < o ? 1.055 * Math.pow(o, 1 / 2.4) - .055 : 12.92 * o, a = t < a ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : 12.92 * a, s = t < s ? 1.055 * Math.pow(s, 1 / 2.4) - .055 : 12.92 * s, {
                        r: d(o, 0, 1),
                        g: d(a, 0, 1),
                        b: d(s, 0, 1)
                    }
                }
            }, {
                key: "rgb2XYZ",
                value: function(e) {
                    var t = l,
                        n = e.r,
                        r = e.g,
                        i = e.b;
                    return n = .04045 < n ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92, r = .04045 < r ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92, i = .04045 < i ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92, {
                        X: n * t.X[0] + r * t.X[1] + i * t.X[2],
                        Y: n * t.Y[0] + r * t.Y[1] + i * t.Y[2],
                        Z: n * t.Z[0] + r * t.Z[1] + i * t.Z[2]
                    }
                }
            }, {
                key: "XYZ2Lab",
                value: function(e) {
                    var t = c,
                        n = e.X / t.X,
                        r = e.Y / t.Y,
                        i = e.Z / t.Z,
                        o = 7.787037;
                    return n = .008856 < n ? Math.pow(n, 1 / 3) : o * n + 16 / 116, {
                        L: 116 * (r = .008856 < r ? Math.pow(r, 1 / 3) : o * r + 16 / 116) - 16,
                        a: 500 * (n - r),
                        b: 200 * (r - (i = .008856 < i ? Math.pow(i, 1 / 3) : o * i + 16 / 116))
                    }
                }
            }, {
                key: "Lab2XYZ",
                value: function(e) {
                    var t = c,
                        n = (e.L + 16) / 116,
                        r = e.a / 500 + n,
                        i = n - e.b / 200,
                        o = Math.pow(r, 3),
                        a = Math.pow(n, 3),
                        s = Math.pow(i, 3),
                        l = 7.787037;
                    return {
                        X: (.008856 < o ? o : (r - 16 / 116) / l) * t.X,
                        Y: (.008856 < a ? a : (n - 16 / 116) / l) * t.Y,
                        Z: (.008856 < s ? s : (i - 16 / 116) / l) * t.Z
                    }
                }
            }, {
                key: "rgb2Lab",
                value: function(e) {
                    var t = h.rgb2XYZ(e);
                    return h.XYZ2Lab(t)
                }
            }, {
                key: "Lab2rgb",
                value: function(e) {
                    var t = h.Lab2XYZ(e);
                    return h.XYZ2rgb(t)
                }
            }]), h);

        function h() {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, h)
        }

        function d(e, t, n) {
            return n < e ? n : e < t ? t : e
        }
        n.default = u
    }, {}],
    109: [function(e, t, n) {
        "use strict";

        function r(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = (function(e, t, n) {
            return t && r(e.prototype, t), n && r(e, n), e
        }(o, [{
            key: "getString",
            value: function() {
                return this.value.toFixed(3)
            }
        }, {
            key: "uniformType",
            value: function() {
                return "float"
            }
        }, {
            key: "uniformValue",
            value: function() {
                return [this.value]
            }
        }, {
            key: "uniformMethod",
            value: function() {
                return "1f"
            }
        }]), o);

        function o(e) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, o), this.value = e
        }
        n.default = i
    }, {}],
    110: [function(e, t, n) {
        "use strict";

        function r(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = (function(e, t, n) {
            return t && r(e.prototype, t), n && r(e, n), e
        }(o, [{
            key: "set",
            value: function(e, t) {
                if ("number" == typeof e) t = t || "vec2", this.set([e], t);
                else if ("string" == typeof e) {
                    var n = e.replace(/(?:#|\)|\]|%)/g, "").split("("),
                        r = (n[1] || n[0].replace(/(\[)/g, "")).split(/,\s*/);
                    t = t || (n[1] ? n[0].substr(0, 4) : "vec" + r.length);
                    var i = [];
                    for (var o in r) i.push(parseFloat(r[o]));
                    this.set(i, t)
                } else if (e)
                    if (Array.isArray(e)) {
                        this.value = [], this.value.length = 0, this.dim = t ? Number(t.substr(3, 4)) : e.length;
                        for (var a = 1 === e.length ? e[0] : 0, s = 0; s < this.dim; s++) this.value.push(e[s] || a)
                    } else e.dim && (this.value = e.value, this.dim = e.dim)
            }
        }, {
            key: "getString",
            value: function(e) {
                e = e || "vec" + this.dim;
                var t = this.dim,
                    n = "",
                    r = e + "(",
                    i = ")";
                t = "array" === e ? (r = "[", i = "]", this.dim) : Number(e.substr(3, 4)), n = r;
                for (var o = 0; o < t; o++) n += this.value[o].toFixed(3), o !== t - 1 && (n += ",");
                return n + i
            }
        }, {
            key: "uniformType",
            value: function() {
                return "vec" + this.dim
            }
        }, {
            key: "uniformValue",
            value: function() {
                for (var e = [], t = 0; t < this.dim; t++) e.push(this.value[t]);
                return e
            }
        }, {
            key: "uniformMethod",
            value: function() {
                return this.dim + "f"
            }
        }, {
            key: "add",
            value: function(e) {
                if ("number" == typeof e)
                    for (var t = 0; t < this.dim; t++) this.value[t] = this.value[t] + e;
                else
                    for (var n = new o(e), r = Math.min(this.dim, n.dim), i = 0; i < r; i++) this.value[i] = this.value[i] + n.value[i]
            }
        }, {
            key: "sub",
            value: function(e) {
                if ("number" == typeof e)
                    for (var t = 0; t < this.dim; t++) this.value[t] = this.value[t] - e;
                else
                    for (var n = new o(e), r = Math.min(this.dim, n.dim), i = 0; i < r; i++) this.value[i] = this.value[i] - n.value[i]
            }
        }, {
            key: "mult",
            value: function(e) {
                if ("number" == typeof e)
                    for (var t = 0; t < this.dim; t++) this.value[t] = this.value[t] * e;
                else
                    for (var n = new o(e), r = Math.min(this.dim, n.dim), i = 0; i < r; i++) this.value[i] = this.value[i] * n.value[i]
            }
        }, {
            key: "div",
            value: function(e) {
                if ("number" == typeof e)
                    for (var t = 0; t < this.dim; t++) this.value[t] = this.value[t] / e;
                else
                    for (var n = new o(e), r = Math.min(this.dim, n.dim), i = 0; i < r; i++) this.value[i] = this.value[i] / n.value[i]
            }
        }, {
            key: "normalize",
            value: function() {
                var e = this.getLength();
                this.div(e)
            }
        }, {
            key: "getAdd",
            value: function(e) {
                var t = new o(this);
                return t.add(e), t
            }
        }, {
            key: "getSub",
            value: function(e) {
                var t = new o(this);
                return t.sub(e), t
            }
        }, {
            key: "getMult",
            value: function(e) {
                var t = new o(this);
                return t.mult(e), t
            }
        }, {
            key: "getDiv",
            value: function(e) {
                var t = new o(this);
                return t.div(e), t
            }
        }, {
            key: "getLengthSq",
            value: function() {
                return 2 === this.dim ? this.value[0] * this.value[0] + this.value[1] * this.value[1] : this.value[0] * this.value[0] + this.value[1] * this.value[1] + this.value[2] * this.value[2]
            }
        }, {
            key: "getLength",
            value: function() {
                return Math.sqrt(this.getLengthSq())
            }
        }, {
            key: "x",
            set: function(e) {
                this.value[0] = e
            },
            get: function() {
                return this.value[0] || 0
            }
        }, {
            key: "y",
            set: function(e) {
                this.value[1] = e
            },
            get: function() {
                return this.value[1] || 0
            }
        }, {
            key: "z",
            set: function(e) {
                if (this.dim < 3) {
                    for (; this.dim < 3;) this.value.push(0);
                    this.dim = 3
                }
                this.value[2] = e
            },
            get: function() {
                return this.value[2] || 0
            }
        }, {
            key: "w",
            set: function(e) {
                if (this.dim < 4) {
                    for (; this.dim < 4;) this.value.push(0);
                    this.dim = 4
                }
                this.value[3] = e
            },
            get: function() {
                return this.value[3] || 0
            }
        }]), o);

        function o(e, t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, o), this.value = [0, 0], this.dim = 2, this.set(e, t)
        }
        n.default = i
    }, {}],
    111: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.getDomOrigin = function(e) {
            var t = e.getBoundingClientRect ? e.getBoundingClientRect() : {
                    top: 0,
                    left: 0
                },
                n = e && e.ownerDocument,
                r = n.body,
                i = n.defaultView || n.parentWindow || window,
                o = n.documentElement || r.parentNode,
                a = o.clientTop || r.clientTop || 0,
                s = o.clientLeft || r.clientLeft || 0;
            return {
                left: t.left + (i.pageXOffset || o.scrollLeft) - s,
                top: t.top + (i.pageYOffset || o.scrollTop) - a
            }
        }, n.getDevicePixelRatio = function(e) {
            var t = window.devicePixelRatio || 1,
                n = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1;
            return t / n
        }
    }, {}],
    112: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.subscribeInteractiveDom = function(o, a) {
            (0, T.subscribeMixin)(o), (a = a || {}).resize = void 0 !== a.resize && a.resize, a.move = void 0 !== a.move && a.move, a.snap = void 0 !== a.snap && a.snap;
            var s, l, c, u, h, d, p, f, m, v, g, y = 100,
                x = 100,
                b = null,
                _ = !1,
                w = document.createElement("div");
            w.className = "ghostdom", a.snap && o.parentElement.appendChild(w);

            function S() {
                L(w, f.left, f.top, f.width, f.height), w.style.opacity = 0
            }

            function t(e) {
                n(e);
                var t = a.resize && (s || l || u || c);
                b = {
                    x: m,
                    y: v,
                    cx: e.clientX,
                    cy: e.clientY,
                    w: f.width,
                    h: f.height,
                    isResizing: t,
                    isMoving: !t && M(),
                    onTopEdge: u,
                    onLeftEdge: c,
                    onRightEdge: s,
                    onBottomEdge: l
                }
            }

            function M() {
                return a.move && 0 < m && m < f.width && 0 < v && v < f.height
            }

            function n(e) {
                f = o.getBoundingClientRect(), m = e.clientX - f.left, v = e.clientY - f.top, u = v < C, c = m < C, s = m >= f.width - C, l = v >= f.height - C, h = window.innerWidth - C, d = window.innerHeight - C
            }

            function r(e) {
                n(e), g = e, _ = !0
            }

            function i(e) {
                if (n(e), b && b.isResizing && o.trigger("resize", {
                        finish: !0,
                        el: o
                    }), a.snap && b && b.isMoving) {
                    var t = {
                        width: f.width,
                        height: f.height
                    };
                    p = f.top < E || f.left < E || f.right > window.innerWidth - E || f.bottom > window.innerHeight - E ? (L(o, 0, 0, window.innerWidth, window.innerHeight), t) : f.top < C ? (L(o, 0, 0, window.innerWidth, window.innerHeight / 2), t) : f.left < C ? (L(o, 0, 0, window.innerWidth / 2, window.innerHeight), t) : f.right > h ? (L(o, window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight), t) : f.bottom > d ? (L(o, 0, window.innerHeight / 2, window.innerWidth, window.innerWidth / 2), t) : null, S(), o.trigger("move", {
                        finish: !0,
                        el: o
                    }), o.trigger("resize", {
                        finish: !0,
                        el: o
                    })
                }
                b = null
            }
            return o.addEventListener("mousedown", function(e) {
                    t(e), g.preventDefault()
                }), document.addEventListener("mousemove", r), document.addEventListener("mouseup", i), o.addEventListener("touchstart", function(e) {
                    t(e.touches[0]), g.preventDefault()
                }), document.addEventListener("touchmove", function(e) {
                    e.preventDefault(), e.stopPropagation(), r(e.touches[0])
                }), document.addEventListener("touchend", function(e) {
                    0 === e.touches.length && i(g.changedTouches[0])
                }),
                function e() {
                    requestAnimationFrame(e);
                    if (!_) return;
                    _ = !1;
                    if (b && b.isResizing) {
                        if (b.onRightEdge && (o.style.width = Math.max(m, y) + "px"), b.onBottomEdge && (o.style.height = Math.max(v, x) + "px"), b.onLeftEdge) {
                            var t = Math.max(b.cx - g.clientX + b.w, y);
                            y < t && (o.style.width = t + "px", o.style.removeProperty("right"), o.style.left = g.clientX + "px")
                        }
                        if (b.onTopEdge) {
                            var n = Math.max(b.cy - g.clientY + b.h, x);
                            x < n && (o.style.height = n + "px", o.style.removeProperty("bottom"), o.style.top = g.clientY + "px")
                        }
                        return S(), void o.trigger("resize", {
                            finish: !1,
                            el: o
                        })
                    }
                    if (b && b.isMoving) {
                        if (a.snap) {
                            if (f.top < E || f.left < E || f.right > window.innerWidth - E || f.bottom > window.innerHeight - E ? (L(w, 0, 0, window.innerWidth, window.innerHeight), w.style.opacity = .2) : f.top < C ? (L(w, 0, 0, window.innerWidth, window.innerHeight / 2), w.style.opacity = .2) : f.left < C ? (L(w, 0, 0, window.innerWidth / 2, window.innerHeight), w.style.opacity = .2) : f.right > h ? (L(w, window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight), w.style.opacity = .2) : f.bottom > d ? (L(w, 0, window.innerHeight / 2, window.innerWidth, window.innerWidth / 2), w.style.opacity = .2) : S(), p) return void L(o, g.clientX - p.width / 2, g.clientY - Math.min(b.y, p.height), p.width, p.height);
                            o.style.removeProperty("right"), o.style.removeProperty("bottom"), o.style.top = g.clientY - b.y + "px", o.style.left = g.clientX - b.x + "px"
                        } else {
                            var r = g.clientX - b.x,
                                i = g.clientY - b.y;
                            r < 0 ? r = 0 : i < 0 ? i = 0 : r + o.offsetWidth > window.innerWidth ? r = window.innerWidth - o.offsetWidth : i + o.offsetHeight > window.innerHeight && (i = window.innerHeight - o.offsetHeight), o.style.removeProperty("right"), o.style.removeProperty("bottom"), o.style.left = r + "px", o.style.top = i + "px"
                        }
                        return void o.trigger("move", {
                            finish: !1,
                            el: o
                        })
                    }
                    a.resize && (s && l || c && u) ? o.style.cursor = "nwse-resize" : a.resize && (s && u || l && c) ? o.style.cursor = "nesw-resize" : a.resize && (s || c) ? o.style.cursor = "ew-resize" : a.resize && (l || u) ? o.style.cursor = "ns-resize" : M() ? o.style.cursor = "move" : o.style.cursor = "default"
                }(), o.snapRight = function() {
                    var e = {
                        width: o.width,
                        height: o.height
                    };
                    L(o, window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight), p = e, o.trigger("move", {
                        finish: !0,
                        el: o
                    }), o.trigger("resize", {
                        finish: !0,
                        el: o
                    })
                }, o
        };
        var T = e("./mixin"),
            E = -30,
            C = 10;

        function L(e, t, n, r, i) {
            e.style.left = t + "px", e.style.top = n + "px", e.style.width = r + "px", e.style.height = i + "px"
        }
    }, {
        "./mixin": 113
    }],
    113: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.subscribeMixin = function(e) {
            var f = new Set;
            return Object.assign(e, {
                on: function(e, t) {
                    var n = {};
                    n[e] = t, f.add(n)
                },
                off: function(e, t) {
                    if (t) {
                        var n = {};
                        n[e] = t, f.delete(n)
                    } else {
                        var r = !0,
                            i = !1,
                            o = void 0;
                        try {
                            for (var a, s = f[Symbol.iterator](); !(r = (a = s.next()).done); r = !0) {
                                var l = a.value,
                                    c = !0,
                                    u = !1,
                                    h = void 0;
                                try {
                                    for (var d, p = Object.keys(l)[Symbol.iterator](); !(c = (d = p.next()).done); c = !0) {
                                        if (d.value === e) return void f.delete(l)
                                    }
                                } catch (e) {
                                    u = !0, h = e
                                } finally {
                                    try {
                                        !c && p.return && p.return()
                                    } finally {
                                        if (u) throw h
                                    }
                                }
                            }
                        } catch (e) {
                            i = !0, o = e
                        } finally {
                            try {
                                !r && s.return && s.return()
                            } finally {
                                if (i) throw o
                            }
                        }
                    }
                },
                offAll: function() {
                    f.clear()
                },
                trigger: function(e) {
                    for (var t = arguments.length, n = Array(1 < t ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                    var i = !0,
                        o = !1,
                        a = void 0;
                    try {
                        for (var s, l = f[Symbol.iterator](); !(i = (s = l.next()).done); i = !0) {
                            var c = s.value;
                            "function" == typeof c[e] && c[e].apply(c, n)
                        }
                    } catch (e) {
                        o = !0, a = e
                    } finally {
                        try {
                            !i && l.return && l.return()
                        } finally {
                            if (o) throw a
                        }
                    }
                },
                listSubscriptions: function() {
                    var e = !0,
                        t = !1,
                        n = void 0;
                    try {
                        for (var r, i = f[Symbol.iterator](); !(e = (r = i.next()).done); e = !0) {
                            var o = r.value;
                            console.log(o)
                        }
                    } catch (e) {
                        t = !0, n = e
                    } finally {
                        try {
                            !e && i.return && i.return()
                        } finally {
                            if (t) throw n
                        }
                    }
                }
            })
        }
    }, {}],
    114: [function(e, t, n) {
        "use strict";
        var r = e("../../core/properties");
        n.init = function() {
            i = n.tabs = document.querySelectorAll(".editor__tab"), o = n.currentTab = i[0];
            for (var e = 0, t = i.length; e < t; e++) i[e].addEventListener("click", a)
        }, n.setActiveTab = function(e) {
            o = null;
            for (var t = 0, n = i.length; t < n; t++) t === e ? (i[t].classList.add("is-active"), o = i[t]) : i[t].classList.remove("is-active")
        };
        var i = n.tabs = null,
            o = n.currentTab = null;

        function a(e) {
            o !== e.target && (o.classList.remove("is-active"), (o = e.target).classList.add("is-active"), r.onTabChanged.dispatch())
        }
    }, {
        "../../core/properties": 67
    }],
    115: [function(e, t, n) {
        "use strict";
        var r = e("mout/object/mixIn"),
            i = e("mout/array/shuffle"),
            o = e("../../utils/math"),
            a = e("gsap").gsap;

        function s(e) {
            r(this, {
                text: "",
                domElement: null,
                ratio: 0,
                stagger1s: [],
                stagger2s: [],
                chars: [],
                useBlur: !0
            }, e), this.domElement = this.domElement || document.createElement("div"), this.text = this.text || this.domElement.innerHTML, this.style = this.domElement.style, this.boundOnUpdate = this.onUpdate.bind(this), this.boundOnComplete = this.onComplete.bind(this), this.setText(this.text)
        }
        var l = s.prototype;
        t.exports = s, l.setText = function(e) {
            e = this.text = e || this.text, this.domElement.innerHTML = e, this.chars.length = 0, this.stagger1s.length = 0, this.stagger2s.length = 0;
            for (var t = this.domElement.querySelectorAll(".title-text-effect__non-text"), n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                this.domElement.innerHTML = this.domElement.innerHTML.replace(i.outerHTML, "#" + n + "# ")
            }
            var o = this.domElement.innerHTML.split(/\s+/g);
            this.domElement.innerHTML = "";
            for (var a = 0, s = o.length; a < s; a++) {
                var l = o[a],
                    c = l.match(/#(\d+)#/g),
                    u = void 0;
                if (c) u = t[parseInt(c[0].replace(/#/g, ""), 10)];
                else {
                    u = document.createElement("span");
                    var h = l.substr(0, 1);
                    u.innerHTML = ("'" == h || "." == h ? "" : " ") + l + " "
                }
                this.chars[a] = u, this.domElement.appendChild(u)
            }
            this.onComplete(), this.onUpdate()
        }, l.show = function(e, t) {
            a.killTweensOf(this), a.to(this, e || 0, {
                delay: t || 0,
                ratio: 1,
                onUpdate: this.boundOnUpdate,
                onComplete: this.boundOnComplete
            })
        }, l.hide = function(e, t) {
            a.killTweensOf(this), a.to(this, e || 0, {
                delay: t || 0,
                ratio: 0,
                onUpdate: this.boundOnUpdate,
                onComplete: this.boundOnComplete
            })
        }, l.onUpdate = function() {
            for (var e = this.useBlur, t = 0, n = this.chars.length; t < n; t++) {
                var r = this.chars[t].style,
                    i = o.cUnMix(.4 * this.stagger1s[t], 1 - .4 * this.stagger2s[t], this.ratio);
                r.opacity = i, e && (r.filter = "blur(" + .2 * (1 - i) + "ex)"), r.visibility = i ? "visible" : this.chars.length < 2 ? "visible" : "hidden"
            }
            this.style.visibility = this.ratio ? "visible" : "hidden"
        }, l.onComplete = function() {
            this.stagger1s.length = 0, this.stagger2s.length = 0;
            var e = this.chars,
                t = Math.max(1, e.length - 1),
                n = Array.apply(null, {
                    length: e.length
                }).map(Number.call, Number);
            Array.prototype.push.apply(this.stagger1s, i(n).map(function(e) {
                return e / t
            })), Array.prototype.push.apply(this.stagger2s, i(n).map(function(e) {
                return e / t
            })), this.style.visibility = this.ratio ? "visible" : "hidden"
        }
    }, {
        "../../utils/math": 124,
        gsap: 9,
        "mout/array/shuffle": 12,
        "mout/object/mixIn": 32
    }],
    116: [function(e, t, n) {
        "use strict";
        n.updateMenu = function() {
            for (var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null, t = 0, n = r.length; t < n; t++) r[t].classList.toggle("is-active", e === t)
        }, n.init = function() {
            r = document.querySelectorAll(".menu__link")
        };
        var r = void 0
    }, {}],
    117: [function(e, t, n) {
        "use strict";
        var r = e("../core/settings"),
            i = e("gsap").gsap;
        n.init = function(e) {
            o = e, a = document.getElementById("preloader"), s = document.getElementById("preloader-text")
        }, n.onPreloading = function(e) {
            l && l.kill();
            l = i.to(n, r.skipLoadingAnimation ? 0 : 1, {
                percent: e,
                onUpdate: c,
                onComplete: u
            })
        };
        var o = void(n.percent = 0),
            a = void 0,
            s = void 0,
            l = void 0;

        function c() {
            s.innerHTML = "Now Loading (" + Math.floor(100 * n.percent) + "%)"
        }

        function u() {
            1 == n.percent && (i.to(a, r.skipLoadingAnimation ? 0 : 1, {
                autoAlpha: 0
            }), o())
        }
    }, {
        "../core/settings": 68,
        gsap: 9
    }],
    118: [function(e, t, n) {
        "use strict";
        n.init = function() {
            i = document.getElementById("prompt"), r = document.getElementById("prompt--bg"), o = document.getElementById("prompt--msg"), a = document.getElementById("prompt--input"), s = document.getElementById("prompt--ok-btn"), r.addEventListener("click", c), s.addEventListener("click", u)
        }, n.showMsg = function(e, t) {
            o.innerHTML = e, i.classList.add("is-visible"), i.classList.remove("is-input"), i.classList.toggle("is-error", !!t)
        }, n.showInput = function(e, t, n, r) {
            o.innerHTML = e, a.value = t || "", i.classList.add("is-visible"), i.classList.add("is-input"), i.classList.toggle("is-error", !!n), a.focus(), a.select()
        }, n.hide = c, n.setOkCallback = function(e) {
            l = e
        }, n.getInputValue = function() {
            return a.value
        };
        var i = void 0,
            r = void 0,
            o = void 0,
            a = void 0,
            s = void 0,
            l = null;

        function c() {
            i.classList.remove("is-visible")
        }

        function u() {
            c(), l && (l(), l = null)
        }
    }, {}],
    119: [function(e, t, n) {
        "use strict";
        t.exports = {
            "more-features": '\n\t<div class="prompt__paragraph"><div class="prompt__title">More features</div>\n\tCineShader supports 2.5D for the screen display through the alpha channel of the fragColor. It maps alpha: [0 - 1] to thickness [0m - 2m] with the screen size of 6m x 6m. In case of the future update, you are recommended to use the values through the vec3 uniform <span>iScreenSize</span> [6, 6, 2]<br><br>\n\tWe also added the <span>#define IS_CINESHADER</span> header on our side and you can use it to make your shader compatible with Shadertoy.com if you used any CineShader specific features.\n\t</div>\n\t',
            "save-and-share": '\n\t<div class="prompt__paragraph"><div class="prompt__title">Save and share instruction</div><ul>\n\t<li>sign in your <a href="https://www.shadertoy.com/profile" target="_blank">shadertoy</a> account.</li>\n\t<li>create a new shader and paste your current code in it.</li>\n\t<li>add <span>cineshader</span> in the tag field.</li>\n\t<li>set its privacy to <span>public + api</span> and hit save.</li>\n\t<li>get your shader_id from the page url: https://www.shadertoy.com/view/shadertoy_id</li>\n\t<li>your CineShader url would be : https://cineshader.com/view/shadertoy_id</li>\n\t</ul></div>\n\t',
            "convert-your-shader": '\n\t<div class="prompt__paragraph"><div class="prompt__title">Make your shader CineShader compatible</div><ul>\n\t<li>make sure you didnâ€™t use any texture, audio and framebuffer.</li>\n\t<li>optionally add a bit of thickness to value to the alpha channel of fragColor.</li>\n\t<li>add <span>cineshader</span> in the tag field.</li>\n\t<li>set its privacy to <span>public + api</span> and hit save.</li>\n\t<li>get your shader_id from the page url: https://www.shadertoy.com/view/shadertoy_id</li>\n\t<li>your CineShader url would be : https://cineshader.com/view/shadertoy_id</li>\n\t</ul></div>\n\t',
            "shader-syntax": '<div class="prompt__paragraph"><div class="prompt__title">Shader Syntax</div>\n\t<table>\n\t\t<tr><td>vec3</td><td>iResolution</td><td>The viewport resolution (z is pixel aspect ratio, usually 1.0)</td></tr>\n\t\t<tr><td>float</td><td>iTime</td><td>Current time in seconds</td></tr>\n\t\t<tr><td>float</td><td>iTimeDelta</td><td>Time it takes to render a frame, in seconds</td></tr>\n\t\t<tr><td>int</td><td>iFrame*</td><td>Current frame</td></tr>\n\t\t<tr><td>float</td><td>iFrameRate</td><td>Number of frames rendered per second</td></tr>\n\t\t<tr><td>vec4</td><td>iMouse</td><td>xy = current pixel coords (if LMB is down). zw = click pixel</td></tr>\n\t\t<tr><td>vec4</td><td>iDate</td><td>Year, month, day, time in seconds in .xyzw</td></tr>\n\t\t<tr><td>vec3</td><td>iCamPos**</td><td>relative camera position to the center of the screen</td></tr>\n\t\t<tr><td>vec4</td><td>iCamQuat**</td><td>relative camera rotation to the center of the screen</td></tr>\n\t\t<tr><td>vec3</td><td>iScreenSize**</td><td>screen mesh width, height and maximum thickness</td></tr>\n\t</table>\n\t<p>* Not compatible with browser running with WebGL 1.</p>\n\t<p>** CineShader only uniform. Recommend to use it with <span>#ifdef IS_CINESHADER</span> to make sure your shader is compatible with Shadertoy.com</p>\n\t</div>\n\t'
        }
    }, {}],
    120: [function(e, t, n) {
        "use strict";
        var r = e("../core/browser"),
            i = e("../core/properties"),
            o = e("./effects/TitleTextEffect"),
            a = e("../controls/cameraControls"),
            s = e("../shaders/shaders");
        n.init = function(e) {
            e, l = document.getElementById("shader-context"), c = new o({
                domElement: document.getElementById("shader-title"),
                useBlur: !r.isMobile
            }), u = new o({
                domElement: document.getElementById("shader-desc"),
                useBlur: !r.isMobile
            }), a.modes.splines.onAnimationStarted.add(p), a.modes.splines.onAnimationRestarted.add(f)
        }, n.show = m, n.hide = v;
        var l = void 0,
            c = void 0,
            u = void 0,
            h = void 0,
            d = !1;

        function p(e) {
            if ("splines" === a.pendingId && "splines" === a.currId && !i.isView) {
                var t = s.splineShaderList[e % s.splineShaderList.length];
                m(t.title, t.desc, e % a.modes.splines.splines.length % 2 ? "left" : "right")
            }
        }

        function f(e) {
            if (!i.isView) {
                var t = s.splineShaderList[e % s.splineShaderList.length];
                m(t.title, t.desc, e % a.modes.splines.splines.length % 2 ? "left" : "right")
            }
        }

        function m(e, t, n) {
            d || (l.classList.remove("is-left", "is-right"), l.classList.add("is-" + n), c.setText(e), c.show(2, 1), u.setText(t), u.show(2, 1), h = setTimeout(v, 9e3), d = !0)
        }

        function v() {
            clearTimeout(h), c.hide(1), u.hide(1), d = !1
        }
    }, {
        "../controls/cameraControls": 63,
        "../core/browser": 65,
        "../core/properties": 67,
        "../shaders/shaders": 94,
        "./effects/TitleTextEffect": 115
    }],
    121: [function(e, t, r) {
        "use strict";
        var n = e("three");
        r.init = function() {
            i = document.getElementById("transition-block"), o = document.createElement("canvas"), a = o.getContext("2d"), o.width = o.height = 0, i.appendChild(o), h = v(), d = v(!0), p = new n.Color(16711680)
        }, r.resize = function(e, t) {
            s = o.width = e, l = o.height = t, u = l + 2 * (c = .4 * t)
        }, r.update = function(e) {
            if (console.log(r.ratio), Math.abs(r.ratio) < 1) {
                var t = r.ratio;
                a.fillStyle = p.getStyle(), a.clearRect(0, 0, s, l);
                var n = (u + l) * t;
                a.fillRect(0, n, s, l), r.ratio < 1 && a.drawImage(d, 0, n + l - 1, s, c), 0 < r.ratio && a.drawImage(h, 0, n - c + 1, s, c), i.style.display = "block"
            } else i.style.display = "none"
        }, r.ratio = -1;
        var i = void 0,
            o = void 0,
            a = void 0,
            s = void 0,
            l = void 0,
            c = void 0,
            u = void 0,
            h = void 0,
            d = void 0,
            p = void 0,
            f = 15,
            m = 64;

        function v(e) {
            var t = document.createElement("canvas"),
                n = t.getContext("2d"),
                r = m,
                i = m,
                o = f * Math.PI / 180,
                a = r * Math.tan(o),
                s = Math.cos(o) * (i - a);
            t.width = r, t.height = i;
            var l = n.createLinearGradient(0, a, Math.sin(o) * s, a + s * s / (i - a));
            return l.addColorStop(e ? 0 : 1, "rgba(6,16,21,1)"), l.addColorStop(e ? 1 : 0, "rgba(6,16,21,0)"), n.fillStyle = l, n.fillRect(0, 0, r, i), t
        }
    }, {
        three: 57
    }],
    122: [function(e, t, n) {
        "use strict";
        var r = e("../core/browser"),
            i = e("../core/properties"),
            o = e("./effects/TitleTextEffect"),
            a = e("../controls/cameraControls"),
            s = e("../router/router"),
            l = e("gsap").gsap;
        n.init = function() {
            c = document.querySelector(".view-infos"), d = document.querySelector(".view-infos__subtitle"), p = document.querySelector(".view-infos__author"), u = document.querySelector(".view-infos__title"), f = document.querySelector(".view-infos__description"), v = document.querySelector(".view-infos__link"), g = document.querySelector(".view-infos__select"), y = document.querySelector(".view-infos__fork .select-wrapper"), x = document.querySelector(".view-infos__fork-button"), b = document.querySelector(".view-infos__back"), h = new o({
                domElement: u,
                useBlur: !r.isMobile
            }), m = new o({
                domElement: f,
                useBlur: !r.isMobile
            }), _ && w();
            a.modes.splines.onAnimationRestarted.add(M), x.addEventListener("click", T), b.addEventListener("click", E)
        }, n.show = S, n.hide = function() {
            h.hide(1, 0), m.hide(1, .5), l.to(d, {
                opacity: 0,
                duration: 1,
                delay: .25,
                ease: "Power4.easeOut"
            }), l.to([v, y, x, b], {
                opacity: 0,
                duration: 2,
                stagger: .1,
                delay: .75,
                ease: "Power4.easeOut",
                onComplete: function() {
                    c.classList.remove("is-visible")
                }
            })
        }, n.setData = function(e, t) {
            (_ = e).id = t
        }, n.updateTexts = w;
        var c = void 0,
            u = void 0,
            h = void 0,
            d = void 0,
            p = void 0,
            f = void 0,
            m = void 0,
            v = void 0,
            g = void 0,
            y = void 0,
            x = void 0,
            b = void 0,
            _ = void 0;

        function w() {
            c.classList.toggle("is-preview", i.isPreview), u.innerHTML = _.title, p.innerHTML = _.username, p.setAttribute("href", "https://www.shadertoy.com/user/" + _.username), v.setAttribute("href", "https://www.shadertoy.com/view/" + _.id);
            var r = !1,
                e = _.description.replace(/\[url=?(.+)?\](.+)\[\/url\]/g, function(e, t) {
                    r = !0;
                    var n = t.replace(/(^\w+:|^)\/\//, "");
                    return '<a class="button-inline title-text-effect__non-text" href="' + t + '" target="_blank">' + (n = n.replace("www.", "")) + "</a>"
                });
            r || (e = _.description.replace(/(https?:\/\/[^\s]+)/g, function(e, t) {
                var n = t.replace(/(^\w+:|^)\/\//, "");
                return '<a class="button-inline title-text-effect__non-text" href="' + t + '" target="_blank">' + (n = n.replace("www.", "")) + "</a>"
            })), f.innerHTML = e, h.setText(_.title), m.setText(e)
        }

        function S() {
            c.classList.add("is-visible"), h.show(2, .5), m.show(2, 2.5), l.to(d, {
                opacity: 1,
                duration: 2,
                delay: 1.5,
                ease: "Power4.easeOut"
            }), l.to([v, y, x, b], {
                opacity: 1,
                duration: 2,
                stagger: .1,
                delay: 3.5,
                ease: "Power4.easeOut"
            })
        }

        function M() {
            i.isView && S()
        }

        function T() {
            i.forkSlotIndex = g.value - 1, s.goToUrl("/editor")
        }

        function E() {
            s.goToUrl("/editor"), i.isPreview = !1
        }
    }, {
        "../controls/cameraControls": 63,
        "../core/browser": 65,
        "../core/properties": 67,
        "../router/router": 92,
        "./effects/TitleTextEffect": 115,
        gsap: 9
    }],
    123: [function(e, t, n) {
        "use strict";
        var r = {
            Linear: {
                None: function(e) {
                    return e
                }
            },
            Quad: {
                In: function(e) {
                    return e * e
                },
                Out: function(e) {
                    return e * (2 - e)
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                }
            },
            Cubic: {
                In: function(e) {
                    return e * e * e
                },
                Out: function(e) {
                    return --e * e * e + 1
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                }
            },
            Quart: {
                In: function(e) {
                    return e * e * e * e
                },
                Out: function(e) {
                    return 1 - --e * e * e * e
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                }
            },
            Quint: {
                In: function(e) {
                    return e * e * e * e * e
                },
                Out: function(e) {
                    return --e * e * e * e * e + 1
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                }
            },
            Sine: {
                In: function(e) {
                    return 1 - Math.cos(e * Math.PI / 2)
                },
                Out: function(e) {
                    return Math.sin(e * Math.PI / 2)
                },
                InOut: function(e) {
                    return .5 * (1 - Math.cos(Math.PI * e))
                }
            },
            Expo: {
                In: function(e) {
                    return 0 === e ? 0 : Math.pow(1024, e - 1)
                },
                Out: function(e) {
                    return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                },
                InOut: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                }
            },
            Circ: {
                In: function(e) {
                    return 1 - Math.sqrt(1 - e * e)
                },
                Out: function(e) {
                    return Math.sqrt(1 - --e * e)
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                }
            },
            Elastic: {
                In: function(e) {
                    var t = void 0,
                        n = .1;
                    return 0 === e ? 0 : 1 === e ? 1 : (t = !n || n < 1 ? (n = 1, .1) : .4 * Math.asin(1 / n) / (2 * Math.PI), -n * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4))
                },
                Out: function(e) {
                    var t = void 0,
                        n = .1;
                    return 0 === e ? 0 : 1 === e ? 1 : (t = !n || n < 1 ? (n = 1, .1) : .4 * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * e) * Math.sin(2 * (e - t) * Math.PI / .4) + 1)
                },
                InOut: function(e) {
                    var t = void 0,
                        n = .1;
                    return 0 === e ? 0 : 1 === e ? 1 : (t = !n || n < 1 ? (n = 1, .1) : .4 * Math.asin(1 / n) / (2 * Math.PI), (e *= 2) < 1 ? -.5 * n * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4) : n * Math.pow(2, -10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4) * .5 + 1)
                }
            },
            Back: {
                In: function(e) {
                    return e * e * (2.70158 * e - 1.70158)
                },
                Out: function(e) {
                    return --e * e * (2.70158 * e + 1.70158) + 1
                },
                InOut: function(e) {
                    var t = 2.5949095;
                    return (e *= 2) < 1 ? .5 * e * e * ((1 + t) * e - t) : .5 * ((e -= 2) * e * ((1 + t) * e + t) + 2)
                }
            },
            Bounce: {
                In: function(e) {
                    return 1 - r.Bounce.Out(1 - e)
                },
                Out: function(e) {
                    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                },
                InOut: function(e) {
                    return e < .5 ? .5 * r.Bounce.In(2 * e) : .5 * r.Bounce.Out(2 * e - 1) + .5
                }
            }
        };
        n.basic = r, n.linear = r.Linear;
        var i = void 0,
            o = void 0;
        for (i in r) "Linear" !== i && (o = r[i], n["easeIn" + i] = o.In, n["easeOut" + i] = o.Out, n["easeInOut" + i] = o.InOut)
    }, {}],
    124: [function(e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = n.PI = Math.PI,
            o = (n.PI2 = 2 * r, n.HALF_PI = .5 * r, n.DEG2RAD = r / 180, n.RAD2DEG = 180 / r, n.step = function(e, t) {
                return t < e ? 0 : 1
            }, n.clamp = function(e, t, n) {
                return e < t ? t : n < e ? n : e
            }),
            a = (n.mix = function(e, t, n) {
                return e + (t - e) * n
            }, n.cMix = function(e, t, n) {
                return e + (t - e) * o(n, 0, 1)
            }, n.unMix = function(e, t, n) {
                return (n - e) / (t - e)
            }, n.cUnMix = function(e, t, n) {
                return o((n - e) / (t - e), 0, 1)
            }),
            i = n.map = function(e, t, n, r, i) {
                return r + (i - r) * (e - t) / (n - t)
            },
            s = (n.cMap = function(e, t, n, r, i) {
                return r + (i - r) * o((e - t) / (n - t), 0, 1)
            }, n.fit = function(e, t, n, r, i, o) {
                return e = a(t, n, e), o && (e = o(e)), r + e * (i - r)
            }, n.normalize = function(e, t, n) {
                return i(e, t, n, 0, 1)
            }, n.smoothstep = function(e, t, n) {
                return (n = a(e, t, n)) * n * (3 - 2 * n)
            }, n.fract = function(e) {
                return e - Math.floor(e)
            }),
            l = (n.hash = function(e) {
                return s(43758.5453123 * Math.sin(e))
            }, n.hash2 = function(e, t) {
                return s(43758.5453 * Math.sin(12.9898 * e + 4.1414 * t))
            }, n.sign = function(e) {
                return e ? e < 0 ? -1 : 1 : 0
            }, n.isPowerOfTwo = function(e) {
                return (e & -e) === e
            }),
            c = n.powerTwoCeilingBase = function(e) {
                return Math.ceil(Math.log(e) / Math.log(2))
            },
            u = (n.powerTwoCeiling = function(e) {
                return l(e) ? e : 1 << c(e)
            }, n.powerTwoFloorBase = function(e) {
                return Math.floor(Math.log(e) / Math.log(2))
            });
        n.powerTwoFloor = function(e) {
            return l(e) ? e : 1 << u(e)
        }, n.latLngBearing = function(e, t, n, r) {
            var i = Math.sin(r - t) * Math.cos(n),
                o = Math.cos(e) * Math.sin(n) - Math.sin(e) * Math.cos(n) * Math.cos(r - t);
            return Math.atan2(i, o)
        }, n.distanceTo = function(e, t) {
            return Math.sqrt(e * e + t * t)
        }, n.distanceSqrTo = function(e, t) {
            return e * e + t * t
        }, n.distanceTo3 = function(e, t, n) {
            return Math.sqrt(e * e + t * t + n * n)
        }, n.distanceSqrTo3 = function(e, t, n) {
            return e * e + t * t + n * n
        }, n.latLngDistance = function(e, t, n, r) {
            var i = Math.sin((n - e) / 2),
                o = Math.sin((r - t) / 2),
                a = i * i + Math.cos(e) * Math.cos(n) * o * o;
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        }, n.cubicBezier = function(e, t, n, r, i) {
            var o = 3 * (t - e),
                a = 3 * (n - t) - o,
                s = i * i;
            return (r - e - o - a) * (s * i) + a * s + o * i + e
        }, n.cubicBezierFn = function(n, e, t, r) {
            var i = 3 * (e - n),
                o = 3 * (t - e) - i,
                a = r - n - i - o;
            return function(e) {
                var t = e * e;
                return a * (t * e) + o * t + i * e + n
            }
        }, n.loop = function(e, t) {
            return e < 0 ? (t - Math.abs(e) % t) % t : e % t
        }
    }, {}],
    125: [function(e, t, n) {
        "use strict";
        var r = e("../../core/browser"),
            i = e("../../core/settings"),
            o = e("../../core/properties"),
            a = e("../../effects/glPositionOffset/glPositionOffset"),
            s = e("../../effects/blueNoise/blueNoise"),
            l = e("../screen/screen"),
            c = e("../visual"),
            u = e("mout/object/mixIn"),
            g = e("three"),
            h = e("glslify");
        n.preInit = function() {
            if (n.hasStartedLoad) return;
            n.hasStartedLoad = !0, o.loader[o.hasInitialized ? "load" : "add"](i.MODEL_PATH + "car.buf", {
                type: "xhr",
                responseType: "arraybuffer",
                weight: 312,
                onLoad: w
            }), o.loader[o.hasInitialized ? "load" : "add"](i.MODEL_PATH + "car_glass.buf", {
                type: "xhr",
                responseType: "arraybuffer",
                weight: 79,
                onLoad: S
            }), (b = new g.Texture(o.loader[o.hasInitialized ? "load" : "add"](i.TEXTURE_PATH + "car.jpg", {
                weight: 354,
                onLoad: function() {
                    setTimeout(function() {
                        b.needsUpdate = !0, b.isReady = !0
                    }, 4)
                }
            }).content)).wrapS = b.wrapT = g.RepeatWrapping
        }, n.update = function() {
            y && m && b && b.isReady && (_ || function() {
                if (!(m && y && b && b.isReady)) return;
                (v = new g.MeshStandardMaterial({
                    side: g.DoubleSide
                })).type = "ShaderMaterial", v.uniforms = u({
                    u_infoTexture: {
                        value: b
                    }
                }, g.UniformsUtils.merge([g.ShaderLib.standard.uniforms]), s.sharedUniforms, a.sharedUniforms, l.sharedUniforms), v.vertexShader = h(["#define GLSLIFY 1\n#define STANDARD\n\nattribute vec3 cmr;\nvarying vec2 v_uv;\n\n#include <glPositionOffset>\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec3 v_worldNormal;\nvarying vec3 v_baseColor;\nvarying vec3 v_cmr;\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\nuniform vec3 u_screenPosition;\nuniform sampler2D u_areaLightCookies[1];\n\nvoid main () {\n\tvNormal = normalize( normalMatrix * normal );\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\tvViewPosition = - mvPosition.xyz;\n\n\tvec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\tvec3 delta = (worldPosition - u_screenPosition) / 50.0;\n\tv_baseColor = lodMipmapSampleNearestCubic(u_areaLightCookies[0], clamp(vec2(0.5, 0.5) + delta.xy, vec2(0.0), vec2(1.0)), 3.0 + abs(delta.z / 10.0), u_screenTextureSize, u_screenMipmapTextureSize).rgb;\n\n\tv_cmr = cmr;\n\tv_worldNormal = normal;\n\n\tv_uv = uv;\n\tgl_Position = projectionMatrix * mvPosition;\n\tgl_Position = glPositionOffset(gl_Position);\n}"]), v.fragmentShader = h(["#define GLSLIFY 1\n#define STANDARD\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\n#include <getBlueNoise>\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\n\nuniform sampler2D u_infoTexture;\n\nvarying vec2 v_uv;\nvarying vec3 v_baseColor;\nvarying vec3 v_cmr;\nvarying vec3 v_worldNormal;\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\n// uniform float roughness;\n// uniform float metalness;\nuniform float opacity;\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\n\n#include <common>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main () {\n\tvec3 blueNoise = getStaticBlueNoise(gl_FragCoord.xy);\n\tvec3 infoColor = texture2D(u_infoTexture, v_uv).rgb;\n\tfloat r = texture2D(u_infoTexture, v_uv * 16.0).r * infoColor.r;\n\t// vec3 infoColor = vec3(1.,1.,1.);//texture2D(u_infoTexture, v_uv).rgb;\n\n\tvec4 diffuseColor = vec4(vec3(1.,1.,1.), opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tfloat roughnessFactor = max(r * 0.4 + 0.1, v_cmr.b);\n\tfloat metalnessFactor = v_cmr.g;\n\n\tvec3 normal = normalize(vNormal);\n\tvec3 geometryNormal = normal;\n\n\tfloat fr = 1.0 - dot(vViewPosition, normal);\n\tvec3 rb = hsv2rgb(vec3(fr, 1.0, 1.0)) * smoothstep(0.5, -0.5, fr) * smoothstep(0.5, 0.45, abs(fr - 0.5));\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\tvec3 worldNormal = normalize(v_worldNormal);\n\n\t// modulation\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( max(outgoingLight * infoColor.b * 0.2, (infoColor.bbb + 0.012) * v_baseColor * (1.0 - infoColor.b) * max(0.0, worldNormal.z)), diffuseColor.a );\n\tgl_FragColor.rgb += rb * outgoingLight.rgb * infoColor.b * (1.0 - roughnessFactor) * 0.18;\n\n}"]), p = n.mesh = new g.Mesh(y, v), (x = new g.MeshStandardMaterial({
                    roughness: 0,
                    metalness: 1
                })).type = "ShaderMaterial", x.uniforms = u({}, g.UniformsUtils.merge([g.ShaderLib.standard.uniforms]), s.sharedUniforms, a.sharedUniforms, l.sharedUniforms), x.vertexShader = h(["#define GLSLIFY 1\n#define STANDARD\n\nvarying vec2 v_uv;\n\n#include <glPositionOffset>\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\nuniform vec3 u_screenPosition;\n\nvoid main () {\n\tvNormal = normalize( normalMatrix * normal );\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\tvViewPosition = - mvPosition.xyz;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\tgl_Position = glPositionOffset(gl_Position);\n}"]), x.fragmentShader = h(["#define GLSLIFY 1\n#define STANDARD\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\n#include <getBlueNoise>\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\n\n#include <common>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main () {\n\tvec4 diffuseColor = vec4(diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tfloat roughnessFactor = roughness;\n\tfloat metalnessFactor = metalness;\n\n\tvec3 normal = normalize(vNormal);\n\tvec3 geometryNormal = normal;\n\n\tfloat fr = 1.0 - dot(vViewPosition, normal);\n\tvec3 rb = hsv2rgb(vec3(fr, 1.0, 1.0)) * smoothstep(0.5, -0.5, fr) * smoothstep(0.5, 0.45, abs(fr - 0.5));\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4(outgoingLight * 0.08, 1.0);\n\tgl_FragColor.rgb = max(gl_FragColor.rgb, rb * 0.08);\n}"]), x.blending = g.AdditiveBlending, f = n.glassMesh = new g.Mesh(m, x), r.isMobile && (v.defines.IS_MOBILE = !0, x.defines.IS_MOBILE = !0);
                (d = n.container = new g.Object3D).add(p), d.add(f), c.container.add(d), _ = !0
            }(), d.visible = "car" == o.modelId)
        }, n.hasStartedLoad = !1;
        var d = n.container = null,
            p = n.mesh = null,
            f = n.glassMesh = null,
            y = void 0,
            m = void 0,
            v = void 0,
            x = void 0,
            b = void 0,
            _ = !1;

        function w(e) {
            var t = 0,
                n = void 0;
            y = new g.BufferGeometry;
            var r = {
                    position: Float32Array,
                    cmr: Float32Array,
                    normal: Float32Array,
                    uv: Float32Array,
                    indices: Uint16Array
                },
                i = new Int16Array(e, t, 34725);
            n = new r.position(34725);
            for (var o = 0, a = 0; o < 11575; o++) n[a + 0] = 2.18153548 + (i[a + 0] - -32768) / 65535 * 3.88133121, n[a + 1] = (i[a + 1] - -32768) / 65535 * 1.3176329495 - .0140472995, n[a + 2] = .716742516 + (i[a + 2] - -32768) / 65535 * 4.724901194, a += 3;
            i = n, y.setAttribute("position", new g.BufferAttribute(i, 3)), t += 69450;
            var s = new Uint16Array(e, t, 34725);
            n = new r.cmr(34725);
            for (var l = 0, c = 0; l < 11575; l++) n[c + 0] = 0 + (s[c + 0] - 0) / 65535 * 1, n[c + 1] = 0 + (s[c + 1] - 0) / 65535 * 1, n[c + 2] = 0 + (s[c + 2] - 0) / 65535 * 1, c += 3;
            s = n, y.setAttribute("cmr", new g.BufferAttribute(s, 3)), t += 69450;
            var u = new Int16Array(e, t, 34725);
            n = new r.normal(34725);
            for (var h = 0, d = 0; h < 11575; h++) n[d + 0] = (u[d + 0] - -32768) / 65535 * 1.999705136 - .999835968, n[d + 1] = (u[d + 1] - -32768) / 65535 * 2 - 1, n[d + 2] = (u[d + 2] - -32768) / 65535 * 1.999669433 - .999833882, d += 3;
            u = n, y.setAttribute("normal", new g.BufferAttribute(u, 3)), t += 69450;
            var p = new Int16Array(e, t, 23150);
            n = new r.uv(23150);
            for (var f = 0, m = 0; f < 11575; f++) n[m + 0] = .000487804879 + (p[m + 0] - -32768) / 65535 * .998365819121, n[m + 1] = .000487804879 + (p[m + 1] - -32768) / 65535 * .991801559121, m += 2;
            p = n, y.setAttribute("uv", new g.BufferAttribute(p, 2)), t += 46300;
            var v = new Uint16Array(e, t, 31932);
            y.setIndex(new g.BufferAttribute(v, 1)), t += 63864
        }

        function S(e) {
            var t = 0,
                n = void 0;
            m = new g.BufferGeometry;
            var r = {
                    position: Float32Array,
                    normal: Float32Array,
                    indices: Uint16Array
                },
                i = new Int16Array(e, t, 10878);
            n = new r.position(10878);
            for (var o = 0, a = 0; o < 3626; o++) n[a + 0] = 2.21964455 + (i[a + 0] - -32768) / 65535 * 3.7770957899999997, n[a + 1] = .255723923 + (i[a + 1] - -32768) / 65535 * 1.0035072870000001, n[a + 2] = .751607656 + (i[a + 2] - -32768) / 65535 * 4.587246184, a += 3;
            i = n, m.setAttribute("position", new g.BufferAttribute(i, 3)), t += 21756;
            var s = new Int16Array(e, t, 10878);
            n = new r.normal(10878);
            for (var l = 0, c = 0; l < 3626; l++) n[c + 0] = (s[c + 0] - -32768) / 65535 * 1.985083818 - .994035959, n[c + 1] = (s[c + 1] - -32768) / 65535 * 1.559716463 - .559716463, n[c + 2] = (s[c + 2] - -32768) / 65535 * 1.797521949 - .953010023, c += 3;
            s = n, m.setAttribute("normal", new g.BufferAttribute(s, 3)), t += 21756;
            var u = new Uint16Array(e, t, 18240);
            m.setIndex(new g.BufferAttribute(u, 1)), t += 36480
        }
    }, {
        "../../core/browser": 65,
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../effects/blueNoise/blueNoise": 70,
        "../../effects/glPositionOffset/glPositionOffset": 72,
        "../screen/screen": 128,
        "../visual": 133,
        glslify: 8,
        "mout/object/mixIn": 32,
        three: 57
    }],
    126: [function(e, t, n) {
        "use strict";
        var r = e("../../core/browser"),
            i = e("../../core/settings"),
            l = e("../../core/properties"),
            o = e("../../helpers/fboHelper"),
            a = e("../../effects/glPositionOffset/glPositionOffset"),
            s = e("../../effects/blueNoise/blueNoise"),
            c = e("../../effects/mipmapper/Mipmapper"),
            u = e("mout/object/mixIn"),
            h = e("three"),
            d = e("glslify");
        n.preInit = function() {
            (f = new h.Texture(l.loader.add(i.TEXTURE_PATH + "floor.jpg", {
                weight: 519
            }).content)).needsUpdate = !0, f.wrapS = f.wrapT = h.RepeatWrapping
        }, n.init = function() {
            m = new c, v = new h.Vector2, (g = o.createRenderTarget(1, 1)).depthBuffer = !0, y = new h.Matrix4, x = 0, b = new h.PerspectiveCamera, _ = new h.Plane, w = new h.Vector3, S = new h.Vector3, M = new h.Vector3, T = new h.Matrix4, E = new h.Vector3, C = new h.Vector4, L = new h.Vector3, A = new h.Vector3, R = new h.Vector3, P = new h.Vector4, p = n.mesh = new h.Mesh(new h.PlaneBufferGeometry(30, 30), new h.ShaderMaterial({
                uniforms: u({
                    u_infoTexture: {
                        value: f
                    },
                    u_textureMatrix: {
                        value: y
                    },
                    u_textureSize: {
                        value: v
                    },
                    u_mipmapTextureSize: {
                        value: m.textureSize
                    },
                    u_mipmapTexture: {
                        value: g.texture
                    },
                    u_noiseTime: {
                        value: 0
                    }
                }, s.sharedUniforms, a.sharedUniforms),
                vertexShader: d(["#define GLSLIFY 1\nuniform mat4 u_textureMatrix;\n\nvarying vec2 v_uv;\nvarying vec4 v_reflectionTextureUv;\n\n#include <glPositionOffset>\n\nvoid main () {\n\tv_uv = uv;\n\tv_reflectionTextureUv = u_textureMatrix * vec4( position, 1.0 );\n\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n\t// gl_Position = glPositionOffset(gl_Position);\n}"]),
                fragmentShader: d(["#define GLSLIFY 1\nuniform sampler2D u_infoTexture;\n\nuniform sampler2D u_mipmapTexture;\nuniform vec2 u_textureSize;\nuniform vec2 u_mipmapTextureSize;\nuniform float u_noiseTime;\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\n#include <getBlueNoise>\n\nvarying vec4 v_reflectionTextureUv;\nvarying vec2 v_uv;\n\nvec2 mirrored(vec2 v) {\n    vec2 m = mod(v, 2.0);\n    return mix(m, 2.0 - m, step(1.0, m));\n}\n\nvoid main () {\n\tvec3 blueNoise = getBlueNoise(gl_FragCoord.xy);\n\t\n\tvec2 reflectionUv = v_reflectionTextureUv.xy / v_reflectionTextureUv.w + blueNoise.xy / u_mipmapTextureSize;\n    vec3 color = lodMipmapSampleNearest(u_mipmapTexture, reflectionUv, 0.0, u_textureSize, u_mipmapTextureSize).rgb;\n\t// vec3 info = texture2D(u_infoTexture, v_uv * 6.0).rgb;\n\tvec3 info;\n\tvec3 blury;\n\t#ifdef IS_MOBILE\n\tinfo = textureSmoothstep(u_infoTexture, v_uv * 6.0, vec2(1024.0)).rgb;\n    blury = lodMipmapSampleSmoothstep(u_mipmapTexture, reflectionUv + info.br / 128.0, info.r * info.g * 15.0, u_textureSize, u_mipmapTextureSize).rgb;\n\tcolor = mix(color, blury, clamp((info.g - 0.25) * 5.0, 0.0, 1.0));\n\t\n\tinfo = textureBicubic(u_infoTexture, v_uv * 2.0 + 0.421, vec2(1024.0)).rgb;\n    blury = lodMipmapSampleSmoothstep(u_mipmapTexture, reflectionUv, info.r * 6.0, u_textureSize, u_mipmapTextureSize).rgb;\n\tcolor = mix(color, blury, clamp((info.b + blueNoise.z * 0.05 - 0.3) *  7.0, 0.0, 1.0));\n\t#else\n\tinfo = textureBicubic(u_infoTexture, v_uv * 6.0, vec2(1024.0)).rgb;\n    blury = lodMipmapSampleCubic(u_mipmapTexture, reflectionUv + info.br / 128.0, info.r * info.g * 15.0, u_textureSize, u_mipmapTextureSize).rgb;\n\tcolor = mix(color, blury, clamp((info.g - 0.25) * 5.0, 0.0, 1.0));\n\t\n\tinfo = textureBicubic(u_infoTexture, v_uv * 2.0 + 0.421, vec2(1024.0)).rgb;\n    blury = lodMipmapSampleCubic(u_mipmapTexture, reflectionUv, info.r * 6.0, u_textureSize, u_mipmapTextureSize).rgb;\n\tcolor = mix(color, blury, clamp((info.b + blueNoise.z * 0.05 - 0.3) *  7.0, 0.0, 1.0));\n\t#endif\n\n\tcolor *= mix(0.6, 0.75, info.g);\n\n\tgl_FragColor = vec4(color + blueNoise.rgb / 128.0, 1.0);\n}"])
            })), r.isMobile && (p.material.defines.IS_MOBILE = !0);
            p.rotation.x = -.5 * Math.PI, p.position.set(10, 0, 10), p.onBeforeRender = O
        }, n.resize = function(e, t) {
            if (!v) return;
            var n = r.isMobile ? .5 : 1;
            e *= n, t *= n, v.set(e, t), g.setSize(1.5 * v.x, v.y), m.resize(v.x, v.y, g.width, g.height)
        };
        var p = n.mesh = null,
            f = void 0,
            m = void 0,
            v = void 0,
            g = void 0,
            y = void 0,
            x = void 0,
            b = void 0,
            _ = void 0,
            w = void 0,
            S = void 0,
            M = void 0,
            T = void 0,
            E = void 0,
            C = void 0,
            L = void 0,
            A = void 0,
            R = void 0,
            P = void 0;

        function O(e, t, n) {
            if (v && (S.setFromMatrixPosition(p.matrixWorld), M.setFromMatrixPosition(n.matrixWorld), T.extractRotation(p.matrixWorld), w.set(0, 0, 1), w.applyMatrix4(T), A.subVectors(S, M), !(0 < A.dot(w)))) {
                A.reflect(w).negate(), A.add(S), T.extractRotation(n.matrixWorld), E.set(0, 0, -1), E.applyMatrix4(T), E.add(M), R.subVectors(S, E), R.reflect(w).negate(), R.add(S), b.position.copy(A), b.up.set(0, 1, 0), b.up.applyMatrix4(T), b.up.reflect(w), b.lookAt(R), b.near = n.near, b.far = n.far, b.updateMatrixWorld(), b.projectionMatrix.copy(n.projectionMatrix), y.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), y.multiply(b.projectionMatrix), y.multiply(b.matrixWorldInverse), y.multiply(p.matrixWorld), _.setFromNormalAndCoplanarPoint(w, S), _.applyMatrix4(b.matrixWorldInverse), C.set(_.normal.x, _.normal.y, _.normal.z, _.constant);
                var r = b.projectionMatrix;
                P.x = (Math.sign(C.x) + r.elements[8]) / r.elements[0], P.y = (Math.sign(C.y) + r.elements[9]) / r.elements[5], P.z = -1, P.w = (1 + r.elements[10]) / r.elements[14], C.multiplyScalar(2 / C.dot(P)), r.elements[2] = C.x, r.elements[6] = C.y, r.elements[10] = C.z + 1 - x, r.elements[14] = C.w, L.setFromMatrixPosition(n.matrixWorld), e.xr.enabled = !1, p.visible = !1;
                var i = e.getRenderTarget(),
                    o = e.xr.enabled,
                    a = e.shadowMap.autoUpdate;
                e.xr.enabled = !1, e.shadowMap.autoUpdate = !1, e.setRenderTarget(g), e.setViewport(0, 0, v.x, v.y), e.setScissor(0, 0, v.x, v.y), e.setScissorTest(!0), e.render(t, b), e.setRenderTarget(null), e.setViewport(0, 0, l.width, l.height), e.setScissor(0, 0, l.width, l.height), m.render(g), e.xr.enabled = o, e.shadowMap.autoUpdate = a, e.setRenderTarget(i);
                var s = n.viewport;
                void 0 !== s && e.state.viewport(s), p.visible = !0, p.material.uniforms.u_noiseTime.value += .01
            }
        }
    }, {
        "../../core/browser": 65,
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../effects/blueNoise/blueNoise": 70,
        "../../effects/glPositionOffset/glPositionOffset": 72,
        "../../effects/mipmapper/Mipmapper": 73,
        "../../helpers/fboHelper": 74,
        glslify: 8,
        "mout/object/mixIn": 32,
        three: 57
    }],
    127: [function(e, t, n) {
        "use strict";
        var r = e("../../core/browser"),
            i = e("../../core/settings"),
            o = e("../../core/properties"),
            a = e("../../effects/glPositionOffset/glPositionOffset"),
            s = e("../../effects/blueNoise/blueNoise"),
            l = e("../screen/screen"),
            c = e("../visual"),
            u = e("mout/object/mixIn"),
            f = e("three"),
            h = e("glslify");
        n.preInit = function() {
            if (n.hasStartedLoad) return;
            n.hasStartedLoad = !0, o.loader[o.hasInitialized ? "load" : "add"](i.MODEL_PATH + "person.buf", {
                type: "xhr",
                responseType: "arraybuffer",
                weight: 33,
                onLoad: y
            }), (v = new f.Texture(o.loader[o.hasInitialized ? "load" : "add"](i.TEXTURE_PATH + "person.jpg", {
                weight: 246,
                onLoad: function() {
                    setTimeout(function() {
                        v.needsUpdate = !0, v.isReady = !0
                    }, 4)
                }
            }).content)).generateMipmaps = !1, v.magFilter = v.minFilter = f.LinearFilter
        }, n.update = function() {
            m && v && v.isReady && (g || function() {
                if (!m || !v || !v.isReady) return;
                (p = new f.MeshStandardMaterial({
                    roughness: .1,
                    metalness: .025
                })).type = "ShaderMaterial", p.uniforms = u({
                    u_infoTexture: {
                        value: v
                    }
                }, f.UniformsUtils.merge([f.ShaderLib.standard.uniforms]), s.sharedUniforms, a.sharedUniforms, l.sharedUniforms), p.vertexShader = h(["#define GLSLIFY 1\n#define STANDARD\n\nvarying vec2 v_uv;\n\n#include <glPositionOffset>\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec3 v_baseColor;\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\nuniform vec3 u_screenPosition;\nuniform sampler2D u_areaLightCookies[1];\n\nvoid main () {\n\tvNormal = normalize( normalMatrix * normal );\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\tvViewPosition = - mvPosition.xyz;\n\n\tvec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\tvec3 delta = (worldPosition - u_screenPosition) / 50.0;\n\tv_baseColor = lodMipmapSampleNearestCubic(u_areaLightCookies[0], clamp(vec2(0.5, 0.5) + delta.xy, vec2(0.0), vec2(1.0)), 3.0 + abs(delta.z / 10.0), u_screenTextureSize, u_screenMipmapTextureSize).rgb;\n\n\tv_uv = uv;\n\tgl_Position = projectionMatrix * mvPosition;\n\tgl_Position = glPositionOffset(gl_Position);\n}"]), p.fragmentShader = h(["#define GLSLIFY 1\n#define STANDARD\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\n// #include <getBlueNoise>\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\n\nuniform sampler2D u_infoTexture;\n\nvarying vec2 v_uv;\nvarying vec3 v_baseColor;\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\n\n#include <common>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, vec3 mapN ) {\n\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See vec4(0.6,0.6,0.5333333333333333,0.5333333333333333)\n\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\tvec2 st0 = dFdx( v_uv );\n\tvec2 st1 = dFdy( v_uv );\n\n\tmapN.xy *= normalScale;\n\n\t// solve the linear system\n\tvec3 dp2perp = cross( q1, surf_norm );\n\tvec3 dp1perp = cross( surf_norm, q0 );\n\tvec3 T = dp2perp * st0.x + dp1perp * st1.x;\n\tvec3 B = dp2perp * st0.y + dp1perp * st1.y;\n\n\t// construct a scale-invariant frame\n\tfloat invmax = 1.0 / sqrt( max( dot(T,T), dot(B,B) ) );\n\tmat3 tsn = mat3( T * invmax, B * invmax, surf_norm );\n\treturn normalize( tsn * mapN );\n}\n\nvoid main () {\n\t// vec3 blueNoise = getBlueNoise(gl_FragCoord.xy);\n\t// vec3 infoColor = texture2D(u_infoTexture, v_uv + blueNoise.xy / 1024.0).rgb;\n\tvec3 infoColor = texture2D(u_infoTexture, v_uv).rgb;\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tfloat roughnessFactor = roughness;\n\tfloat metalnessFactor = metalness;\n\n\tvec3 mapN = vec3(infoColor.xy, 1.0) * 2.0 - 1.0;\n\tmapN.z = sqrt(1.0 - min(1.0, mapN.x * mapN.x + mapN.y * mapN.y));\n\tvec3 normal = normalize(vNormal);\n\tnormal = perturbNormal2Arb( -vViewPosition, normal, vec2(1.0, -1.0), normalize(mapN));\n\tvec3 geometryNormal = normal;\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( max(outgoingLight * infoColor.b * 0.45, infoColor.bbb * 0.1 * v_baseColor), diffuseColor.a );\n}"]), r.isMobile && (p.defines.IS_MOBILE = !0);
                d = n.container = new f.Mesh(m, p), c.container.add(d), g = !0
            }(), d.visible = "person" == o.modelId)
        }, n.hasStartedLoad = !1;
        var d = n.container = null,
            m = void 0,
            p = void 0,
            v = void 0,
            g = !1;

        function y(e) {
            var t = 0,
                n = void 0;
            m = new f.BufferGeometry;
            var r = {
                    position: Float32Array,
                    uv: Float32Array,
                    normal: Float32Array,
                    indices: Uint16Array
                },
                i = new Int16Array(e, t, 17730);
            n = new r.position(17730);
            for (var o = 0, a = 0; o < 5910; o++) n[a + 0] = 3.76528668 + (i[a + 0] - -32768) / 65535 * .4250624199999997, n[a + 1] = (i[a + 1] - -32768) / 65535 * 1.632646632738 - .000874832738, n[a + 2] = 3.47016954 + (i[a + 2] - -32768) / 65535 * .43467259999999985, a += 3;
            i = n, m.setAttribute("position", new f.BufferAttribute(i, 3)), t += 35460;
            var s = new Int16Array(e, t, 11820);
            n = new r.uv(11820);
            for (var l = 0, c = 0; l < 5910; l++) n[c + 0] = .00190000003 + (s[c + 0] - -32768) / 65535 * .97289999097, n[c + 1] = .00187591696 + (s[c + 1] - -32768) / 65535 * .99607624604, c += 2;
            s = n, m.setAttribute("uv", new f.BufferAttribute(s, 2)), t += 23640;
            var u = new Int16Array(e, t, 17730);
            n = new r.normal(17730);
            for (var h = 0, d = 0; h < 5910; h++) n[d + 0] = (u[d + 0] - -32768) / 65535 * 1.9993848810000001 - .999570847, n[d + 1] = (u[d + 1] - -32768) / 65535 * 1.9996310469999998 - .999989092, n[d + 2] = (u[d + 2] - -32768) / 65535 * 1.999926508 - .999933541, d += 3;
            u = n, m.setAttribute("normal", new f.BufferAttribute(u, 3)), t += 35460;
            var p = new Uint16Array(e, t, 30510);
            m.setIndex(new f.BufferAttribute(p, 1)), t += 61020
        }
    }, {
        "../../core/browser": 65,
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../effects/blueNoise/blueNoise": 70,
        "../../effects/glPositionOffset/glPositionOffset": 72,
        "../screen/screen": 128,
        "../visual": 133,
        glslify: 8,
        "mout/object/mixIn": 32,
        three: 57
    }],
    128: [function(e, t, n) {
        "use strict";
        var r = e("../../core/settings"),
            i = (e("../../core/properties"), e("../../helpers/fboHelper"), e("./screenShader")),
            o = e("./screenLight"),
            a = e("./screenMesh"),
            s = e("three");
        n.preInit = function() {
            c = n.container = new s.Object3D
        }, n.init = function() {
            i.init(), o.init(), c.add(o.light), o.light.position.set(4, 3.5, -2), o.light.updateMatrixWorld(!0), a.init(), c.add(a.mesh), a.mesh.position.set(4, 3.5, -1.45), a.mesh.scale.set(r.SCREEN_SIZE, r.SCREEN_SIZE, 1), l.u_screenPosition = {
                value: o.light.position
            }
        }, n.update = function(e) {
            i.update(e), a.update(e)
        };
        var l = n.sharedUniforms = {},
            c = n.container = null
    }, {
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../helpers/fboHelper": 74,
        "./screenLight": 129,
        "./screenMesh": 130,
        "./screenShader": 131,
        three: 57
    }],
    129: [function(e, t, n) {
        "use strict";
        var r = e("../../core/settings"),
            i = e("three");
        n.init = function() {
            (n.light = new i.RectAreaLight(16777215, 10, r.SCREEN_SIZE, r.SCREEN_SIZE)).rotation.y = Math.PI
        };
        n.light = null
    }, {
        "../../core/settings": 68,
        three: 57
    }],
    130: [function(e, t, n) {
        "use strict";
        var r = e("../../core/browser"),
            S = e("../../core/settings"),
            i = e("../../core/properties"),
            o = e("../../effects/glPositionOffset/glPositionOffset"),
            a = e("../../effects/blueNoise/blueNoise"),
            s = e("./screen"),
            M = e("../../utils/math"),
            l = e("mout/object/mixIn"),
            T = e("three"),
            c = e("glslify");
        n.init = function() {
            (function() {
                for (var e = S.SCREEN_SEGMENTS, t = S.SCREEN_SEGMENTS + 2, n = t - 1, r = new Float32Array(t * t * 3), i = new Float32Array(t * t * 2), o = new Uint32Array(n * n * 6), a = 0, s = 0, l = 0; a < t; a++) {
                    var c = (M.clamp(a - 1, 0, e) + .5) / (e + 1),
                        u = M.clamp(a - 1, 0, e) / e - .5,
                        h = !1;
                    0 == a ? h = !0 : a == t - 1 ? h = !0 : c = c;
                    for (var d = 0; d < t; d++) {
                        var p = (M.clamp(d - 1, 0, e) + .5) / (e + 1),
                            f = M.clamp(d - 1, 0, e) / e - .5,
                            m = !1;
                        0 == d ? m = !0 : d == t - 1 ? m = !0 : p = p, r[l + 0] = f, r[l + 1] = u, r[l + 2] = m || h, i[s + 0] = p, i[s + 1] = c, s += 2, l += 3
                    }
                }
                for (var v = 0, g = 0; v < n; v++)
                    for (var y = 0; y < n; y++) {
                        var x = y + t * v,
                            b = y + t * (v + 1),
                            _ = y + 1 + t * (v + 1),
                            w = y + 1 + t * v;
                        o[g + 0] = x, o[g + 1] = w, o[g + 2] = b, o[g + 3] = b, o[g + 4] = w, o[g + 5] = _, g += 6
                    }(E = new T.BufferGeometry).setAttribute("position", new T.BufferAttribute(r, 3)), E.setAttribute("uv", new T.BufferAttribute(i, 2)), E.setIndex(new T.BufferAttribute(o, 1))
            })(), u = new T.ShaderMaterial({
                uniforms: l({
                    u_resolution: i.sharedUniforms.u_resolution
                }, s.sharedUniforms, a.sharedUniforms, o.sharedUniforms),
                vertexShader: c(["#define GLSLIFY 1\nuniform sampler2D u_screenTexture;\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_resolution;\n\n#ifdef IS_HD\nvarying vec2 v_uv;\n#else\nvarying vec3 v_color;\n#endif\n\n#include <glPositionOffset>\n\nvoid main () {\n\tfloat isEdge = step(0.5, position.z);\n\n\tvec2 texCoord = clamp(uv * u_screenTextureSize, vec2(0.5), vec2(u_screenTextureSize - 0.5)) + u_glPositionOffset * u_resolution * 0.5;\n\n\tvec4 screenInfo = texture2D(u_screenTexture, texCoord / u_screenTextureSize * vec2(0.66666, 1.0));\n\tvec3 pos = vec3(position.xy, screenInfo.a * 2.0);\n\n\t#ifdef IS_HD\n\tv_uv = uv;\n\t#else\n\tv_color = screenInfo.rgb;\n\t#endif\n\n\tpos.z *= (1.0 - isEdge);\n\tpos.z -= 0.5;\n\n\t\n\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n\tgl_Position = glPositionOffset(gl_Position);\n}"]),
                fragmentShader: c(["#define GLSLIFY 1\nuniform sampler2D u_screenTexture;\n\n#ifdef IS_HD\nvarying vec2 v_uv;\n#else\nvarying vec3 v_color;\n#endif\n\nvoid main () {\n\t#ifdef IS_HD\n\tvec4 screenInfo = texture2D(u_screenTexture, v_uv * vec2(0.66666, 1.0));\n\tgl_FragColor = vec4(screenInfo.rgb, 1.0);\n\t#else\n\tgl_FragColor = vec4(v_color, 1.0);\n\t#endif\n}"])
            }), r.isMobile || (u.defines.IS_HD = !0);
            u.extensions.derivatives = !0, n.mesh = new T.Mesh(E, u)
        }, n.resize = function(e, t) {}, n.update = function(e) {};
        n.mesh = null;
        var E = void 0,
            u = void 0
    }, {
        "../../core/browser": 65,
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../effects/blueNoise/blueNoise": 70,
        "../../effects/glPositionOffset/glPositionOffset": 72,
        "../../utils/math": 124,
        "./screen": 128,
        glslify: 8,
        "mout/object/mixIn": 32,
        three: 57
    }],
    131: [function(e, t, n) {
        "use strict";
        var r = e("../../core/settings"),
            i = e("../../core/browser"),
            c = e("../../core/properties"),
            o = e("./screen"),
            a = e("./screenLight"),
            u = e("../../helpers/fboHelper"),
            s = e("../../shaders/shaders"),
            l = e("../../effects/blueNoise/blueNoise"),
            h = e("../../io/exporter"),
            d = e("../../effects/mipmapper/Mipmapper"),
            p = e("../../controls/cameraControls"),
            f = e("mout/object/mixIn"),
            m = e("three"),
            v = e("glslify");
        n.preInitTester = X, n.init = function() {
            X(), L = u.createRenderTarget(r.SCREEN_RESOLUTION, r.SCREEN_RESOLUTION, !0), P = L.clone(), A = u.createRenderTarget(r.SCREEN_RESOLUTION, r.SCREEN_RESOLUTION / 2, !0), R = A.clone(), y = new d, _ = new m.Vector2(r.SCREEN_RESOLUTION, r.SCREEN_RESOLUTION), x = u.createRenderTarget(1.5 * _.x, _.y, !0), y.resize(_.x, _.y, x.width, x.height), F = new m.Matrix4, H = new m.Euler(0, Math.PI, 0), G = new m.Quaternion, V = new m.Vector3, z = new m.Vector2(2 * r.SCREEN_RESOLUTION, 2 * r.SCREEN_RESOLUTION), N = new m.Raycaster, k = new m.Plane(new m.Vector3(0, 0, 1), 2), m.ShaderLib.standard.uniforms.u_areaLightCookies = {
                value: [x.texture]
            }, m.ShaderLib.physical.uniforms.u_areaLightCookies = {
                value: [x.texture]
            }, S.u_screenTextureSize = {
                value: _
            }, S.u_screenMipmapTextureSize = {
                value: y.textureSize
            }, S.u_screenNoiseTexture = {
                value: L.texture
            }, S.u_screenNormalAOTexture = {
                value: P.texture
            }, S.u_screenTexture = {
                value: x.texture
            }, f(o.sharedUniforms, S), (M = new m.RawShaderMaterial({
                uniforms: T.uniforms,
                vertexShader: T.vertexShader,
                fragmentShader: "",
                depthTest: !1,
                depthWrite: !1,
                blending: m.NoBlending,
                transparent: !0
            })).extensions.derivatives = !0, E = new m.RawShaderMaterial({
                uniforms: {
                    iResolution: M.uniforms.iResolution,
                    u_oddTexture: {
                        value: A.texture
                    },
                    u_evenTexture: {
                        value: R.texture
                    }
                },
                vertexShader: u.vertexShader,
                fragmentShader: u.precisionPrefix + v(["#define GLSLIFY 1\nuniform sampler2D u_oddTexture;\nuniform sampler2D u_evenTexture;\nuniform vec2 iResolution;\n\nvarying vec2 v_uv;\n\nvoid main () {\n\tvec2 uv = vec2(\n\t\tv_uv.x,\n\t\t(floor(gl_FragCoord.y * 0.5) + 0.5) / (iResolution.y * 0.5)\n\t);\n\n\tgl_FragColor = mix(\n\t\ttexture2D(u_evenTexture, uv),\n\t\ttexture2D(u_oddTexture, uv),\n\t\tstep(1.0, mod(gl_FragCoord.y, 2.0))\n\t);\n}"]),
                depthTest: !1,
                depthWrite: !1,
                blending: m.NoBlending,
                transparent: !0
            }), (w = new m.RawShaderMaterial({
                uniforms: f({
                    u_screenAOSampleRange: {
                        value: .1
                    },
                    u_screenHeightScale: {
                        value: .1
                    },
                    u_noiseOffset: {
                        value: new m.Vector2
                    }
                }, S, l.sharedUniforms),
                vertexShader: u.vertexShader,
                fragmentShader: u.precisionPrefix + v(["#define GLSLIFY 1\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_noiseOffset;\nuniform sampler2D u_screenNoiseTexture;\nuniform float u_screenHeightScale;\nuniform float u_screenAOSampleRange;\n\nvarying vec2 v_uv;\n\nconst float PI2 = 6.2831853;\n\n// https://github.com/mrdoob/three.js/blob/ecb116f6af0a63558b707369f15d680a59ba736d/examples/webgl_shadowmap_pcss.html\nvec2 poissonDisk[SAMEPLE_COUNT];\n\nvoid initPoissonSamples(float noise) {\n\tfloat ANGLE_STEP = PI2 * 4.0 / float( SAMEPLE_COUNT );\n\tfloat INV_SAMEPLE_COUNT = 1.0 / float( SAMEPLE_COUNT );\n\tfloat angle = noise * PI2;\n\tfloat radius = INV_SAMEPLE_COUNT;\n\tfloat radiusStep = radius;\n\tfor( int i = 0; i < SAMEPLE_COUNT; i ++ ) {\n\t\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t}\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid main () {\n\tfloat center = texture2D(u_screenNoiseTexture, v_uv).a;\n\tvec2 texelSize = 1.0 / u_screenTextureSize;\n\tvec3 dX = vec3(texelSize.x * 2.0, 0.0, (\n\t\t\ttexture2D(u_screenNoiseTexture, v_uv + vec2(texelSize.x, 0.0)).a -\n\t\t\ttexture2D(u_screenNoiseTexture, v_uv - vec2(texelSize.x, 0.0)).a\n\t\t) * u_screenHeightScale\n\t);\n\tvec3 dY = vec3(0.0, texelSize.y * 2.0, (\n\t\t\ttexture2D(u_screenNoiseTexture, v_uv + vec2(0.0, texelSize.y)).a -\n\t\t\ttexture2D(u_screenNoiseTexture, v_uv - vec2(0.0, texelSize.y)).a\n\t\t) * u_screenHeightScale\n\t);\n\n\tvec3 n = normalize(cross(dX, dY)) * 0.5 + 0.5;\n\tinitPoissonSamples(hash12((v_uv + u_noiseOffset) * 100.0));\n\n\tfloat sum = 0.0;\n\tfor( int i = 0; i < SAMEPLE_COUNT; i ++ ) {\n\t\tvec2 offset = poissonDisk[i] * u_screenAOSampleRange;\n\t\tfloat r = texture2D(u_screenNoiseTexture, v_uv + offset).a;\n\t\tsum += max(0.0, r - center);\n\t}\n\tfloat ao = 1.0 - sum / float(SAMEPLE_COUNT);\n\n\tgl_FragColor = vec4(\n\t\tn.x,\n\t\tn.y,\n\t\tao * ao * ao,\n\t\t1.0\n\t);\n}"]),
                depthTest: !1,
                depthWrite: !1,
                blending: m.NoBlending,
                transparent: !0
            })).defines.SAMEPLE_COUNT = 32, b = new m.RawShaderMaterial({
                uniforms: f({}, S),
                vertexShader: u.vertexShader,
                fragmentShader: u.precisionPrefix + v(["#define GLSLIFY 1\nuniform sampler2D u_screenNoiseTexture;\nuniform sampler2D u_screenNormalAOTexture;\n\n// uniform float u_screenUseCustomColor;\n\nvarying vec2 v_uv;\n\nvoid main () {\n\tvec4 screenInfo = texture2D(u_screenNoiseTexture, v_uv);\n\tvec3 shade = texture2D(u_screenNormalAOTexture, v_uv).rgb;\n\tvec3 n = vec3(shade.rg * 2.0 - 1.0, 0.0);\n\tn.z = sqrt(1.0 - n.x * n.x - n.y * n.y);\n\n\tvec3 color = mix(mix(vec3(0.050980392156862744,0.2196078431372549,0.24313725490196078), vec3(0.9019607843137255,0.9686274509803922,0.9803921568627451), shade.b), screenInfo.rgb * (0.3 + 0.7 * shade.b), 1.0);\n\tfloat f = max(dot(n, vec3(0.5774)), 0.0);\n\tcolor *= mix(0.75, 1.0, f * f * 0.3 + f * 0.7);\n\t\n\tgl_FragColor = vec4(color, screenInfo.a);\n}"]),
                depthTest: !1,
                depthWrite: !1,
                blending: m.NoBlending,
                transparent: !0
            }), p.modes.splines.onAnimationStarted.add(Y), c.isView ? Z(c.currentSketch.shader) : Z(s.infos[c.templateShaderId].shader);
            h.onBeforeRender.add(K)
        }, n.changeShader = Z, n.testShader = function(e) {
            var t = q.replace(g, e);
            T.fragmentShader = t, T.userData.originalShader = e, T.needsUpdate = !0;
            var n = u.getColorState();
            u.render(T, C), u.getColorState(n);
            for (var r = u.renderer.info.programs, i = !0, o = 0, a = r.length; o < a; o++) {
                var s = r[o].diagnostics;
                if (void 0 !== s && s.material === T) {
                    if (!s.runnable) return i = !1, s;
                    break
                }
            }
            if (i) return !1
        }, n.update = function(e) {
            if (h.isExporting) return;
            c.shaderTime += e * c.shaderTimeMultiplier, M.uniforms.iTime.value = c.shaderTime, M.uniforms.iTimeDelta.value = e, M.uniforms.iFrame.value = c.shaderFrame++, M.uniforms.iFrameRate.value = 1 / e;
            var t = new Date;
            D.set(t.getFullYear(), t.getMonth(), t.getDate(), 3600 * t.getHours() + 60 * t.getMinutes() + t.getSeconds() + t.getMilliseconds() / 1e3), G.setFromEuler(H), F.makeRotationFromQuaternion(G).premultiply(a.light.matrixWorld), F.getInverse(F).multiply(c.camera.matrixWorld), F.decompose(B, G, V), U.set(G.x, G.y, G.z, G.w), c.isMouseDown && (N.setFromCamera(c.mouse, c.camera), N.ray.intersectPlane(k, V), I.x = (V.x + 3 - 4) / 6 * r.SCREEN_RESOLUTION, I.y = (V.y + 3 - 3.5) / 6 * r.SCREEN_RESOLUTION);
            c.hasMouseJustDown ? (N.setFromCamera(c.mouseDown, c.camera), N.ray.intersectPlane(k, V), I.z = z.x = (V.x + 3 - 4) / 6 * r.SCREEN_RESOLUTION, I.w = z.y = (V.y + 3 - 3.5) / 6 * r.SCREEN_RESOLUTION) : c.isMouseDown ? (I.z = z.x, I.w = z.y) : (I.z = 2 * r.SCREEN_RESOLUTION - I.x, I.w = 2 * r.SCREEN_RESOLUTION - I.y);
            J()
        }, n.shaderLineStart = -1;
        var g = "/*ADD_GET_NOISE_SHADER*/",
            y = void 0,
            x = void 0,
            b = void 0,
            _ = void 0,
            w = void 0,
            S = {},
            M = void 0,
            T = void 0,
            E = void 0,
            C = void 0,
            L = void 0,
            A = void 0,
            R = void 0,
            P = void 0,
            O = void 0,
            I = void 0,
            D = void 0,
            N = void 0,
            k = void 0,
            z = void 0,
            F = void 0,
            B = void 0,
            U = void 0,
            H = void 0,
            G = void 0,
            V = void 0,
            W = !1,
            j = !0,
            q = void 0;

        function X() {
            if (!q) {
                var e = (r.USE_WEBGL2 ? u.precisionPrefix2 : u.precisionPrefix) + "#define HW_PERFORMANCE " + (i.isMobile ? "0" : "1") + "\n";
                q = e + v(["#define IS_CINESHADER\n#ifdef IS_WEBGL2\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\nuniform int iFrame;\n#else\nprecision highp float;\n#define GLSLIFY 1\n#endif\n\nuniform vec3 iResolution;\nuniform float iTime;\nuniform float iTimeDelta;\n\nuniform float iFrameRate;\nuniform vec4 iMouse;\nuniform vec4 iDate;\n\nuniform vec3 iCamPos;\nuniform vec4 iCamQuat;\nuniform vec3 iScreenSize;\n\nuniform vec2 u_interlaceParams;\nuniform vec2 u_aaOffset;\n\n/*ADD_GET_NOISE_SHADER*/\n\nvoid main () {\n\tgl_FragColor = vec4(0.1);\n\n\tvec2 fragCoord = vec2(\n\t\tgl_FragCoord.x,\n\t\tfloor(gl_FragCoord.y) * u_interlaceParams.x + u_interlaceParams.y\n\t) + u_aaOffset;\n\n\tmainImage(gl_FragColor, fragCoord);\n}\n"]), n.shaderLineStart = q.split(g)[0].split(/\r\n|\r|\n/).length, C = u.createRenderTarget(1, 1, !0), (T = new m.RawShaderMaterial({
                    uniforms: {
                        iResolution: {
                            value: new m.Vector3(r.SCREEN_RESOLUTION, r.SCREEN_RESOLUTION, 1)
                        },
                        iTime: {
                            value: 0
                        },
                        iTimeDelta: {
                            value: 0
                        },
                        iFrame: {
                            value: 0
                        },
                        iFrameRate: {
                            value: 0
                        },
                        iMouse: {
                            value: I = new m.Vector4(0, 0, 2 * -r.SCREEN_RESOLUTION, 2 * -r.SCREEN_RESOLUTION)
                        },
                        iDate: {
                            value: D = new m.Vector4
                        },
                        iCamPos: {
                            value: B = new m.Vector3
                        },
                        iCamQuat: {
                            value: U = new m.Vector4
                        },
                        iScreenSize: {
                            value: new m.Vector3(r.SCREEN_SIZE, r.SCREEN_SIZE, 2)
                        },
                        u_interlaceParams: {
                            value: new m.Vector2(1, .5)
                        },
                        u_aaOffset: {
                            value: new m.Vector2(1, .5)
                        }
                    },
                    vertexShader: e + v(["#define GLSLIFY 1\n#ifdef IS_WEBGL2\nin vec3 position;\n#else\nattribute  vec3 position;\n#endif\n\nvoid main() {\n    gl_Position = vec4(position, 1.0 );\n}\n"]),
                    fragmentShader: "",
                    depthTest: !1,
                    depthWrite: !1,
                    blending: m.NoBlending,
                    transparent: !0
                })).extensions.derivatives = !0
            }
        }

        function Y(e) {
            "splines" !== p.pendingId || "splines" !== p.currId || c.isView || Z(s.splineShaderList[e % s.splineShaderList.length].shader)
        }

        function Z(e) {
            if (O !== e && void 0 !== e) {
                O = e;
                var t = q.replace(g, e);
                T.fragmentShader = t, T.userData.originalShader = e, T.needsUpdate = !0;
                var n = u.getColorState();
                u.render(T, C), u.getColorState(n);
                for (var r = u.renderer.info.programs, i = !0, o = 0, a = r.length; o < a; o++) {
                    var s = r[o].diagnostics;
                    if (void 0 !== s && s.material === T) {
                        s.runnable || (i = !1, c.onShaderCompiled.dispatch(!1, s));
                        break
                    }
                }
                if (i) {
                    var l = M;
                    M = T, T = l, c.currentSketch && c.isEditor && (c.currentSketch.shader = e), c.onShaderCompiled.dispatch(!0)
                }
            }
        }

        function K(e, t) {
            T.uniforms.u_aaOffset.value.set(.5 * t.x, .5 * t.y), J(), T.uniforms.u_aaOffset.value.set(0, 0)
        }

        function J() {
            var e = c.useInterlacing || c.viewQuality < 3,
                t = u.getColorState();
            e ? ((j = !j) ? (M.uniforms.u_interlaceParams.value.set(2, .5), u.render(M, R)) : (M.uniforms.u_interlaceParams.value.set(2, 1.5), u.render(M, A)), W || (j ? u.copy(R.texture, A) : u.copy(A.texture, R)), u.render(E, L)) : (M.uniforms.u_interlaceParams.value.set(1, .5), u.render(M, L)), w.uniforms.u_noiseOffset.value.set(Math.random(), Math.random()), u.render(w, P);
            var n = u.renderer;
            n.setRenderTarget(x), n.setViewport(0, 0, _.x, _.y), n.setScissor(0, 0, _.x, _.y), n.setScissorTest(!0), u.render(b), n.setRenderTarget(null), n.setViewport(0, 0, c.width, c.height), n.setScissor(0, 0, c.width, c.height), y.render(x), u.getColorState(t), W = e
        }
    }, {
        "../../controls/cameraControls": 63,
        "../../core/browser": 65,
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../effects/blueNoise/blueNoise": 70,
        "../../effects/mipmapper/Mipmapper": 73,
        "../../helpers/fboHelper": 74,
        "../../io/exporter": 78,
        "../../shaders/shaders": 94,
        "./screen": 128,
        "./screenLight": 129,
        glslify: 8,
        "mout/object/mixIn": 32,
        three: 57
    }],
    132: [function(e, t, n) {
        "use strict";
        var r = e("../../core/browser"),
            i = e("../../core/settings"),
            o = e("../../core/properties"),
            a = e("../../effects/glPositionOffset/glPositionOffset"),
            s = e("../../effects/blueNoise/blueNoise"),
            l = e("../screen/screen"),
            c = e("mout/object/mixIn"),
            m = e("three"),
            u = e("glslify");
        n.preInit = function() {
            o.loader.add(i.MODEL_PATH + "stage.buf", {
                type: "xhr",
                responseType: "arraybuffer",
                weight: 824,
                onLoad: b
            }), o.loader.add(i.MODEL_PATH + "stage_screen_edges.buf", {
                type: "xhr",
                responseType: "arraybuffer",
                weight: 1,
                onLoad: _
            }), (x = new m.Texture(o.loader.add(i.TEXTURE_PATH + "stage.jpg", {
                weight: 565,
                onLoad: function() {
                    x.needsUpdate = !0
                }
            }).content)).generateMipmaps = !1, x.magFilter = x.minFilter = m.LinearFilter
        }, n.init = function() {
            h = n.container = new m.Object3D, (d = new m.MeshStandardMaterial({
                roughness: .35,
                metalness: .18
            })).type = "ShaderMaterial", d.uniforms = c({
                u_infoTexture: {
                    value: x
                }
            }, m.UniformsUtils.merge([m.ShaderLib.standard.uniforms]), s.sharedUniforms, a.sharedUniforms, l.sharedUniforms), d.vertexShader = u(["#define GLSLIFY 1\n#define STANDARD\n\nvarying vec2 v_uv;\n\n#include <glPositionOffset>\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec3 v_baseColor;\n\n#ifdef IS_EDGES\nvarying vec4 v_edgeInfos;\n#endif\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\nuniform vec3 u_screenPosition;\nuniform sampler2D u_areaLightCookies[1];\n\nvoid main () {\n\tvNormal = normalize( normalMatrix * normal );\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\tvViewPosition = - mvPosition.xyz;\n\n\tvec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\tvec3 delta = (worldPosition - u_screenPosition) / 50.0;\n\tv_baseColor = lodMipmapSampleNearestCubic(u_areaLightCookies[0], clamp(vec2(0.5, 0.5) + delta.xy, vec2(0.0), vec2(1.0)), 3.0 + abs(delta.z / 10.0), u_screenTextureSize, u_screenMipmapTextureSize).rgb;\n\t\n\t#ifdef IS_EDGES\n\tvec2 edgeSampleUv = vec2(\n\t\t(position.x - 1.0) / 6.0,\n\t\t(position.y - 0.5) / 6.0\n\t);\n\tv_edgeInfos = vec4(\n\t\tedgeSampleUv, // uv\n\t\t(position.z + 1.5) * 2.0,\n\t\tnormal.z\n\t);\n\t#endif\n\n\tv_uv = uv;\n\tgl_Position = projectionMatrix * mvPosition;\n\tgl_Position = glPositionOffset(gl_Position);\n}"]), d.fragmentShader = u(["#define GLSLIFY 1\n#define STANDARD\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\n#include <getBlueNoise>\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\nuniform vec3 u_screenPosition;\n\nuniform sampler2D u_infoTexture;\n\nvarying vec2 v_uv;\nvarying vec3 v_baseColor;\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\n\n#ifdef IS_EDGES\nvarying vec4 v_edgeInfos;\n#endif\n\n#include <common>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main () {\n\tvec3 blueNoise = getBlueNoise(gl_FragCoord.xy);\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tfloat roughnessFactor = roughness;\n\tfloat metalnessFactor = metalness;\n\n\tvec3 normal = normalize( vNormal );\n\tvec3 geometryNormal = normal;\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\n\tvec3 infoColor = texture2D(u_infoTexture, v_uv + blueNoise.xy / 2048.0).rgb;\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#ifdef IS_EDGES\n\t\tvec2 edgeSampleUv = clamp(v_edgeInfos.xy, vec2(0.0), vec2(1.0));\n\t\tfloat lodOffset = length(max(vec2(0.0), abs(v_edgeInfos.xy - 0.5) - 0.5)) * 12.0 * 5.0 + v_edgeInfos.z * 2.0;\n\t\tfloat ao = 1.0;\n\t\tao *= 1.0 - lodMipmapSampleSmoothstep(u_areaLightCookies[0], edgeSampleUv, lodOffset + 1.0, u_screenTextureSize, u_screenMipmapTextureSize).a * 0.5;\n\t\tao *= 1.0 - lodMipmapSampleSmoothstep(u_areaLightCookies[0], edgeSampleUv, lodOffset + 2.0, u_screenTextureSize, u_screenMipmapTextureSize).a * 0.25;\n\t\tao *= 1.0 - lodMipmapSampleSmoothstep(u_areaLightCookies[0], edgeSampleUv, lodOffset + 3.0, u_screenTextureSize, u_screenMipmapTextureSize).a * 0.125;\n\t\t\n\t\tgl_FragColor = vec4( outgoingLight * 0.35 + 0.65 * v_baseColor, diffuseColor.a ) * mix(0.35, 1.0, v_edgeInfos.w * v_edgeInfos.w) * infoColor.r * ao;\n\t#else\n\t\tgl_FragColor = vec4( outgoingLight * infoColor.r + infoColor.r * 0.65 * v_baseColor, diffuseColor.a );\n\t#endif\n\n}"]), p = new m.Mesh(v, d), h.add(p), g = new m.MeshStandardMaterial({
                roughness: .35,
                metalness: .18
            }), r.isMobile && (d.defines.IS_MOBILE = !0, g.defines.IS_MOBILE = !0);
            g.type = "ShaderMaterial", g.uniforms = d.uniforms, g.vertexShader = u(["#define GLSLIFY 1\n#define STANDARD\n\nvarying vec2 v_uv;\n\n#include <glPositionOffset>\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec3 v_baseColor;\n\n#ifdef IS_EDGES\nvarying vec4 v_edgeInfos;\n#endif\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\nuniform vec3 u_screenPosition;\nuniform sampler2D u_areaLightCookies[1];\n\nvoid main () {\n\tvNormal = normalize( normalMatrix * normal );\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\tvViewPosition = - mvPosition.xyz;\n\n\tvec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\tvec3 delta = (worldPosition - u_screenPosition) / 50.0;\n\tv_baseColor = lodMipmapSampleNearestCubic(u_areaLightCookies[0], clamp(vec2(0.5, 0.5) + delta.xy, vec2(0.0), vec2(1.0)), 3.0 + abs(delta.z / 10.0), u_screenTextureSize, u_screenMipmapTextureSize).rgb;\n\t\n\t#ifdef IS_EDGES\n\tvec2 edgeSampleUv = vec2(\n\t\t(position.x - 1.0) / 6.0,\n\t\t(position.y - 0.5) / 6.0\n\t);\n\tv_edgeInfos = vec4(\n\t\tedgeSampleUv, // uv\n\t\t(position.z + 1.5) * 2.0,\n\t\tnormal.z\n\t);\n\t#endif\n\n\tv_uv = uv;\n\tgl_Position = projectionMatrix * mvPosition;\n\tgl_Position = glPositionOffset(gl_Position);\n}"]), g.fragmentShader = u(["#define GLSLIFY 1\n#define STANDARD\n\n#include <textureSmoothstep>\n#include <textureBicubic>\n#include <lodMipmapSample>\n\n#include <getBlueNoise>\n\nuniform vec2 u_screenTextureSize;\nuniform vec2 u_screenMipmapTextureSize;\nuniform vec3 u_screenPosition;\n\nuniform sampler2D u_infoTexture;\n\nvarying vec2 v_uv;\nvarying vec3 v_baseColor;\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\n\n#ifdef IS_EDGES\nvarying vec4 v_edgeInfos;\n#endif\n\n#include <common>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main () {\n\tvec3 blueNoise = getBlueNoise(gl_FragCoord.xy);\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tfloat roughnessFactor = roughness;\n\tfloat metalnessFactor = metalness;\n\n\tvec3 normal = normalize( vNormal );\n\tvec3 geometryNormal = normal;\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\n\tvec3 infoColor = texture2D(u_infoTexture, v_uv + blueNoise.xy / 2048.0).rgb;\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#ifdef IS_EDGES\n\t\tvec2 edgeSampleUv = clamp(v_edgeInfos.xy, vec2(0.0), vec2(1.0));\n\t\tfloat lodOffset = length(max(vec2(0.0), abs(v_edgeInfos.xy - 0.5) - 0.5)) * 12.0 * 5.0 + v_edgeInfos.z * 2.0;\n\t\tfloat ao = 1.0;\n\t\tao *= 1.0 - lodMipmapSampleSmoothstep(u_areaLightCookies[0], edgeSampleUv, lodOffset + 1.0, u_screenTextureSize, u_screenMipmapTextureSize).a * 0.5;\n\t\tao *= 1.0 - lodMipmapSampleSmoothstep(u_areaLightCookies[0], edgeSampleUv, lodOffset + 2.0, u_screenTextureSize, u_screenMipmapTextureSize).a * 0.25;\n\t\tao *= 1.0 - lodMipmapSampleSmoothstep(u_areaLightCookies[0], edgeSampleUv, lodOffset + 3.0, u_screenTextureSize, u_screenMipmapTextureSize).a * 0.125;\n\t\t\n\t\tgl_FragColor = vec4( outgoingLight * 0.35 + 0.65 * v_baseColor, diffuseColor.a ) * mix(0.35, 1.0, v_edgeInfos.w * v_edgeInfos.w) * infoColor.r * ao;\n\t#else\n\t\tgl_FragColor = vec4( outgoingLight * infoColor.r + infoColor.r * 0.65 * v_baseColor, diffuseColor.a );\n\t#endif\n\n}"]), g.defines.IS_EDGES = !0, y = new m.Mesh(f, g), h.add(y)
        }, n.resize = function(e, t) {}, n.update = function(e) {};
        var h = n.container = null,
            v = void 0,
            d = void 0,
            p = void 0,
            f = void 0,
            g = void 0,
            y = void 0,
            x = void 0;

        function b(e) {
            var t = 43426,
                n = 0,
                r = void 0;
            v = new m.BufferGeometry;
            var i = {
                    indices: Uint16Array,
                    position: Float32Array,
                    uv: Float32Array,
                    normal: Float32Array
                },
                o = new Uint16Array(e, n, 139395);
            v.setIndex(new m.BufferAttribute(o, 1)), n += 278790;
            var a = new Int16Array(e, n, 3 * t);
            r = new i.position(3 * t);
            for (var s = 0, l = 0; s < t; s++) r[l + 0] = (a[l + 0] + 32768) / 2151.8171171095137 - 5.43910122, r[l + 1] = (a[l + 1] + 32768) / 4799.337667340407 - .0107239997, r[l + 2] = (a[l + 2] + 32768) / 2293.6461674959055 - 4.49677277, l += 3;
            a = r, v.setAttribute("position", new m.BufferAttribute(a, 3)), n += 6 * t;
            var c = new Int16Array(e, n, 86852);
            r = new i.uv(86852);
            for (var u = 0, h = 0; u < t; u++) r[h + 0] = (c[h + 0] + 32768) / 65535, r[h + 1] = (c[h + 1] + 32768) / 65535, h += 2;
            c = r, v.setAttribute("uv", new m.BufferAttribute(c, 2)), n += 4 * t;
            var d = new Int8Array(e, n, 3 * t);
            r = new i.normal(3 * t);
            for (var p = 0, f = 0; p < t; p++) r[f + 0] = (d[f + 0] + 128) / 127.5 - 1, r[f + 1] = (d[f + 1] + 128) / 127.5 - 1, r[f + 2] = (d[f + 2] + 128) / 127.5 - 1, f += 3;
            d = r, v.setAttribute("normal", new m.BufferAttribute(d, 3))
        }

        function _(e) {
            var t = 0,
                n = void 0;
            f = new m.BufferGeometry;
            var r = {
                    position: Float32Array,
                    uv: Float32Array,
                    indices: Uint8Array,
                    normal: Float32Array
                },
                i = new Int16Array(e, t, 144);
            n = new r.position(144);
            for (var o = 0, a = 0; o < 48; o++) n[a + 0] = (i[a + 0] + 32768) / 9362.142857142857 + .5, n[a + 1] = (i[a + 1] + 32768) / 9362.142857142857, n[a + 2] = (i[a + 2] + 32768) / 131070 - 2, a += 3;
            i = n, f.setAttribute("position", new m.BufferAttribute(i, 3)), t += 288;
            var s = new Int16Array(e, t, 96);
            n = new r.uv(96);
            for (var l = 0, c = 0; l < 48; l++) n[c + 0] = (s[c + 0] + 32768) / 600548.4193320014 + .579034865, n[c + 1] = (s[c + 1] + 32768) / 600548.413828707 + .243261337, c += 2;
            s = n, f.setAttribute("uv", new m.BufferAttribute(s, 2)), t += 192;
            var u = new Uint8Array(e, t, 48);
            f.setIndex(new m.BufferAttribute(u, 1)), t += 48;
            var h = new Int8Array(e, t, 144);
            n = new r.normal(144);
            for (var d = 0, p = 0; d < 48; d++) n[p + 0] = (h[p + 0] + 128) / 127.5 - 1, n[p + 1] = (h[p + 1] + 128) / 127.5 - 1, n[p + 2] = (h[p + 2] + 128) / 255, p += 3;
            h = n, f.setAttribute("normal", new m.BufferAttribute(h, 3))
        }
    }, {
        "../../core/browser": 65,
        "../../core/properties": 67,
        "../../core/settings": 68,
        "../../effects/blueNoise/blueNoise": 70,
        "../../effects/glPositionOffset/glPositionOffset": 72,
        "../screen/screen": 128,
        glslify: 8,
        "mout/object/mixIn": 32,
        three: 57
    }],
    133: [function(e, t, n) {
        "use strict";
        var r = e("../core/properties"),
            i = e("./stage/stage"),
            o = e("./floor/floor"),
            a = e("./screen/screen"),
            s = e("./car/car"),
            l = e("./person/person"),
            c = e("three");
        e("glslify");
        n.preInit = function() {
            u = n.container = new c.Object3D, a.preInit(), i.preInit(), o.preInit();
            var e = h[r.modelId];
            e && e.preInit()
        }, n.init = function() {
            a.init(), i.init(), o.init(), u.add(i.container), u.add(o.mesh), u.add(a.container)
        }, n.resize = function(e, t) {
            i.resize(e, t), o.resize(e, t)
        }, n.update = function(e) {
            for (var t in a.update(e), i.update(e), o.mesh.visible = 0 < r.viewQuality, i.container.children[0].visible = 1 < r.viewQuality, h) {
                var n = h[t];
                t === r.modelId && n.preInit(), n.update()
            }
        };
        var u = n.container = null,
            h = {
                car: s,
                person: l
            }
    }, {
        "../core/properties": 67,
        "./car/car": 125,
        "./floor/floor": 126,
        "./person/person": 127,
        "./screen/screen": 128,
        "./stage/stage": 132,
        glslify: 8,
        three: 57
    }]
}, {}, [76]);
